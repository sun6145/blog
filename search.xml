<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spark01]]></title>
    <url>%2Fblog%2F2018%2F11%2F20%2Fspark01%2F</url>
    <content type="text"><![CDATA[回顾 大数据生态: 解决的问题: 分布式存储和分布式计算 ​ Google:GFS / MapReduce / Bigtable 基于三篇论文,产生了hadoop ​ hdfs: 分布式的存储 ​ MapReduce: 计算框架(离线计算) ​ facebook创建hive,SQL-ON_Hadoop,数据仓库的标准 ​ (以上的效率低,延时高) ​ 基于bigtable的hbase出现,(百万级别列,上10亿的行) 辅助工具: ​ flume: 日志收集工具 ​ sqoop:rdb关系型数据库 hdfs ​ Kafka: 消息队列 ​ azkaban:作业的调度 zookeeper: zookeeper:zookeeper做资源协调调度 比如hdfs-ha选举 azkaban:做任务调度task，比如mrjob的调度 再简单一点zookeeper调度的是集群内部的各个节点 azkaban调度的是俺们自己写的mr job 大数据计算 三大计算中心 离线计算（离线批处理）mapreduce 慢 实时计算（事件计算） storm flink 准实时计算 三大计算引擎 交互式计算引擎 hbase 图计算引擎 hame graph 机器学习引擎 mathout spark:基于内存的一站式的通用计算框架, 数据来源: Hdfs,mysql,local,kafka,hbase,hive 资源调度框架: yarn mesos standalone sparkCore :核心RDD(弹性式分布式数据集): 离线计算 sparkSql: sparkStreaming:准实时计算 sparkGrapht:图计算 sparkLLib: 机器学习 spark shell : 交互式计算 google开源的datacloud 一站式:Apache Beam Spark MRv1: 1. 可扩展差(jobTracker:即负责资源调度,又负责任务管理) 2. 可用性差(单点故障) 3. 资源利用率底,一些 Task 并不能充分利用 slot，而其他 Task也无法使用这些空闲的资源。 4. 不支持多种MR框架 MR2: 运行时环境被重构了。JobTracker被拆分成了通用的资源调度平台（ResourceManager，简称 RM）、,项目经理(整体资源分配,监控)节点管理器（NodeManager）、(单台资源的调度)负责各个计算框架的任务调度模型（ApplicationMaster，简称 AM）。 由于对 HDFS 的频繁操作（包括计算结果持久化、数据备份、资源下载及 Shuffle 等）导致磁盘 I/O 成为系统性能的瓶颈，因此只适用于离线数据处理或批处理，而不能支持对迭代式、交互式、流式数据的处理。 优势 减少磁盘 I/O Spark 允许将 map 端的中间输出和结果存储在内存中，reduce 端在拉取中间结果时避免了大量的磁盘 I/O。 Spark 将应用程序上传的源文件缓冲到 Driver 本地文件服务的内存中，当 Executor 执行任务时直接从 Driver 的内中读取，也节省了大量的磁盘 I/O。 增加并行度 由于将中间结果写到磁盘与从磁盘读取中间结果属于不同的环节，Hadoop 将它们简单的通过串行执行衔接起来。 Spark 把不同的环节抽象为 Stage，允许多个 Stage 既可以串行执行，又可以并行执行。 避免重新计算 当 Stage 中某个分区的 Task 执行失败后，会重新对此 Stage 调度，但在重新调度的时候会过滤已经执行成功的分区任务，所以不会造成重复计算和资源浪费。 可选的 Shuffle 和排序 灵活的内存管理策略 Spark 是 MapReduce 的替代方案，而且兼容 HDFS、Hive，可融入 Hadoop 的生态系统，以弥补 MapReduce 的不足。 概念 官网：http://spark.apache.org/ Spark 是一种快速、通用、可扩展的大数据分析引擎 2009 年诞生于加州大学伯克利分校 AMPLab 2010 年开源 2013 年 6 月成为 Apache 孵化项目 2014 年 2 月成为 Apache 顶级项目 应用场景 复杂的批量处理（Batch Data Processing），偏重点在于处理海量数据的能力，至于处理速度可忍受，通常的时间可能是在数十分钟到数小时； 基于历史数据的交互式查询（Interactive Query），通常的时间在数十秒到数十分钟之间 基于实时数据流的数据处理（Streaming Data Processing），通常在数百毫秒到数秒之间目前对以上三种场景需求都有比较成熟的处理框架： 第一种情况可以用 Hadoop 的 MapReduce 来进行批量海量数据处理第二种情况可以 Impala、Kylin 进行交互式查询第三中情况可以用 Storm 分布式处理框架处理实时流式数据 以上三者都是比较独立，各自一套维护成本比较高，而 Spark 的出现能够一站式平台满意以上需求。第一种情况使用 Spark Core 解决第二种情况使用 Spark SQL 解决第三种情况使用 Spark Streaming 解决 总结 Spark 场景有以下几个： Spark 是基于内存的迭代计算框架，适用于需要多次操作特定数据集的应用场合。需要反复操作的次数越多，所需读取的数据量越大，受益越大，数据量小但是计算密集度较大的场合，受益就相对较小 由于 RDD 的特性，Spark 不适用那种异步细粒度更新状态的应用，例如 web 服务的存储或者是增量的 web 爬虫和索引。就是对于那种增量修改的应用模型不适合 数据量不是特别大，但是要求实时统计分析需求 行业应用场景： Yahoo 将 Spark 用在 Audience Expansion 中的应用，进行点击预测和即席查询等 淘宝技术团队使用了 Spark 来解决多次迭代的机器学习算法、高计算复杂度的算法等。应用于内容推荐、社区发现等 腾讯大数据精准推荐借助 Spark 快速迭代的优势，实现了在“数据实时采集、算法实时训练、系统实时预测”的全流程实时并行高维算法，最终成功应用于广点通 PCTR 投放系统上。 优酷土豆将 Spark 应用于视频推荐(图计算)、广告业务，主要实现机器学习、图计算等迭代计算。 安装 三大主要版本：Spark-0.XSpark-1.X（主要 Spark-1.3 和 Spark-1.6）Spark-2.X（最新 Spark-2.3）官网首页：http://spark.apache.org/downloads.html Spark-2.3 需要依赖：Java 8+ 和 Python 2.7+/3.4+ 和 Scala 2.11 和 R 3.1+ 上传解压,添加环境变量 修改配置文件 spark-env.sh slaves spark-default.conf 发送到其他节点 配置高可用 修改sparK-env.sh 12export SPARK_DAEMON_JAVA_OPTS=&quot;-Dspark.deploy.recoveryMode=ZOOKEEPER -Dspark.deploy.zookeeper.url=bd1:2181,bd2:2181,bd3:2181 -Dspark.deploy.zookeeper.dir=/spark&quot; Spark相关的概念Master 是spark集群的管理者,或者是管理节点,在Spark基于yarn的方式运行过程中,master就是ResourceManager,基于自身的standalone模式运行就是集群中查看的master节点 作用:就是整体的资源调度 Worker 是spark集群中的工作节点,在spark基于yarn的方式运行过程中,workder就是nodemanager,基于自身的standalone模式运行就是集群中查看的Worker节点 作用:本台机器上面的资源调度 RDD 弹性式分布式数据集:能够被并行计算的,被分区存储在集群中的各个几点的数据集 存储的数据在rdd的对应的各个partition分区中 弹性:spark的数据在内存中进行存储或计算,当内存存储不了的时候,会将对应的数据外溢到磁盘中进行存储和计算 rdd的创建方式: 可以hdfs文件创建 还可以通过并行的scala的集合创建 在编码过程中还可以通过转化,将一个rdd转化为其他的rdd Application 提交的spark集群中去运行的完整的应用就是一个application ,当然,一个application由多个job组成 Job 每提交的集群一次，就会说触发一次action操作，就是提交一次spark作业job,从这个角度而言，一个application由多个job组成。 可以理解为MapReduce中的job SparkContext 整个application的应用的上下文对象 一个spark应用的入口就是sparkContext,是Spark作业中最重要的概念 Driver+ job就是Application Driver 驱动,简单理解,就是用来提交代码,提交job作业 job在集群中运行,而这些driver是在本地提交这些job作业的 Driver的部分就是在一 个application中除去job的部分都是Driver部分 Spark Rdd的计算过程 加载数据,从hdfs(hdfs://bd1807/data/hello.txt)中加载文件到内存中 将数据加载到不同的分区,每个节点有部分数据 将数据进行flatMap之后会生成一个新的rdd 数据不会保留,假设原始数据是1G,新的rdd数据也是1G,内存不断的增长 继续执行操作,转换成新的rdd(key,1) 执行reducebyKey ,不同partition的数据会分发到一个新paratiton.(聚合统计) 项目创建 创建一个sparkConfig对象,new SparkConfig(true),默认加载默认的配置信息 创建一个SparkContext对象,加载关联的sparkConf对象,加载外部数据源,产生rdd java的api多一个java—JavaSparkContext 在一个spark中,只能有一个active的SparkContext jsc.textFile(path): 加载外部的普通的文本文件 对rdd进行各种操作 关闭sparkcontext,释放资源 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package core.p1;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.*;import scala.Tuple2;import java.lang.reflect.Array;import java.lang.reflect.Parameter;import java.util.Arrays;import java.util.Iterator;public class _01WordCount7 &#123; public static void main(String[] args) &#123; SparkConf conf = new SparkConf(); conf.setMaster("local[2]"); conf.setAppName(_01WordCount7.class.getSimpleName()); JavaSparkContext jsc = new JavaSparkContext(conf); JavaRDD&lt;String&gt; linerdd = jsc.textFile("d:/data/hello.txt");// linerdd.foreach(new VoidFunction&lt;String&gt;() &#123;// @Override// public void call(String s) throws Exception &#123;// System.out.println(s);// &#125;// &#125;); //这些XXXXFunction中的参数，由二个部分， // 第一部分为输入，参考函数的调用者 // 第二部分为输出，看我们需要什么类型 JavaRDD&lt;String&gt; wordRDD = linerdd.flatMap(new FlatMapFunction&lt;String, String&gt;() &#123; @Override public Iterator&lt;String&gt; call(String s) &#123; //\s空白符号(制表符,回车等) // + 一个或多个 // * 匹配0 次huo多个 // ? 一次或0次 String[] temp = s.split("\\s+"); return Arrays.asList(temp).iterator(); &#125; &#125;);// wordRDD.foreach(new VoidFunction&lt;String&gt;() &#123;// @Override// public void call(String s) throws Exception &#123;// System.out.println(s);// &#125;// &#125;); //转为map(word,1) JavaPairRDD&lt;String, Integer&gt; pairRDD = wordRDD.mapToPair(new PairFunction&lt;String, String, Integer&gt;() &#123; @Override public Tuple2&lt;String, Integer&gt; call(String s) throws Exception &#123; return new Tuple2&lt;&gt;(s, 1); &#125; &#125;);// pairRDD.foreach(new VoidFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;// @Override// public void call(Tuple2&lt;String, Integer&gt; pair) throws Exception &#123;// System.out.println(pair._1+"\t"+pair._2);// &#125;// &#125;); //进行数据统计 JavaPairRDD&lt;String, Integer&gt; resultRDD = pairRDD.reduceByKey(new Function2&lt;Integer, Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer, Integer integer2) throws Exception &#123;// System.out.println(integer+"====================&gt;"+integer2); return integer + integer2; &#125; &#125;); //结果展示 resultRDD.foreach(new VoidFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123; @Override public void call(Tuple2&lt;String, Integer&gt; tuple2) throws Exception &#123; System.out.println(tuple2._1+"------"+tuple2._2); &#125; &#125;); //释放资源 jsc.close(); &#125;&#125; 错误12345678910SparkConf conf = new SparkConf();org.apache.spark.SparkException: A master URL must be set in your configuration原因:在构建一个spark作业的时候,一定要指定一个spark作业的运行方式conf.setMaster("local[2]");An application name must be set in your configuration必须要为设置一个应用名称名字随便.一般取类名conf.setAppName(_01WordCount7.class.getSimpleName()); spark的运行方式 local:在本地运行,在本地创建SparkContext对象 local:给当前Spark作业只分配一个cpu core ,一个线程运行,并行度是1 local[N]:给当前Spark作业只分配N个cpu core ,一个线程运行,并行度是N local[*]:根据当前机器,自动分配线程个数 local[N,R]:比上述多了一个允许失败的次数,R次 standlone:提交到集群运行,就是master运行,并行度需要在spark-submit脚本中进行设置 spark://bigdata01:7070 yarn:基于yarn的方式运行spark作业 yarn-cluster: sparkContext的创建在yarn集群中 yarn-client: sprakContext的创建在本地 测试环境： 一般使用yarn-client 生产环境： 使用yarn-cluster mesos(略) mesos-cluster mesos-client 基于lambda的WordCount 需要jdk1.8 1234567891011121314151617181920212223242526272829303132333435package core.p1;import org.apache.spark.SparkConf;import org.apache.spark.api.java.JavaPairRDD;import org.apache.spark.api.java.JavaRDD;import org.apache.spark.api.java.JavaSparkContext;import org.apache.spark.api.java.function.FlatMapFunction;import org.apache.spark.sql.SparkSession;import scala.Tuple2;import java.sql.SQLOutput;import java.util.Arrays;public class _02WordCountLambada &#123; public static void main(String[] args) &#123; SparkConf conf = new SparkConf().setAppName(_02WordCountLambada.class.getSimpleName()) .setMaster("local[2]"); JavaSparkContext jsc = new JavaSparkContext(conf); JavaRDD&lt;String&gt; linerdd = jsc.textFile("d:/data/hello.txt"); JavaRDD&lt;String&gt; wordRDD = linerdd.flatMap((line) -&gt; &#123; String[] fields = line.split("\\s+"); return Arrays.asList(fields).iterator(); &#125;); JavaPairRDD&lt;String, Integer&gt; pairRDD = wordRDD.mapToPair(word -&gt; new Tuple2&lt;String, Integer&gt;(word, 1)); JavaPairRDD&lt;String, Integer&gt; resultRDD = pairRDD.reduceByKey((v1, v2) -&gt; v1 + v2); resultRDD.foreach(s -&gt; System.out.println(s)); jsc.close(); &#125;&#125; Scala版本的SparkWordCount SparkContext创建 可能出现的错误,访问的时候要将hdfs-site.xml,core-site.xml放到resources目录下 1234567891011121314151617181920package com.aura.coreimport org.apache.spark.&#123;SparkConf, SparkContext&#125;object _01ScalaSpark &#123; def main(args: Array[String]): Unit = &#123; val conf = new SparkConf() .setAppName(s"$&#123;_01ScalaSpark.getClass.getSimpleName&#125;") .setMaster("local[2]") val sc = new SparkContext(conf) val lineRDD = sc.textFile("/hive.txt") val wordsRDD = lineRDD.flatMap(line=&gt;line.split("\\s+")) val pairRDD = wordsRDD.map(word =&gt; (word,1)) val resultRDD = pairRDD.reduceByKey((v1,v2)=&gt; v1+v2) resultRDD.foreach(r=&gt;println(r._1+"==&gt;"+r._2)) //释放资源 sc.stop() &#125;&#125; Scala版本的SparkWordCount SparkSession创建形式 123456789101112131415161718192021package com.aura.coreimport org.apache.spark.sql.SparkSessionimport org.apache.spark.&#123;SparkConf, SparkContext&#125;object _02ScalaSpark &#123; def main(args: Array[String]): Unit = &#123; val spark = SparkSession.builder() .appName(s"$&#123;_02ScalaSpark.getClass.getSimpleName&#125;") .master("local") .getOrCreate() val sc = spark.sparkContext val lineRDD = sc.textFile("hdfs://bd1807/hive.txt") val wordsRDD = lineRDD.flatMap(_.split("\\s+")) .map((_,1)).reduceByKey(_+_).foreach(println) //关闭 spark.stop() &#125;&#125; spark作业提交到集群 将之前的代码打成jar包 去掉master,将路径改为手动 123456789101112131415161718192021222324252627282930313233package com.aura.coreimport org.apache.spark.sql.SparkSessionobject _03SparkWordCountUpload &#123; def main(args: Array[String]): Unit = &#123; if(args==null || args.length&lt;1)&#123; println( """ |Paramenter Error! Usage:&lt;inputPath&gt; |inputPath: 程序数据输入源 """.stripMargin) System.exit(-1) &#125; var Array(inputPath)=args val spark = SparkSession.builder() .appName(s"$&#123;_02ScalaSpark.getClass.getSimpleName&#125;") .getOrCreate() val sc = spark.sparkContext val lineRDD = sc.textFile(inputPath) val wordsRDD = lineRDD.flatMap(_.split("\\s+")) .map((_,1)).reduceByKey(_+_) //.collect()//将集群中的rdd对应的partition中的数据,拉取到dirver中,在工作中慎用 .foreach(println) //关闭 spark.stop() &#125;&#125; 上传到虚拟机中 编写脚本 123456789export HADOOP_CONF_DIR=/home/sun/apps/hadoop-2.7.6/etc/hadoop/home/sun/apps/spark-2.2.2-bin-hadoop2.7/bin/spark-submit \--class com.aura.core._03SparkWordCountUpload \--master spark://hdp01:7077 \--deploy-mode client \--executor-memory 600M \--num-executors 1 \spark-wc.jar \hdfs://bd1807/hive.txt]]></content>
  </entry>
  <entry>
    <title><![CDATA[hbase03]]></title>
    <url>%2Fblog%2F2018%2F11%2F02%2Fhbase03%2F</url>
    <content type="text"><![CDATA[mapreduce如何读取habaseMapReduce 程序读取到hbase的数据的时候 ,其实一个result map犯法每次执行一次接收的参数就是一个record 存储hbaseshell : put &quot;user_info&quot; ,&quot;rk01&quot;,&quot;base_info:name&quot;,&quot;huangbo&quot; API:table.put(new Put(rowkey,cf,qualifier,value)) hbase在进行插入的粒度,其实是cell级别 ​ 每次插入的就是一个Mutation ​ put,delete ​ 查询出来的就是一个cell HBase 结合 MapReduce]]></content>
  </entry>
  <entry>
    <title><![CDATA[hbase]]></title>
    <url>%2Fblog%2F2018%2F10%2F31%2Fhbase%2F</url>
    <content type="text"><![CDATA[sql: 结构化查询语言,针对于二维表格的一种脚本语言 Nosqll: 这个类型的数据的数据存储格式:key-value 用一句话总结: 能使用sql语法进行增删改查的数据库就是sql数据库,否则就是nosql数据库 所谓的nosql数据库就是一个很大很大的map Nosql:No sql NoSQL: Not only SQL(基于各种nosql数据库都有sql客户端) hbase: put delete put get scan sql客户端: 用户编写的sql 这个工具帮助把这个sql转换成hbase认识的命令 hadoop是什么东西 平台 hdfs mapreducea yarn ntfs qq eclispse chrome windows(操作系统:桥梁 把软件所需要做的硬件资源进行管理 ) 一个完整的计算机: 操作系统 文件系统 提供一个计算模型 编写软件运行计算任务 一个完整的计算集群:—-&gt; 一台强大的服务器 功能: 把多个服务器组合在一起,形成一个整体 对于hadoop用户,不需要了解hadoop到底由多少台服务组成 我们只需要认为我们使用的hdfs 或者yarn等等都是一台服务器 HBase:123HBase 是一个 通过大量廉价 机器 解决海量数据的高速存储和读取的分布式数据库解决方案hbase其实就是一个大集群,内部由 12345678910111213mysqlhbase四维标（立体空间 +时间）相当于是二维表查出的结果是一个二维表student.get(rowkey,family,colume,timestampe)列簇：包含的key的个数可以不一致，可以不确定，可以随机指定student.get(rowkey,family,colume)=默认最新的值student.get(rowkey,family)=是这个rowkey,family的key-valuestudent.get(rowkey,family,colume//key,timestampe//value) HBase 这个 NoSQL 数据库的要点 ：① 高并发，以扩 展，解决海量数据集的随机实时增删改查② HBase 本质依然是 Key-Value 数据库， 查询数据功能很简单，不支持 join 等复杂操作( 可通过 Hive 支持来实现多表 join 等复杂操作)③ 不支持复杂的事务，只支持行级事务④ HBase 中支持的数据类型：byte[] （底层所有数据的存储都是字节数组）⑤ 主要用来存储结构化和半结构化的松散数据。】 HBase 中的表 特点1 、 大 ：一个表可以有上十亿行，上百万列2 、 面向列 ： 列可以灵活指定， 面向列( 族) 的存储和权限控制，列( 簇) 独立检索。3 、 稀疏 ：对于为空(null) 的列，并不占用存储空间，因此，表可以设计的非常稀疏。4 、 无 严格 模式 ：每行都有一个可排序的主键和任意多的列，列可以根据需要动态的增加，同一张表中不同的行可以有截然不同的列 关于存储系统的模式介绍：读模式：输入写入的时候不做检验，在读取数据的时候做模式校验，比如数据仓库 Hive写模式：数据库都是写模式的，在写入数据进入存储系统的时候做模式校验，比如 RDBMS 行键 （RowKey ） 与 NoSQL 数据库们一样，RowKey 是用来检索记录的主键。访问 HBase Table 中的行。 rowKey 行键可以是任意字符串(最大长度是 64KB，实际应用中长度一般为 10-100bytes)，最好是 16。(64位机器是8字节)在 HBase 内部，RowKey 保存为字节数组。 HBase 会对表中的数据按照 rowkey 排序(字典排序） 存储时，数据按照 RowKey 的字典序(byte order)排序存储。设计 Key 时，要充分排序存储这个特性，将经常一起读取的行存储放到一起。(位置相关性) 三种方式：1 、 通过单个 row key 访问2 、 通过 row key 的 的 range3 、全表扫描 列簇（Column Family） HBase 表中的每个列，都归属与某个列簇。 列 簇的 是表的 Schema 的一部分( 而列不是)， 必须在创建表的时候指定。指定好了列簇就不能更改。 列簇可以增加或者删除，删除的时候会删除这个列簇中的所有数据 列名都以列簇作为前缀。例如 courses:history，courses:math 都属于 courses 这个列簇。访问控制、磁盘和内存的使用统计等都是在列簇层面进行的。 列簇越多，在取一行数据时所要参与 IO、搜寻的文件就越多，所以，如果没有必要，不要设置太多的列簇，官网推荐是小于等于 3（最好就一个列簇） 时 间戳 （TimeStamp ） HBase 中通过 RowKey 和 Column 确定的为一个存储单元称为 Cell。 每个 Cell 都保存着同一份数据的多个版本。 版本通过时间戳来索引 时间戳的类型是 64 位整型。时间戳可以由 HBase(在数据写入时自动)赋值，此时时间戳是精确到毫秒的当前系统时间。 时间戳也可以由客户显式赋值。 每个Cell 中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。HBase 在查询的时候，默认返回最新版本/最近的数据。如果需要读取旧版本的数据，可以指定时间戳 数据版本回收方式：为了避免数据存在过多版本造成的的管理(包括存储和索引)负担 保存数据的最后 n 个版本 保存最近一段时间内的版本（设置数据的生命周期 TTL) 用户可以针对每个列簇进行设置。 单元格（Cell ） 由{RowKey, Column( =&lt;Column Family&gt; + &lt;Qualifier&gt;), Version} 唯一确定的单元。 Cell 中的数据是没有类型的，全部是字节码形式存储 HBase 应用场景 半结 构化或非结构化数据对于数据结构字段不够确定或杂乱无章很难按一个概念去进行抽取的数据适合用 HBase。而且 HBase 是面向列的，HBase 支持动态增加字段 记录非常稀疏RDBMS 的行有多少列是固定的，为 null 的列浪费了存储空间。而 HBase 为 null 的 Column是不会被存储的，这样既节省了空间又提高了读性能。 多版本数据对于需要存储变动历史记录的数据，使用 HBase 就再合适不过了。HBase 根据 Row key 和Column key 定位到的 Value 可以有任意数量的版本值。 超大数据 量 的随机、实时读写当数据量越来越大，RDBMS 数据库撑不住了，就出现了读写分离策略，通过一个 Master 专门负责写操作，多个 Slave 负责读操作，服务器成本倍增。随着压力增加，Master 撑不住了，这时就要分库了，把关联不大的数据分开部署，一些 join 查询不能用了，需要借助中间层。随着数据量的进一步增加，一个表的记录越来越大，查询就变得很慢，于是又得搞分表，比如按 ID 取模分成多个表以减少单个表的记录数。经历过这些事的人都知道过程是多么的折腾。采用 HBase 就简单了，只需要加机器即可，HBase 会自动水平切分扩展，跟 Hadoop 的无缝集成保障了其数据可靠性（HDFS）和海量数据分析的高性能（MapReduce）。 查询简单不涉及到复杂的 Join 查询，基于 RowKey 或者 RowKey 的范围查询 hbase 集群结构 Master HRegionServer 如果Master宕机 整个Hbase依然可用, master是功能上的主节点。不是数据状态的主节点 如果master宕机，部分功能不能用：增删改表的定义 但是还是可以使用其他一些功能：比如查询 HDFS—&gt;File—&gt;block—–&gt;namenode(metadata) Hbase—&gt;table—&gt;Region—–&gt;zookeeper(metadata) hbase的关于元数据的操作，都是必须经过master,也就是说只有master才有权限去更改元数据 maser和namenode master 的压力要小得多，并且甚至宕机一段时间都没有问题 master节点不能长时间宕机，比如宕机一个小时都没有问题 关于region的负载均衡是有master来做的 Region 是负载均衡的最小单元 region的大小：0.x 1G // 1.x 10G 刚刚均匀分 5g 5g 是 HBase 将一个表中的所有数据按照 RowKey 的不同范围进行切割的逻辑单元，每个Region负责一定范围数据的读写访问。Region由RegionServer负责管理。HBase中的Region的概念就和 HDFS 中的数据块的概念差不多，Region 是 HBase 表切分出来的一个分片。数据块是 HDFS 中的一个大文件切分出来的一个分片。 HMasterHBase 的主节点，负责整个集群的状态感知、负载分配、负责用户表的元数据(schema)管理（可以配置多个用来实现 HA），HMaster 负载压力相对于 HDFS 的 NameNode会小很多。HBase 的 HMaster 其实就算是宕机一段时间也可以正常对外提供服务的(要搞清楚为什么)。 RegionServerHBase 中真正负责管理 Region 的服务器，也就是负责为客户端进行表数据读写的服务器。每一台 RegionServer 会管理很多的 Region，一个 RegionServer 上面管理的所有的region不属于同一张表。负责Region的拆分，负责和底层的HDFS的存储交互，负责StoreFile的合并。 ZooKeeper整个 HBase 中的主从节点协调，元数据的入口，主节点之间的选举，集群节点之间的上下线感知……都是通过 ZooKeeper 来实现 HDFS用来存储 HBase 的系统文件，或者表的 Region 文件 ClientClient 包含了访问 HBase 的接口，另外 Client 还维护了对应的 Cache 来加速 HBase 的访问，比如 Cache 的.META.元数据的信息。 HBase 和 和 Hive 的 比较 OLAP(hive):数据库 analusis select OLTP(hbase): 数据库 transaction insert updeate delete hbase进行select ,hive整合hbase 相同点1、HBase 和 Hive 都是架构在 Hadoop 之上，用 HDFS 做底层的数据存储，用 MapReduce 做数据计算 不同点1、 Hive 是建立在 Hadoop 之上为了降低 MapReduce 编程复杂度的 ETL 工具。​ HBase 是为了弥补 Hadoop 对实时操作的缺陷2、 Hive 表是纯逻辑表，因为 Hive 的本身并不能做数据存储和计算，而是完全依赖 Hadoop​ HBase 是物理表，提供了一张超大的内存 Hash 表来存储索引，方便查询3、 Hive 是数据仓库工具，需要全表扫描，就用 Hive，因为 Hive 是文件存储​ HBase 是数据库，需要索引访问，则用 HBase，因为 HBase 是面向列的 NoSQL 数据库4、 Hive 表中存入数据（文件）时不做校验，属于读模式存储系统​ HBase 表插入数据时，会和 RDBMS 一样做 Schema 校验，所以属于写模式(无严格模式)存储系统5、 Hive 不支持单行记录操作，数据处理依靠 MapReduce，操作延时高​ HBase 支持单行记录的 CRUD，并且是实时处理，效率比 Hive 高得多 搭建]]></content>
  </entry>
  <entry>
    <title><![CDATA[sqoop]]></title>
    <url>%2Fblog%2F2018%2F10%2F30%2Fsqoop%2F</url>
    <content type="text"><![CDATA[sqoop：概念及功能：​ 数据迁移的，数据移动​ 原来数据管理是集中式管理​ 将原来的集中式管理的数据 移动到分布式平台下​ sqoop就是将传统的关系型数据库的数据和大数据据平台之间的数据迁移​ 迁移有两个方向：​ 1）关系型数据库mysql/oracle—-》大数据平台（hadoop,hive,hbase）​ 数据导入​ 2）大数据平台（hadoop hive hbase）—-》关系型数据库(mysql)​ 数据导出​ 通常用于 分析结果数据从hive或hdfs导出到mysql中 便于前台展示​ sqoop是关系型数据库和大数据平台的桥梁​ 注意：这里的大数据平台指的是hadoop的广义概念 hadoop： 1）狭义 专门指hadoop组件 2）广义： hadoop生态圈的所有组件 hadoop hive hbase zookeeper ......&lt;!-- more --&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[beeline day16]]></title>
    <url>%2Fblog%2F2018%2F10%2F30%2Fbeelineday16%2F</url>
    <content type="text"><![CDATA[hive的beeline的连接方式: beeline：远程连接的服务 hive中内置了这个工具 步骤 修改hadoop集群的配置 hadoop集群中的每一个节点的配置文件都需要修改 将下面的配置文件 远程发送到其他hadoop节点 123456789101112131415161718192021222324251）修改hdfs-site.xml &lt;property&gt; &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt;2)core-site.xml &lt;property&gt; &lt;name&gt;hadoop.proxyuser.hadoop.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.proxyuser.hadoop.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; scp hdfs-site.xml core-site.xml hadoop02:/home/hadoop/apps/hadoop-2.7.6/etc/hadoop/scp hdfs-site.xml core-site.xml hadoop03:/home/hadoop/apps/hadoop-2.7.6/etc/hadoop/scp hdfs-site.xml core-site.xml hadoop04:/home/hadoop/apps/hadoop-2.7.6/etc/hadoop/ 重启hadoop集群 启动hive 先启动hive的服务端 为后台服务，一定在安装hive的节点启动的hiveserver2 启动hive的服务端 启动beeline进行连接:beeline 连接： !connect hive的url: jdbc:hive2://hadoop02:10000 mysql的url：jdbc:mysql://hadoop02:3306 下面的提示： 123456789Enter username for jdbc:hive2://hadoop02:10000:安装hive的用户的名字Enter password for jdbc:hive2://hadoop02:10000:安装hive的用户的密码下面日志证明连接成功：Connected to: Apache Hive (version 2.3.2)Driver: Hive JDBC (version 2.3.2)Transaction isolation: TRANSACTION_REPEATABLE_READ0: jdbc:hive2://hadoop02:10000&gt;hive&gt; hive后台服务nohup hiveserver2 1&gt;/home/hadoop/logs/hiveserver.log 2&gt;/home/hadoop/logs/hiveserver.err &amp; 解释： nohup no hang up 输出日志级别为1 代表标准输出 输出级别为2 代表的是错误输出 其他节点通过beeline连接 使用beeline连接的时候： 将hive的安装包远程发送到其他的节点上 启动beeline：到bin目录下 ./beeline启动 transform hive的脚本解析方式 脚本：shell python写的脚本 解析某一个字符串/数据： hive内置函数 自定义函数 可以将解析任务写在一个脚本中 ,hive中调用transform的这种方式运行脚本 123456789101112131415161718192021222324需求：统计周一到周日哪一天的观影人数最多问题：将时间戳转换为周几用transform的方式进行解析： 准备数据：&#123;&quot;movie&quot;:&quot;2355&quot;,&quot;rate&quot;:&quot;5&quot;,&quot;timeStamp&quot;:&quot;978824291&quot;,&quot;uid&quot;:&quot;1&quot;&#125; &#123;&quot;movie&quot;:&quot;1197&quot;,&quot;rate&quot;:&quot;3&quot;,&quot;timeStamp&quot;:&quot;978302268&quot;,&quot;uid&quot;:&quot;1&quot;&#125;&#123;&quot;movie&quot;:&quot;1287&quot;,&quot;rate&quot;:&quot;5&quot;,&quot;timeStamp&quot;:&quot;978302039&quot;,&quot;uid&quot;:&quot;1&quot;&#125; &#123;&quot;movie&quot;:&quot;2804&quot;,&quot;rate&quot;:&quot;5&quot;,&quot;timeStamp&quot;:&quot;978300719&quot;,&quot;uid&quot;:&quot;1&quot;&#125;&#123;&quot;movie&quot;:&quot;594&quot;,&quot;rate&quot;:&quot;4&quot;,&quot;timeStamp&quot;:&quot;978302268&quot;,&quot;uid&quot;:&quot;1&quot;&#125;建表关联数据：create table movie_01(line string);load data local inpath &apos;/home/hadoop/datas/movie&apos; into table movie_01;json解析原始表：create table movie_02 as select get_json_object(line,&apos;$.movie&apos;) movieid,get_json_object(line,&apos;$.rate&apos;) rate,get_json_object(line,&apos;$.timeStamp&apos;) time01,get_json_object(line,&apos;$.uid&apos;) userid from movie_01; 12345678910111213141516transform解析：1）写脚本进行解析时间戳 python## vi weekday_mapper.pycentos6 默认安装python#!/usr/bin/pythonimport sysimport datetimefor line in sys.stdin:line = line.strip()movie,rate,unixtime,userid = line.split('\t')weekday = datetime.datetime.fromtimestamp(float(unixtime)).isoweekday()print '\t'.join([movie, rate, str(weekday),userid])strip():相当于java中的trim 去前后空格的 concat_ws("\t",) 12345672)在hive中调用脚本进行解析1. 将脚本文件加载到hive的classpath下 add file /home/hadoop/datas/my.py;2. 检验： list files; list file; 1234567891011121314153)查询解析create table movie_03 as select transform(movieid,rate,time01,userid) using &apos;python my.py&apos; as (movieid,rate,week_day,userid) from movie_02;using 跟的是脚本执行语言：shell脚本：sh ...shpython脚本：python ...py最终语句：select week_day,count(1) as total from movie_03 group by week_day order by total desc limit 1; hive的多字节分隔符 hive中默认只支持单字节分割符 不支持多字节分割符 123456789101112131415161718192021数据： 1::zs::23 2::ls::32 3::ww::45建表：create table test_byte(id int,name string,age int) row format delimited fields terminated by &apos;::&apos;;数据加载：load data local inpath &apos;/home/hadoop/datas/test_01&apos; into table test_byte;结果： 1::zs::23 1 空 zs 空 23查询 1 空 zs（转换失败为null） 1 ( 空) NULL 2 NULL 3 NULL默认是不支持多字节分割符的想要支持 需要自定义输入 输出 正则表达式的方式进行解析123456789101112131415161718默认的输入和输出： 默认的输入：一整行文件数据 分割符：“：” 默认输出：1 空 zs 空 23表的默认描述信息中：SerDe Library:org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe 只能解析单字节 InputFormat: org.apache.hadoop.mapred.TextInputFormat OutputFormat: org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat---------------------想要解析多字节：正则表达式的方式进行解析定义： 1）解析类-----正则表达式的解析类 org.apache.hadoop.hive.serde2.RegexSerDe 2）修改输入类： 自定义输入:输入格式就是一个正则 表达式 1::zs::23----&gt; (.*)::(.*)::(.*) 3)修改输出类： 自定义输出:取正则表达式解析完成的 %1$s %2$s %3$s 123456789最终建表：create table t_bi_reg(id int,name string,age int) row format serde 'org.apache.hadoop.hive.serde2.RegexSerDe'with serdeproperties('input.regex'='(.*)::(.*)::(.*)','output.format.string'='%1$s %2$s %3$s') stored as textfile; 加载数据：load data local inpath '/home/hadoop/datas/test_01' into table t_bi_reg; 多字节分割符的处理方式 将多字节分割符转换为单字节分割符 有风险,需要足够了解数据原始数据：1::zs:se::23将::----&gt;:得到1:zs:se:23 自定义输入 输出方式 解析类—–正则表达式的解析类 常用 没有风险 修改源码–全局作用 基本不用数据的分割符 各色各样的比较麻烦的 hive的分析函数 分析函数：统计分析的时候使用的 over子句 场景： ​ 分组求topN​ 按地区求排名前几的​ 每一门课程平均分的排前三 1234567891011需求：求每一个部门中年龄最小的前三个 分组：部门 排序：年龄 升序sql实现： select department,age from stu_test01 group by department order by age limit 3; //全局的升序排序 错误的写法 实际需求： 按照部门分组 在每一个部门中进行排序 组内的排序 123456789over 子句--窗口函数 把每一个部门中的数据单独拿出来进行排序分析 可以理解为将每一个部门的数据单独放在一个分析的窗口中 可以指定，每一个窗口的取数据的分组条件和排序条件的 每一个窗口中取数据的分组条件 partition by/distribute by 每一个窗口内部的排序规则 order by(partition by)/sort by(distribute by) over子句不能单独使用，必须和聚合函数sum count一起使用 或者和row_number rank dense_rank一起使用 row_number 行号/排名的 12345678910111213141516171819202122232425262728293031select department,age, row_number() over(partition by department order by age asc) from stu_test01;结果： CS 18 1 CS 18 2 CS 19 3 CS 19 4 CS 19 5 CS 19 6 CS 20 7 CS 20 8 CS 21 9 CS 23 10 IS 18 1 IS 18 2 IS 19 3 IS 19 4 IS 19 5 IS 19 6 IS 19 7 IS 19 8 IS 19 9 IS 19 10 IS 21 11 年龄最小的前三：select department,age,b.index from (select department,age,row_number() over(partition by department order by age asc) index from student_external) bwhere b.index&lt;=3; rank 排名 跳过并列的 并列的排名是一样的 select department,age, rank() over(partition by department order by age asc) from student_external; 结果： CS 18 1 CS 19 2 CS 19 2 CS 20 4 CS 20 4 CS 21 6 CS 23 7 IS 18 1 IS 19 2 IS 19 2 IS 19 2 IS 19 2 IS 21 6 MA 17 1 MA 18 2 MA 18 2 MA 18 2 MA 18 2 MA 19 6 MA 20 7 MA 22 8 dense_rank 并列的排名一样的 排名不跳 顺序递增的 1234567891011121314151617181920212223select department,age,dense_rank() over(partition by department order by age asc) from student_external; CS 18 1 CS 18 1 CS 19 2 CS 19 2 CS 19 2 CS 19 2 CS 20 3 CS 20 3 CS 21 4 CS 23 5 IS 18 1 IS 18 1 IS 19 2 IS 19 2 IS 19 2 IS 19 2 IS 19 2 IS 19 2 IS 19 2 IS 19 2 IS 21 3 补充： hive中表中的每一个字段之间默认的分割符 \t hive内置函数中 类型转换函数cast 针对可以转的类型cast(需要转换的字段 as 转换的类型) union 、union all​ 将多个查询结果进行联合拼接​ union去重​ union all 不去重的 1234567891011121314151617select * from student_external where age=18 union select * from student_external where sex=&apos;女&apos;;95002 刘晨 女 19 IS95003 王敏 女 22 MA95005 刘刚 男 18 MA95007 易思玲 女 19 MA95008 李娜 女 18 CS95009 梦圆圆 女 18 MA95011 包小柏 男 18 MA95012 孙花 女 20 CS95014 王小丽 女 19 CS95015 王君 男 18 MA95017 王风娟 女 18 IS95018 王一 女 19 IS95019 邢小丽 女 19 IS 1234567891011121314151617181920select * from student_external where age=18 union all select * from student_external where sex=&apos;女&apos;;95002 刘晨 女 19 IS95017 王风娟 女 18 IS95017 王风娟 女 18 IS95018 王一 女 19 IS95014 王小丽 女 19 CS95019 邢小丽 女 19 IS95003 王敏 女 22 MA95012 孙花 女 20 CS95005 刘刚 男 18 MA95007 易思玲 女 19 MA95008 李娜 女 18 CS95008 李娜 女 18 CS95011 包小柏 男 18 MA95009 梦圆圆 女 18 MA95009 梦圆圆 女 18 MA95015 王君 男 18 MA sql hql—查询 写查询语句： 查询语句顺序 分组 排序 过滤 需求字段 select *** from stu_test01 where group by order by limit]]></content>
  </entry>
  <entry>
    <title><![CDATA[hive查询与数据类型]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2Fhive%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[查询常用的操作 where group by order by having limit join 查询语句的写的顺序：​ select ... from ....join....where ...group by...having...order by...limit.. sql语句的执行顺序：​ from---join--where--group by---having---select---order by---limit 本地模式set hive.exec.mode.local.auto=true; 本地模式参考 join关联 hive中连接 只支持等值连接,不支持不等值连接select .... from a join b on a.id&gt;b.id; 不支持 , key值不好确定 hive中and连接 不支持orselect ... from a join b on a.id=b.id and a.pid=b.pid;select ... from a join b on a.id=b.id or a.pid=b.pid; key值不好确定 hive支持多表关联 但是hive中进行关联的时候尽量避免笛卡尔积 内连接 inner join–inner可以省略取的是两个表的交集 123456select a.id aid,a.name name,b.id bid,b.score score from test_a a inner join test_b b on a.id=b.id;结果： 1 zs 1 34 2 ls 2 67 外链接左外连接 left outer join==left join 以join左侧的表为基础表 左侧的表的所有数据都会显示 右侧可以关联上的就会补全 关联不上 null补充 1234567select a.id aid,a.name name,b.id bid,b.score score from test_a a left join test_b b on a.id=b.id;结果：1,2,31 zs 1 342 ls 2 673 ww NULL NULL 右外连接 right outer join=right join以join右侧的表为基础 左侧的表可以关联上的就会补全 关联不上 null补充 1234567select a.id aid,a.name name,b.id bid,b.score score from test_a a right join test_b b on a.id=b.id;结果：1 zs 1 342 ls 2 67NULL NULL 4 99 全外连接 full outer join=full join两个表的并集 1234567select a.id aid,a.name name,b.id bid,b.score score from test_a a full join test_b b on a.id=b.id;结果：1 zs 1 342 ls 2 673 ww NULL NULLNULL NULL 4 99 半连接 left semi join 相当于内连接 取左半表的数据左表中在右表中出现关联上的数据，判断左边在右边里面左表id：1,2,3 右表中的id ：1,2,4 hive对in/exists的支持性能很低 出现left semi join mysql没有 半连接，有in/exists 经验：做join 小表放左侧 大表右侧 多个表进行关联的时候 先做较小表的关联 在和大表进行关联 12345select * from test_a a left semi join test_b b on a.id=b.id;结果：1 zs2 ls group by 分组 group by执行是在select之前的 select后面的别名, group by中不能使用的,只能使用原生的字段 如果有group by select查询的字段只能有以下两种： group by的字段 聚合函数 1select class,min(score) from student group by class; order by 排序 全局排序 对hive表中的所有的数据进行排序 1select * from stu_test01 order by age asc; sort by 排序 局部排序 在每一个reducetask中进行排序的当reducetask的个数是一个的时候就相当于全局排序=order by 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647select * from stu_test01 sort by age asc;reducetask=3:结果 reducetask0 95008 李娜 女 18 CS 95005 刘刚 男 18 MA 95008 李娜 女 18 CS 95011 包小柏 男 18 MA 95004 张立 男 19 IS 95014 王小丽 女 19 CS 95019 邢小丽 女 19 IS 95010 孔小涛 男 19 CS 95004 张立 男 19 IS 95019 邢小丽 女 19 IS 95007 易思玲 女 19 MA 95001 李勇 男 20 CS 95012 孙花 女 20 CS 95020 赵钱 男 21 IS 95003 王敏 女 22 MA reducetask1 95021 周二 男 17 MA 95015 王君 男 18 MA 95011 包小柏 男 18 MA 95017 王风娟 女 18 IS 95009 梦圆圆 女 18 MA 95017 王风娟 女 18 IS 95005 刘刚 男 18 MA 95018 王一 女 19 IS 95007 易思玲 女 19 MA 95010 孔小涛 男 19 CS 95014 王小丽 女 19 CS 95018 王一 女 19 IS 95022 郑明 男 20 MA 95013 冯伟 男 21 CS reducetask2 95021 周二 男 17 MA 95015 王君 男 18 MA 95009 梦圆圆 女 18 MA 95002 刘晨 女 19 IS 95002 刘晨 女 19 IS 95006 孙庆 男 23 CS sort by 在进行分每一个reducetask中的数据的时候 是随机选择的字段进行分配的reducetask0/reducetask0 都有王小丽 distribute by 仅仅相当于分桶的概念 将数据根据指定的distribute by字段进行分桶 桶的个数由reducetask的个数决定的 1234567891011121314151617181920212223242526272829303132333435363738394041424344select * from stu_test01 distribute by age;reducetask=3; 桶的个数3个 按照age进行分桶的 桶1 age%3=0 95005 刘刚 男 18 MA 95015 王君 男 18 MA 95011 包小柏 男 18 MA 95017 王风娟 女 18 IS 95008 李娜 女 18 CS 95009 梦圆圆 女 18 MA 95015 王君 男 18 MA 95005 刘刚 男 18 MA 95011 包小柏 男 18 MA 95017 王风娟 女 18 IS 95013 冯伟 男 21 CS 95020 赵钱 男 21 IS 95008 李娜 女 18 CS 95009 梦圆圆 女 18 MA 桶2 age%3=1 95010 孔小涛 男 19 CS 95007 易思玲 女 19 MA 95004 张立 男 19 IS 95019 邢小丽 女 19 IS 95014 王小丽 女 19 CS 95018 王一 女 19 IS 95002 刘晨 女 19 IS 95010 孔小涛 男 19 CS 95007 易思玲 女 19 MA 95004 张立 男 19 IS 95003 王敏 女 22 MA 95019 邢小丽 女 19 IS 95014 王小丽 女 19 CS 95018 王一 女 19 IS 95002 刘晨 女 19 IS 桶3 age%3=2 95021 周二 男 17 MA 95012 孙花 女 20 CS 95022 郑明 男 20 MA 95001 李勇 男 20 CS 95021 周二 男 17 MA 95006 孙庆 男 23 CS 分桶后局部排序 如果既想按照指定的字段进行分桶 distribute by 又想在每一个桶中进行局部排序 sort by distribute by+sort by 123456789101112131415161718192021222324252627282930313233343536373839404142select * from stu_test01 distribute by age sort by age; blk-1 age%3=0 95005 刘刚 男 18 MA 95015 王君 男 18 MA 95011 包小柏 男 18 MA 95017 王风娟 女 18 IS 95008 李娜 女 18 CS 95009 梦圆圆 女 18 MA 95015 王君 男 18 MA 95005 刘刚 男 18 MA 95011 包小柏 男 18 MA 95017 王风娟 女 18 IS 95008 李娜 女 18 CS 95009 梦圆圆 女 18 MA 95013 冯伟 男 21 CS 95020 赵钱 男 21 IS blk-2 age%3=1 95010 孔小涛 男 19 CS 95007 易思玲 女 19 MA 95004 张立 男 19 IS 95019 邢小丽 女 19 IS 95014 王小丽 女 19 CS 95018 王一 女 19 IS 95002 刘晨 女 19 IS 95010 孔小涛 男 19 CS 95007 易思玲 女 19 MA 95004 张立 男 19 IS 95019 邢小丽 女 19 IS 95014 王小丽 女 19 CS 95018 王一 女 19 IS 95002 刘晨 女 19 IS 95003 王敏 女 22 MA blk-3 age%3=2 95021 周二 男 17 MA 95021 周二 男 17 MA 95022 郑明 男 20 MA 95012 孙花 女 20 CS 95001 李勇 男 20 CS 95006 孙庆 男 23 CS hive数据类型 hive====java中 string int double 基本数据： 整型：tinyint smallint int bigint 浮点型：double float 字符串类型：string 布尔类型：boolean 时间戳：timestamp 复杂数据类型 都是由基本数据类型构成的,后面都是多个数据，集合类型 collection items terminated by ‘,’ 指定集合中的元素的分割符 array – list—collection 应用场景：某一个字段有多个数据 ,数据的个数不统一,多个数据类型统一 12345678910111213141516family：name familieszs dad,mum,sisterls dad,mumww dad,mum,brother,wife,son建表：create table test_array(name string,family array&lt;string&gt;) row format delimited fields terminated by '\t' collection items terminated by ',' stored as textfile;加载数据：load data local inpath '/home/hadoop/datas/family' into table test_array;collection items terminated by ',' 指定集合中的元素的分割符 查询：访问通过下标[] 1select name,family[3] from test_array; map—映射 k-v 应用场景：k-v类型 123456789101112131415161718infoname infozs age:28,salary:20000,address:beijingls age:20,address:sh,job:ITww age:36,job:rs建表：create table test_map(name string,info map&lt;string,string&gt;) row format delimited fields terminated by '\t' collection items terminated by "," map keys terminated by ':';数据加载：load data local inpath '/home/hadoop/datas/info' into table test_map;指定多个分割符的时候 从外向内age:36,job:rs 先字段的分割,后k-v的分割map keys terminated by ':' map的key和value的分割符 查询：根据key—访问value 1select name,info["salary"] from test_map; struct java中的对象类型 应用场景：每一条数据都是具有严格的统一的个数 数据的每一个字段都是统一的类型：类类型 12345678910111213141516171819Student&#123; string name; int age;&#125;stu_infoname infozss 26,123456,shanghai,695xh 27,234556,shenzhen,700xl 25,678894,beijing,570建表：create table test_struct(name string,info struct&lt;age:int,xuehao:int,address:string,score:int&gt;) row format delimited fields terminated by &apos;\t&apos; collection items terminated by &quot;,&quot;;加载数据：load data local inpath &apos;/home/hadoop/datas/stu_info&apos; into table test_struct; 数据查询:通过字段名.属性 1select name,info.age from test_struct; hive视图特点 hive中的视图仅仅相当于一个sql语句的快捷方式 hive中的视图只有逻辑视图 没有物化视图 hive中的视图不支持insert delete update的操作,只支持查询 hive中的视图在查询视图的时候才会真正的执行 select * from age_20_view;才开始执行的 hive的视图保存在元数据库TBLS表中，保存的就是视图代表的sql语句不是sql的查询结果 提高hql语句的可读性 ，在很多的子查询的 12345678910select * from age_20_view 提高hql语句的可读性 where id &gt;95001;-----------select * from (select * from stu_test01 where age&gt;20)where id&gt;95001; 操作 创建视图 12reate view view_name as select....create view age_20_view as select * from stu_test01 where age&gt;20; 查看视图列表 12how tables; 既有视图 又有表show views; 只能查看视图 查看视图的详细描述信息 123desc age_20_view;desc extended age_20_view;desc formatted age_20_view; 删除视图 12drop view age_20_view; 可行drop table age_20_view; 不可行 hive的函数函数分类 UDF user define function 一路进一路出 处理一条数据 获取一条数据 UDTF user define table function 一路进多路出 处理一条数据 返回多条数据 explode UDAF user define aggregate funvtion 进多路出一路 处理多条数 返回一条数据 sum count avg max min 内置函数内置函数操作 查看所有内置函数 show functions; 271个内置函数 查看内置函数的用法 desc function funname; 查看函数的详细描述信息~desc function extended funname; 常用内置函数 集合函数 生成集合的函数 array 数组生成函数 array_contains 判断数组中是否包含元素的 map 生成map集合的 参数偶数个 奇数-key 偶数–value map_keys map的key map_values map的value 数值函数 round(x[, d]) 参数1：浮点数 参数2：需要保留几位小数 参数2不传 四舍五入 ceil:大于参数的最小整数。ceil(4.5)---5 floor：小于参数的最大整数floor(4.5)---4 字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243# 字符串截取 1. substr(需要截取的字符串, 截取位置[, 长度]) 字符串 从1开始 2. substring# 字符串查找： 1. instr(原始字符串, 需要查找的字符串) 有 返回子字符所在的第一个字符的下标 没有 返回 0# 字符串切分： 1. split(原始字符串, 分割的表达式) 返回的是切分完的数组# 字符串的拼接： 1. concat(str1, str2, ... strN) 多个字符串拼接为一个字符串 2. concat_ws(各个子字符串的分隔符, [string | array(string)]) concat_ws(&quot;-&quot;,&quot;aa&quot;,&quot;bb&quot;,array(&quot;ss&quot;,&quot;jj&quot;))---&gt; aa-bb-ss-jj# 大小写转换 1. lcase 小写 2. ucase 大写 3. lower 小写 4. upper 大写# 字符串判断： 处理null 1. nvl(查询的字段,默认值) 参数1为null则返回参数2 参数1不为null 返回参数1 select name,nvl(family[2],&quot;self&quot;) from test_array; 2. if（表达式，返回值1，返回值2） 表达式？返回值1：返回值2 select if(family[2] is null,&quot;self&quot;,family[2]) from test_array; 3. is null 判断是否为null 是 true 不是false# 去除空格 1. trim 去二端空格 2. ltrim 去左端空格 3. rtrim 去右端空格 日期操作 123456789101112131415161. unix_timestamp(date, [pattern]) 将给定日期转换为时间戳 select unix_timestamp(); 返回的当前系统的时间戳 select unix_timestamp(&quot;2018-10-20&quot;,&quot;yyyy-MM-dd&quot;);返回给定日期的时间戳 2. from_unixtime(系统时间戳, 需要转换的日期格式) 将时间戳--&gt;日期的 year 返回日期或时间戳所在年份 month 获取月份的 day 获取天的 hour minute second weekofyear(date) 返回的是一年中的第几周 datediff(date1, date2) 返回的是(date1 大 date2小)之间相差的天数 表生成函数 应用场景:细分 1234567891011121314151617181920212223explode（数组/map集合） 炸裂函数 进一条数据出来多条数据 参数：数组/map集合 将数组或map炸裂为多行 一个元素一行语法上不支持explode和普通字段一起查询select name,explode(family) from test_array;---&gt;不支持解决方案：select name,fs.*from test_array lateral view explode(family) fs;[1,2,3,4]----4行 1 2 3 4[1:2,3:4]----2行 key value 1 2 3 4 12345678910111213141516171819应用场景：数据 电影名 电影类型： 分手大师 喜剧 分手大师 爱情 一出好戏 喜剧/悬疑/惊悚/爱情获取电影名 电影类型（一个）select name,fs.family_mem from test_array lateral view explode(family) fs as family_mem; fs 未炸裂之前的字段别名 family_mem 炸裂之后的字段select name,stuin.sk,stuin.sv from test_map lateral view explode(info) stuin as sk,sv; stuin 未炸裂之前的字段别名 sk,sv map炸裂之后的字段k-v 自定义函数开发步骤： 创建一类继承hive的UDF类 实现一个方法 名字必须叫evaluate 返回值: 函数调用的返回值 参数: 函数调用的时候的参数 将上面的程序进行打jar包 传到linux本地 将jar包放在hive的classpath下 add jar path; 将本地jar添加到hive的classpath下 ad d jar /home/hadoop/myudf.jar; 验证：list jars; list jar; 当前添加的jar包的作用域：当前客户端 如果当前客户端退出 jar包失效 下次进入的时候重新添加 创建一个临时函数 注册函数 关联自定义的函数类 create temporary function myfun as &#39;com.ghgj.cn.test01.MyUDF&#39;; as 后面必须是全限定名 show functions; 临时函数只对当前的客户端生效 客户端退出 临时函数失效 使用函数 通过函数名—》com.ghgj.cn.test01.MyUDF—》evaluate(int a,int b,int c) evaluate(String ip)调用的时候传入不同的参数调用不同的evaluate方法​ select myfun(1,2,3);​ select myfun(“1.23.4.220”); json解析1234567Stu&#123; id int; name string; age int; score int[];&#125;json数据：&#123;id:1,name:&quot;zs&quot;,age:35,score:[12,34,1]&#125; 需要解析json数据： 自定义函数 使用内置函数 get_json_object(json_txt, path)参数1：json格式的字符串参数2：需要解析的属性的路径 1234567# $ : Root object json串的根目录 最外层的目录# . : Child operator 用来取子节点 key-value格式的子节点# [] : Subscript operator for array 用来取数组的元素 用下标进行取的# * : Wildcard for [] 案例123456789101112数据：[&#123;"movie":"914","rate":"3","timeStamp":"978301968","uid":"1"&#125;]1. $ ----&gt; []2. $[0].movie----&gt;914建表： movie rate timeStamp uid 914 3 978301968 1 select get_json_object('&#123;"movie":"914","rate":"3","timeStamp":"978301968","uid":"1"&#125;','$.movie'); 123456789101112131415161718192021222324252627282930var data = [&#123; "id": 1, "startTime": "2017-12-12 10:36:50", "endTime": "2018-02-02 00:00:00", "value": "0.26", "jobCode": "zd_test_02_171212103650", "status": "正常", "machCode": 1&#125;,&#123; "id": 2, "startTime": "2018-01-03 00:00:00", "endTime": "2018-01-12 00:00:00", "value": "0.66", "jobCode": "close_test_05_171212103622", "status": "调机", "machCode": 3&#125;];$[1]===&#123; "id": 2, "startTime": "2018-01-03 00:00:00", "endTime": "2018-01-12 00:00:00", "value": "0.66", "jobCode": "close_test_05_171212103622", "status": "调机", "machCode": 3&#125;]$[1].jobCode=="close_test_05_171212103622"]]></content>
      <categories>
        <category>HIVE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hive的操作]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2Fhive%E7%9A%84ddl%2F</url>
    <content type="text"><![CDATA[hive的DDL 表的创建，修改 DML 数据的加载（load/insert） 数据导出 hive的ddl data-define-language 数据库 建库：​ create database if not exists test; 切换数据库：​ use test; 查看正在使用的数据库：​ select current_database(); 查看数据库列表：​ show databases;​ show databases like &#39;test*&#39;; 查看数据库的详细描述信息：​ desc database test;----DBS 删除库：​ drop database if exists test; 只能删除空的数据库​ drop database test restrict;. restrict​ drop database test cascade; 强制删除非空数据库 修改数据库：不支持 表 显示表列表：​ show tables;​ show tables like &#39;test*&#39;;​ show tables in test_home; 查看指定数据库下的表 ​ show partitions table_name;查看指定分区表的分区信息 ​ show partitions student_ptn partition(department=&quot;IS&quot;);查看表分区 查看表的详细信息：​ desc test01; 可以查看表的字段描述信息​ desc extended test01; 查看表的详细信息​ desc formatted test01; 格式化显示表的详细信息 删除表​ drop table test01; 清空表​ truncate table test01;清空表中的数据 表结构保存 查看表的建表语句 ​ show create table tablename;最全的建表语句 表的创建1234567891011121314151617181920212223242526272829303132333435363738CREATE [EXTERNAL] TABLE [IF NOT EXISTS] table_name [(col_name data_type [COMMENT col_comment], ...)] [COMMENT table_comment] [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)] [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS] [ROW FORMAT row_format] [STORED AS file_format] [LOCATION hdfs_path]解析： 1）EXTERNAL 创建外部表需要指定的关键字 不指定默认创建的是内部表 2）if not exists 避免报错的 建表的时候指定 if exists 删除表的时候指定 3）comment 添加描述信息 4）PARTITIONED BY： 指定分区字段的 注意：分区字段一定不能再表的原始建表字段中 建表的时候3个字段：id name age 指定分区字段的一定不能是上面的三个字段 5）[CLUSTERED BY (col_name, col_name, ...) 指定分桶字段 注意：分桶字段一定在建表字段中的某一个或几个 [SORTED BY (col_name [ASC|DESC], ...)] 每一个桶中的排序规则 INTO num_buckets BUCKETS] 指定桶的个数的 6）ROW FORMAT row_format 指定分割符的 fields terminated by lines terminated by collections terminated by 7)STORED AS file_format 指定hive表中的原始数据的存储格式 默认的textFile进行文件存储 rcfile 8)LOCATION hdfs_path 指定hive表中的数据的存储目录 默认目录： /user/hive/warehouse/...db 修改配置文件进行修改：全局的 针对所有的表的数据 /user/hive/hivehome/...db/stu 这里的location也可以指定数据的存储目录，针对某一个表 这里指定的时候覆盖配置文件中的 不指定默认配置文件中的路径 注意：这里指定的路径一定是hdfs的路径 而不是本地 建表例子1）创建一个内部表 12create table if not exists student_managed(id int,name string,sex string,age int,department string) row format delimited fields terminated by ',' location '/user/mytable/stu'; 2）创建一个外部表 12create external table student_external(id int,name string,sex string,age int,department string) row format delimited fields terminated by ','; 3）创建一个分区表 分区字段：选择的时候 根据实际需求：经常根据哪一个字段进行过滤查询外部的分区表 分区字段department 一个目录下创建不同的目录 123create external table if not exists student_ptn(id int,name string,sex string,age int) partitioned by(department string) row format delimited fields terminated by ','; 4）创建一个分桶表 相当于mapreduce的分区的 key.hash%tasks 一个目录下创建不同的文件 12345678create external table if not exists student_buk (id int,name string,sex string,age int,department string) clustered by (id) sorted by (age asc) into 3 buckets row format delimited fields terminated by ',';桶的个数：3 id%3 指定分桶字段：id按照age asc 升序排序 5）进行表复制 关键字：like只会复制表结构 不会复制表数据 内部表还是外部表取决于表的自身的属性 1create table if not exists student_copy like student_external; //没有external，内部表 6）ctas进行建表 查询语句需要存储为一个临时表 create table ..... as select .... from .....where ..... 表的修改操作 修改表名 ​ alter table student_copy rename to stu_copy; 修改表的列信息 增加列 alter table stu_copy add columns (salary double); 替换列：将所有的列替换为新给的列 alter table stu_copy replace columns(test01 int,test02 string); 修改列 修改列名 修改列的类型:类型修改的时候 小类型—大类型 alter table stu_copy change test01 aa01 int; alter table stu_copy change aa01 aa01 string; alter table stu_copy change aa01 aa01 int;不支持String转为int 修改表的分区信息增加/添加表的分区 add partition(分区信息),注意：分区信息是指定分区字段的值 123456alter table student_ptn add partition(department="IS");alter table student_ptn add partition(department="MA");alter table student_ptn add partition(department="CS");一次性添加多个分区alter table student_ptn add partition(department="CS") partition(department="") partition(department=""); 修改分区的存储位置 分区默认存储位置：/user/hive/hivehome/bd1807.db/student_ptn/department=CS 12345671）添加分区的时候使用location关键字进行指定alter table student_ptn add partition(department="test") location '/user/hive/hivehome/test_ptn'; 2)针对已经添加的分区 可以手动修改存储目录 *******alter table student_ptn partition(department="test") set location '/user/hive/hivehome/test_ptn'; 删除分区1alter table student_ptn drop partition(department=&quot;test&quot;); hive的dml数据加载 以下两种方式最后都是将数据文件放到hive表中的目录下 如果在建表的时候指定了目录 这个目录下有数据 当前表中有没有数据？ 1234create table if not exists student_test02(id int,name string,sex string,age int,department string) row format delimited fields terminated by &apos;,&apos; location &apos;/hive_in&apos;;查询的时候 发现表中是有数据的 load方式 本质：将hdfs的原始文件的数据移动到hive的表的目录下​ 在移动的过程中如果发现重名的 重命名 新的数据文件命名为student_copy_1.txt 语法： 1234567891011LOAD DATA [LOCAL] INPATH &apos;filepath&apos; [OVERWRITE] INTO TABLE tablename [PARTITION(partcol1=val1, partcol2=val2 ...)] 解析： 1）local关键字 这个关键字指定数据从本地加载的 数据不是从本地加载 这个关键字不要 2）inpath 后面的路径 绝对路径 3）OVERWRITE关键字 是否覆盖原表数据进行数据插入 加上这个关键字就会覆盖原始表中的数据 load实例本地数据加载到hive表中load data local inpath &apos;/home/hadoop/datas/student.txt&apos; into table student_managed; load data local inpath &apos;/home/hadoop/datas/student.txt&apos; overwrite into table student_managed; 从hdfs进行数据加载1load data inpath '/hive_in/student.txt' into table student_managed; insert方式单条数据插入 每次只插入一条数据 12insert into table student_managed values(123,"zss","男",34,"IS");将插入的数据先放在一个临时表中 在从临时表中将数据load到要插入的表中 单重数据插入1234一次插入多条数据insert into table ... select .... from ... where ...insert into table stu_test select * from student_managed where age&gt;20; 多重数据插入123456789101112insert into table stu_test select * from student_managed where age&gt;20;insert into table stu_test01 select * from student_managed where age&lt;20;合并的写法from student_managed insert into stu_test select * where age&gt;20 insert into stu_test01 select * where age&lt;20;语法：from ...insert into table ... select .... where ...insert into table ..... select .... where....... 单级分区表的数据插入静态分区 适用于分区数量比较少 分区名字都知道的时候 静态分区的数据插入—插入数据的时候指定分区的字段名 添加分区alter table student_ptn add partition(department=&#39;IS&#39;); 向指定表的分区中插入数据,加载到了表的某一个分区中 load的方式 不会对加载的数据进行判断筛选 这种方式在进行加载的时候一定要十分确定是这个分区的数据 123456load data local inpath '/home/hadoop/datas/student.txt' into table student_ptn partition(department='IS');查询表：会把分区字段看做普通字段select * from student_ptn; （定义4个字段，结果5个字段）前4个字段就是我们加载文件的前4个列的值 最后一个字段分区字段department='IS' insert的方式 从一个表中进行查询数据放在分区表中的 使用insert 1234567891011121314151617单重数据插入insert into table student_ptn partition(department="IS") select id,name,sex,age from student_managed where department="IS";多重数据插入--数据插入的时候也会自动创建指定的分区from student_managed insert into table student_ptn partition(department="IS") select id,name,sex,age where department="IS" insert into table student_ptn partition(department="MA") select id,name,sex,age where department="MA";在查询的时候是全表扫描 select* 全表扫描将分区字段看做普通字段进行查询, select * ...where department="IS" 只会扫描分区为department="IS" 整体的查询性能比普通表高查询的过滤条件不是分区字段的时候select * where age=20 ----全表扫描 动态分区 插入分区表数据的时候 不需要指定分区名的 动态分区的数据插入只能使用insert的方式 语法：partition 指定分区字段 123456insert into table student_ptn partition(department) select * from student_managed;报错：FAILED: SemanticException [Error 10096]: Dynamic partition strict mode requires at least one static partition column. To turn this off set hive.exec.dynamic.partition.mode=nonstrict修改配置文件的值：set hive.exec.dynamic.partition.mode=nonstrict; 12345678910111213修改插入语句：insert into table student_ptn partition(department) select id,name,sex,age,department from student_managed;按照部门进行分区-----------------insert into table student_ptn partition(department) select id,name,department,age,sex from student_managed;会按照sex 分区 department="男" department="女"----------------------默认情况下 select的最后一个字段就是分区字段注意：动态分区的时候 将分区字段写在查询语句的最后 动态和静态分区的区别 静态分区插入数据的之后 指定分区的名；动态分区插入数据的时候 不需要指定分区的名 根据数据生成分区的名 静态分区中的可能会存在某一个分区没有数据 分区的目录是一个空目录；动态分区根据实际的数据生成的分区 每一个分区至少一条数据 如果一条数据都没有则不会生成这个分区 动态分区的时候 每一个分区都会对应配置文件中设置的reducetask的个数（set reducetasks=3）；分区过多的时候 产生多个reducetask,拉低性能， 慎重设置reducetask的个数 多级分区 分区字段大于1个 建表12345678create table if not exists student_ptn01(id int,name string,age int) partitioned by(sex string,department string) row format delimited fields terminated by &apos;,&apos;;一级分区：sex二级分区：department目录结构：/user/hive/hivehome/bd1807/student_ptn01/sex=&quot;男&quot;/department=&quot;IS&quot; 数据插入load方式123load data local inpath '/home/hadoop/datas/student.txt' into table student_ptn01 partition(sex="男",department="IS"); insert的方式(动态）1234567insert into table student_ptn01 partition(sex,department) select id,name,sex,age,department from student_managed;这个最后二个字段不是分区字段，查出的数据如果类型不匹配返回nullinsert into table student_ptn01 partition(sex,department) select id,name,age,sex,department from student_managed;分区字段 一定在查询的末尾几个字段 分桶表的数据插入 只能用insert的方式 不能使用load的方式 分桶—-MR中的分区—肯定需要MapReduce程序 load方式不走MR 123测试：load data local inpath '/home/hadoop/datas/student.txt' into table student_buk;会报错 12345678910111213141516171819202122232425262728293031323334353637383940413个桶---MR中的3个分区---3个reducetask任务insert into table student_buk select * from student_managed;日志：Hadoop job information for Stage-1: number of mappers: 2; number of reducers: 3结果： /user/hive/hivehome/bd1807.db/student_buk/000000_0 /user/hive/hivehome/bd1807.db/student_buk/000001_0 /user/hive/hivehome/bd1807.db/student_buk/000002_0 分桶字段 id 排序：age 升序 桶1：000000_0 id---int id%3=0 95004 张立 男 19 IS 95007 易思玲 女 19 MA 95019 邢小丽 女 19 IS 95010 孔小涛 男 19 CS 95001 李勇 男 20 CS 95022 郑明 男 20 MA 95013 冯伟 男 21 CS 123 zss 男 34 IS 桶2：000001_0 id%3=1 95017 王风娟 女 18 IS 95011 包小柏 男 18 MA 95008 李娜 女 18 CS 95005 刘刚 男 18 MA 95002 刘晨 女 19 IS 95014 王小丽 女 19 CS 95020 赵钱 男 21 IS 1234 zss 男 34 IS 桶3：000002_0 id%3=2 95021 周二 男 17 MA 95015 王君 男 18 MA 95009 梦圆圆 女 18 MA 95018 王一 女 19 IS 95012 孙花 女 20 CS 95003 王敏 女 22 MA 95006 孙庆 男 23 CS 分桶的字段不是数值 name.hashCode%3 在hive的1.2版本中 向分桶表插入数据的时候 需要手动设定reducetask的个数的 1234567In order to change the average load for a reducer (in bytes):set hive.exec.reducers.bytes.per.reducer=&lt;number&gt; 设置每一个reduvetask的吞吐量In order to limit the maximum number of reducers:set hive.exec.reducers.max=&lt;number&gt; 设置的是reducetask的最大的个数 1009In order to set a constant number of reducers:set mapreduce.job.reduces=&lt;number&gt; 设置reducetask个数的 -1-1 根据实际需求 分配reducetask个数 内部表和外部表区别123456789101112删除内部表的时候 元数据删除 hdfs的原始数据的目录也会删除删除外部表 元数据被删除了 hdfs的原始数据目录没有删除的1）数据删除的时候内部表的数据 表数据自己管理 删除表数据的时候 元数据和原始数据一同删除外部表数据 hdfs管理的 删除表的时候只会删除元数据信息 原始数据不会被删除2）应用场景上内部表通常用于存储一些中间结果数据 （只针对某一个业务模块）外部表 通常用于一些共享数据 公用数据 原始数据 删除表的时候不会把数据删除3）建表目录上内部表建表的时候 一般使用默认的目录就可以外部表数据一般已经存在hdfs的某一个目录上了 建表的时候一般指定数据目录 location 指定到数据所在目录 这个时候外部表和共享数据就会自动关联 数据导出单重导出 导出到本地文件系统 INSERT OVERWRITE LOCAL DIRECTORY directory1 select_statement 12345678910111213141516hive&gt; insert overwrite local directory &apos;/home/wyp/wyp&apos; &gt; select * from wyp; 将会在本地文件系统的/home/wyp/wyp文件夹下生成文件，这个文件是Reduce产生的结果（这里生成的文件名称是000000_095013冯伟男21CS95020赵钱男21IS95003王敏女22MA95006孙庆男23CS保存的文件列之间是用^A（\x01）来切割如今我们能够用Hive0.11.0版本号新引进了一个新的特性，指定输出结果列之间的分隔符： hive&gt; insert overwrite local directory &apos;/home/wyp/Documents/result&apos;hive&gt; row format delimitedhive&gt; fields terminated by &apos;\t&apos;hive&gt; select * from test; 导出到HDFS中 INSERT OVERWRITE DIRECTORY directory1 select_statement 1234hive&gt; insert overwrite directory &apos;/home/wyp/hdfs&apos; &gt; select * from wyp; 将会在HDFS的/home/wyp/hdfs文件夹下保存导出来的数据。 多重导出 from table INSERT OVERWRITE [LOCAL] DIRECTORY directory1 select... where... 123from student_managedinsert overwrite local directory "/home/sun/datas/age_20" select * where age&gt;20insert overwrite local directory "/home/sun/datas/agexiao20" select * where age&lt;20; 导出到Hive的还有一个表中123456789101112131415161718192021hive&gt; insert into table test &gt; partition (age=&apos;25&apos;) &gt; select id, name, tel &gt; from wyp;##################################################################### 这里输出了一堆Mapreduce任务信息。这里省略#####################################################################Total MapReduce CPU Time Spent: 1 seconds 310 msecOKTime taken: 19.125 secondshive&gt; select * from test;OK5 wyp1 131212121212 256 wyp2 134535353535 257 wyp3 132453535353 258 wyp4 154243434355 251 wyp 13188888888888 252 test 13888888888888 253 zs 899314121 25Time taken: 0.126 seconds, Fetched: 7 row(s)]]></content>
      <categories>
        <category>HIVE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hadoop02]]></title>
    <url>%2Fblog%2F2018%2F09%2F29%2Fhadoop02%2F</url>
    <content type="text"><![CDATA[安装过程中的问题 Hadoop的安装模式 hdfs 的设计思想 hdfs的主从架构 hdfs的优缺点 hafs常用操作 谷歌的三篇论文 用java实现 google 2003 ——– GFS Mapreduce bigtable doung cutting ———–java GFS ————-hdfs Mapreduce ————Mapreduce bigtable ———hbase hadoop是什么高可用 高可靠的分布式开源框架 基于普通廉价机 hadoop的模块hadoop1.0 hdfs mapreduce hadoop2.0 hdfs :主从 一主多从 主: namenode 从: datanode 助理:secondarynamenode mapreduce yarn 主从架构 主:resourcemanager 从: nodemanager hadoop的安装 伪分布式 完全分布式 安装过程中的问题某些进程启动失败 启动集群的过程中,发现某些进程启动不了,集群运行一段时间后某个进程挂了? 启动时候的日志文件:$HADOOP_HOME/logs 123456Starting namenodes on [hdp01]hdp01: starting namenode, logging to /home/sun/apps/hadoop-2.7.6/logs/hadoop-sun-namenode-hdp01.outhdp02: starting datanode, logging to /home/sun/apps/hadoop-2.7.6/logs/hadoop-sun-datanode-hdp02.outhdp03: starting datanode, logging to /home/sun/apps/hadoop-2.7.6/logs/hadoop-sun-datanode-hdp03.outStarting secondary namenodes [hdp02]hdp02: starting secondarynamenode, logging to /home/sun/apps/hadoop-2.7.6/logs/hadoop-sun-secondarynamenode-hdp02.out 确保集群没有问题:查看集群启动的日志文件 hadoop-sun-namenode-hdp01.log 1234日志文件的命名规则:hdfs的相关进程 ---hadoop模块yarn的相关简称 ----yarn 模块进程的归属模块 用户名 进程名字 主机名.log 对于问题,查看日志文件 123456789101112131415161718192021222324252627哪一个进程没有,查看哪一个进程的日志文件查看日志文件的命令 tail -100 日志文件如果报错: 同java代码报错如果日志文件不报错: 集群没有问题 有报错信息: 需要先解决报错没有报错 进程不启动 1. 停掉集群 全部重启 暴力 hdfs的相关进程 stop-dfs.sh start-dfs.sh yarn的相关进程 stop-yarn.sh start-yarn.sh 2. 单独启动没有启动的进程 hdfs hadoop-daemon.sh 单独启动,某一个节点上的某一个hdfs进程 hadoop-daemons.sh 启动多个节点上的某一个hdfs进程 hadoop-daemon.sh start namenode hadoop-daemon.sh start datanode hadoop-daemon.sh start secondarynamenode yarn yarn-daemon.sh 单独启动,某一个节点上的某一个yarn进程 yarn-daemon.sh start resoucemanager yarn-daemon.sh start nodemanager 格式化的问题 ps -ef | grep java | grep hadoop:查看hadoop的进程 成功格式化只能格式化一次 原因: 集群安装的过程中 配置了namenode的数据存储目录 12345&lt;property&gt;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;&lt;value&gt;/home/hadoop/data/hadoopdata/name&lt;/value&gt;&lt;description&gt;namenode的数据的存储目录&lt;/description&gt;&lt;/property&gt; namenode存储目录有二个内容 current 12345678910111213141516171819202122232425current 存储的是namenode 的数据信息 namenode存储的数据 就是datanode上的数据的描述信息 描述数据的数据--------元数据 --------------------------------------------------current下有一个核心的文件 VERSION 版本信息文件 格式化的时候生成 #Sat Sep 29 15:54:29 CST 2018namespaceID=2080811177clusterID=CID-4a07165e-6c8b-47bb-afc8-e8f473394a38D //集群的 集群版本ID cTime=0storageType=NAME_NODE // 存储类型blockpoolID=BP-1194953031-192.168.2.101-1538040436190 //块池idlayoutVersion=-63 clusterID:集群的 集群版本ID 集群的唯一标识datanode和namenode相互通信的根基,datanode里面也会存储这个信息 如果两个版本信息一致 则会认为是同一个集群 否则 认为是不同的集群 in_use.lock 12in_use.lock: 锁文件:就是保证一个节点只启动一个namenode进程 3.datanode的version:datanode启动的时候生成的 路径：/home/hadoop/data/hadoopdata/data/current 1234567#Sat Sep 29 16:07:15 CST 2018storageID=DS-e390bfb6-9b44-4cc4-a22e-a9259b6f4935clusterID=CID-4a07165e-6c8b-47bb-afc8-e8f473394a38 集群id 集群的标志cTime=0datanodeUuid=22c87409-cd54-42b6-b34a-63bcc935c3e5storageType=DATA_NODElayoutVersion=-56 格式化的时候:只生成了namenode的version信息 没有生成datanode的版本信息 datanode的version启动datanode的时候生成 重新格式化会造成namenode的version被覆盖 datanode的version不会被覆盖 ​ 格式化了二次:集群肯定是关闭 ​ 将所有的节点的数据目录删除,再创新格式化 ​ 再生产中要谨慎使用 容易造成数据丢失 时间同步在集群的安装过程中 需要保证 各个节点之间的时间同步 原因: datanode和namenode之间需要通信的 只要各个节点之间的时间一致就可以 ,不是节点时间和北京时间一致 实现 手动 date -s 时间 时间同步服务器实现 手动搭建 用公网的 ntpdate 时间同步服务器的公网ip sudo ntpdate ntp1.aliyun.com 配置过程中的环境变量配置过程中的环境变量 系统的环境变量位置:/etc/profile —-所有用户都生效的 用户环境变量 : ~/.bashrc —–只针对当前用户有效 用户环境变量 : ~/.bash_profile —–只针对当前用户有效 加载顺序: 系统环境变量:/etc/profile 用户环境下的:~/.bashrc 用户环境变量:~/.bash_profile 生效的顺序与加载顺序相反,最后加载最先生效 Hadoop的安装模式单机模式 不需要安装,直接解压就可以用 生产中不会使用 不存在分布式文件系统 没有守护进程,只在一个节点上运行 生产中不会使用 个人学习的时候 代码调试 伪分布式 存在分布式文件系统 有守护进程 只不过所有的进程只在一个节点上运行 生产中不用 个人测试的时候 完全分布式 存在所有的分布式文件系统 所有的进程运行在不同的节点的 运行在多个节点之上 多个节点共同组成的一个集群 运行模式: 一主多从一助理 文件系统: ​ 一个namenode ​ 多个datanode ​ 一个secondarynamenode: 是namenode的冷备份,只复制数据,不能当做namenodenamenode yarn: ​ 一主多从 ​ 极少的企业 小型的公司 测试集群 缺陷:存在单点故障的问题,主节点自由一个 secondarynamenode是仅仅备份namenode的元数据 不会主动切换为namenode 当namenode宕机的时候 会造成集群整体不可用 数据不可访问 高可用(ha high avalible) 解决完全分布式中的单点故障问题(hdfs的单点故障) 运行模式: ​ 多个主节点 多个从节点 一般 2个主节点 多个从节点 2个主节点,同一时间 只能允许一个对外提供服务,另外一个处于热备份状态(时刻准备接替为active namenode) 对外提供服务的: active namenode 热备份的:standby namenode 这种模式中 多个namenode之间的数据肯定是实时同步的 存储的数据是一致的,如果active namenode 宕机的时候 standby namnode才可以接替 数据不丢失 实际生产中 对于绝大多数公司足够用 集群规模 中小规模 大规模也可以 不要太大规模 100台左右 缺陷 虽然这种模式有二个namenode 同一时间对外提供访问的自由一个,如果集群中的datanode的节点个数很多的时候 会造成namenode的压力过大 联邦模式 解决集群过大 ,namenode压力过大的问题 同一时间同时对外提供服务的namenode有多个 active namenode 每个namenode 只负责集群中的一部分的数据管理(不是datanode的管理) 如何区分哪一个namenode管理的哪一个部分数据: 一个datanode下有多个块池 namemode的version中记录 blockpooID:块池ID,记录自己需要管理的数据块的信息 namenode管理数据块的标志 不同的namenode管理的数据的blockPoolID不一样 当集群中的节点个数过多的时候可以真正的分担namenode的数据管理的压力 注意: ​ 区分每一个namenode管理的是datanode上的一部分数据 ​ 而不是(每一个namenode管理几个datanode)对个集群 生产环境: 超大集群 :联邦模式+高可用 hdfs的理论hadoop2.0 hdfs: hadoop distibuted filesystem hadoop 的分布式文件系统 海量数据的分布式存储 来源谷歌的GFS论文 mapreduce: 分布式计算的 yarn 分布式资源调度 hdfs 的设计思想分块存储12345678910111213141516块怎么分? 数据块太大: 负载不均衡 数据块太小: 每一个数据块会被namenode记录 namrnode记录的内容太多,namenode的压力过大hdfs设计的时候已经设计了一个比较合理的值: hadoop1.0 64M hadoop2.0 128M 在hadoop的默认配置中 $HADOOP_HOME/share/hadoop/hdfs dfs.blocksize 134217728(128M) 如果hdfs-site.xml中配置了这个参数 会把默认的hdfs-default.xml覆盖掉 默认的大小 不会造成负载不均衡 同时不会造成namenode的压力过大注意: 进行数据存储的时候 假设300M block_1 128M block_2 128M block_3 44M 最后的数据不足128 ,也单独存储一个块 不会和其他数据混合存储 备份存储 冗余存储hadoop设计的时候 基于廉价机 如果每一个数据只存储一份 任意 一个节点宕机 会造成数据丢失 hdfs在进行设计时候 每一个数据都要进行备份存储 冗余存储 保证数据的安全性 副本: 相当于备份的概念 但是和备份不一样的一点 这里的备份没有主从之分 所有的备份数据 和原始数据同等地位 针对用户的读写时候 无差别 对外提供服务的时候 是根据哪一个副本空余 哪一个副本就对外提供服务 ;都空余的时候,就近原则 hdfs的默认的备份存储的副本个数3份 dfs.replication 2 我们自己配置的 如果我们不进行配置 这个参数 默认每一个数据块存储3份副本 副本的放置(用空间换数据安全)保证数据的安全性: 同一个数据块的不同副本 放置在不同的节点上 但是同一个节点可以存放对个不同的数据块 同一个节点上 如果放置同一个数据块的二个副本 没有意义 同一个节点上 只能存储一个数据块的一个副本 3个副本 副本1 ---------------datanode01 ​ 副本2 —————datanode02 ​ 副本3 —————datanode03 如果副本个数设置为3 有一个副本所在的节点宕机 如何处理? 12345少于设置的个数: 这个时候hdfs会自己再复制一个副本出来 最终保证3个副本如果副本复制完成了 刚才宕机的节点恢复了 这个时候 副本个数就变成4个 大于设置的副本个数,如何处理?namenode 会经过1h左右的时间如果发现还是4个副本(集群稳定) hdfs会删除一个副本 保证副本个数为3 如果集群中datanode的节点个数 2 个 设置的副本的个数为3 123这时候集群中只能保存节点个数的副本每个节点保存一个副本 最终只有二个副本剩下的一个副本会进行记账 当集群中的节点增加的时候会把这个副本补上 hdfs的架构hdfs的简单使用12345678910111213141516171819hdfs的上传存储的命令上传 本地 ---------- hdfs集群中这里的本地 客户端所在的本地 ----&gt; hdfs集群中 客户端 -----本地 linux ----linux eclipse ---- windowshadoop fs -put 本地的文件 hdfs 的路径 本地文件 可以是绝对路径 也可以说相对路径 hdfs: 文件的目录结构 同linux 只有绝对路径进行访问 没有相对路径的访问方式 所有的访问从/开始 hadoop : 启动一个hadoop 客户端 fs file System :打开hdfs的文件系统 - 后面的是命令 查看目录结构:hadoop fs -ls [-h] 目录 主从架构一主多从 1234567891011121314151617181920212223242526272829303132主:namenode1. 存储元数据信息 元数据:管理datanode数据的数据 包括3个部分 1)抽象目录树 对于hdfs来说 目录树不代表任何一个节点存储目录结构 代表的是集群中的所有节点共同构成的存储集群的目录结构 目录树叫抽象目录树 2)数据和块的对应关系 如果一个数据被切分成了多个块 这多个块之间的blockid一定是顺序递增的 文件存储的时候 按照块为单位进行存储 一个文件如果超过128M就会被切分成很多块 假设 文件名 hadoop.gz 300M 切成3块 hdfs在进行数据块的切分的时候每一个数据块都有一个数据块的编号 这个数据块的编号 blockid 全局唯一 /hadoop.gz blk_00000001 blk_00000002 blk_00000003 /hdfs-site.xml 1.4kb blk_00000004 3)数据块的存储位置 和副本的个数有关 每一个块3个副本 /hadoop.gz blk_00000001 [hadoop01 hadoop02 hadoop03] blk_00000002 [hadoop04 hadoop02 hadoop03] blk_00000003 [hadoop01 hadoop02 hadoop04] 2. 处理客户端的读写请求 客户端读写 先去找namenode 1234567891011121314151617181920212223从:datanode1. 负责数据的真正存储 数据块的存储 datanode负责 hdfs-site.xml &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/data/hadoopdata/data&lt;/value&gt; &lt;description&gt;datanode 的数据存储目录&lt;/description&gt; &lt;/property&gt; datanode的所有数据信息 (相关信息数据 和 原始数据的数据块存储位置) /home/hadoop/data/hadoopdata/data/current/BP-1261971397-192.168.191.201-1538186485641/current/finalized/subdir0/subdir0 1. BP-1261971397-192.168.191.201-1538186485641:块池文件 块池文件 : 存储当前节点的所有的块的文件 2. 目录下有文件 blk_XXXXXXXXXX 实际的原始数据的块(文件) blk_XXXXXXXXXX.meta 上面的块的描述 2. 负责处理客户端真正的读写请求 123456助理:secondarynamenode这里是一个namenode的冷备份的节点 1) 帮助namenode备份元数据 放置namenode宕机的时候可以进行数据恢复 2) 帮助namenode做一些事情 (元数据合并) 减轻namenode的压力 hdfs的优缺点优点 成本低 构建在廉价机器上 高容错 适合批处理(离线处理) 离线处理: 不适合处理实时数据 移动计算而非数据 数据位置暴露给计算框架,数据位置暴露给计算框架 移动计算: 计算在哪里 数据就在那里 数据跟着计算[跑] 浪费大量的数据在数据拷贝上 一台机器的计算能力有限 移动计算: 数据子那里 计算就到哪里 计算跟着数据[跑] 适合大数据处理 GB,TB,甚至PB级数据 百万规模以上的文件数据量 10K+节点规模 流式文件访问 一次性写入 多次读取,保证数据一致性 hdfs不支持文件修改 对于hdfs来说,文件修改的成本太高 但是支持文件追加 不建议使用 基本不用 缺点 对于低延迟的数据访问不支持 对于实时的数据访问 不支持 只支持离线数据访问 不适合小文件的存储 1000w 1kb的文件 原因: 每一个小文件都需要单独存储一个数据块,在进行文件访问的时候,先去访问namenode找到该数据块的位置 再到对应的datanode上进行文件读取 有可能找文件的过程(寻址)时间远远大于文件的真实读取时间 会造成namenode 的压力过大 一个文件——-1个数据块——–1条元数据 很多数据块会对应很多条元数据 一条元数据150Byte 元数据大小 1000w*150byte =1 500 000 000 ≈1.5G 1000w*1kb=10000000=====10G 10T 会造成namenode的压力过大 不支持数据修改 一次写入多次读取 常用命令操作 文件的上传 hadoop fs -put 文件 hdfs目录:复制 hadoop fs -copyFromLocal 本地文件路径 hdfs的文件目录 hadoop fs -moveFromLocal 本地文件路径 hdfs的文件目录 注意: ​ 在文件上传的过程中 如果没有指定文件名 以原来的文件名命名 ​ 如果指定文件名 则以指定的文件名命名 ​ /test 是重命名为test ​ /test/ 放到test目录下(一定要存在) ​ hdfs不会自动创建上传文件的目录 上传文件的时候,父目录一定要存在 创建文件夹 hadoop fs -mkdir /hdp hadoop fs -mkdir -p /hdp/aa/bb:级联创建 文件下载 hadoop fs -get hdfs文件目录 本地文件目录:拷贝 hadoop fs -copyToLocal hdfs文件目录 本地文件目录:拷贝 hadoop fs -moveToLocal 本地文件路径 hdfs的文件目录:hdfs的文件下载完成 删除了 hadoop fs -get /hdfs-site.xml ~/ hadoop fs -copyToLocal /hdfs-site.xml ~/ 123&gt; [sun@hdp01 ~]$ hadoop fs -moveToLocal /hdfs-site.xml ~/aa &gt; moveToLocal: Option &apos;-moveToLocal&apos; is not implemented yet.(还没有实现)&gt; 查看文件的目录信息 hadoop fs -ls目录:只能查看当前给定的目录下的目录树 不能级联查看 hadoop fs -lsr -R hdfs目录:级联查看 删除文件 hadoop fs -rm hdfs文件的绝对路径 删除目录 hadoop fs -rm -r -f hdfs目录 1234&gt; [sun@hdp01 ~]$ hadoop fs -rm -r -f /hdp&gt; 18/09/29 16:35:23 INFO fs.TrashPolicyDefault: Namenode trash configuration: Deletion interval = 0 minutes, Emptier interval = 0 minutes.&gt; Deleted /hdp&gt; 修改用户和组信息 linux:chown [-R] 用户:组 文件 hdfs修改 ​ hadoop fs -chown [-R] 用户:组 hdfs的路径 修改文件的读写权限 linux :chmod [-R] 文件读写权限 文件或目录 7(所属用户)5(所属组的用户)5(其他用户) 读:4 写2 执行1 hdfs hadoop fs -chmod [-R] 文件读写权限 文件或目录 设置副本个数 hdfs-default.xml: 默认个数3个 hdfs-site.xml:改为2 通过命令设置副本个数 hadoop fs -setrep [-R] [-w] 副本个数 目录:命令只能修改指定路径的副本数 [-R] :级联 ​ hadoop fs -setrep -R 副本个数 目录:只能修改指定文件下已经存在的文件的副本数,新上传的按照hdfs-site.xml进行配置副本数 [-w]:wait,等待新设定的副本完成 查看文件内容 [-cat] ​ cat fs -cat hdfs的文件目录 [-tail]:查看文件末尾1kb的数据 ​ hadoop fs -tail /a.sh 新建一个空文件 (hdfs不能修改,不常用) hadoop fs -touchz hdfs目录/文件名 hadoop fs -touchz /a.txt hdfs文件的移动和复制 移动: ​ hadoop fs -mv hdfs路径 新路径 复制: ​ hadoop fs -cp hdfs路径 新路径 其他 12345- appendToFile 追加 追加到原始文件的末尾 成本高 hadoop fs -appendToFile 本地文件 hdfs目录 这里的追加是在原始的数据块上追加的 如果原始的数据块追加超过128M 这回切分 1234合并下载:-getmerge将hdfs上的多个文件合并为一个文件下载到本地按照给的路径的顺序 进行合并下载hadoop fs -getmerge hdfs的多个文件路径(空格隔开) 本地文件路径 1234567891011121314151617df: 查看整个磁盘占有率[sun@hdp01 ~]$ hadoop fs -df -h /Filesystem Size Used Available Use%hdfs://hdp01:9000 137.2 G 200 K 118.2 G 0%---------du: 每一个文件的大小[sun@hdp01 ~]$ hadoop fs -du -h / 270 /a.sh0 /a.txt1.5 K /hdfs-site.xml309 /sun-count 个数 12345678910111213141516171819202122232425262728293031323334353637383940414243shell---命令行的操作方式必须在hadoop的安装的节点上hadoop fs [-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;] [-cat [-ignoreCrc] &lt;src&gt; ...] [-checksum &lt;src&gt; ...] [-chgrp [-R] GROUP PATH...] [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...] [-chown [-R] [OWNER][:[GROUP]] PATH...] [-copyFromLocal [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;] [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;] [-count [-q] [-h] &lt;path&gt; ...] [-cp [-f] [-p | -p[topax]] &lt;src&gt; ... &lt;dst&gt;] [-createSnapshot &lt;snapshotDir&gt; [&lt;snapshotName&gt;]] [-deleteSnapshot &lt;snapshotDir&gt; &lt;snapshotName&gt;] [-df [-h] [&lt;path&gt; ...]] [-du [-s] [-h] &lt;path&gt; ...] [-expunge] [-find &lt;path&gt; ... &lt;expression&gt; ...] [-get [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;] [-getfacl [-R] &lt;path&gt;] [-getfattr [-R] &#123;-n name | -d&#125; [-e en] &lt;path&gt;] [-getmerge [-nl] &lt;src&gt; &lt;localdst&gt;] [-help [cmd ...]] [-ls [-d] [-h] [-R] [&lt;path&gt; ...]] [-mkdir [-p] &lt;path&gt; ...] [-moveFromLocal &lt;localsrc&gt; ... &lt;dst&gt;] [-moveToLocal &lt;src&gt; &lt;localdst&gt;] [-mv &lt;src&gt; ... &lt;dst&gt;] [-put [-f] [-p] [-l] &lt;localsrc&gt; ... &lt;dst&gt;] [-renameSnapshot &lt;snapshotDir&gt; &lt;oldName&gt; &lt;newName&gt;] [-rm [-f] [-r|-R] [-skipTrash] &lt;src&gt; ...] [-rmdir [--ignore-fail-on-non-empty] &lt;dir&gt; ...] [-setfacl [-R] [&#123;-b|-k&#125; &#123;-m|-x &lt;acl_spec&gt;&#125; &lt;path&gt;]|[--set &lt;acl_spec&gt; &lt;path&gt;]] [-setfattr &#123;-n name [-v value] | -x name&#125; &lt;path&gt;] [-setrep [-R] [-w] &lt;rep&gt; &lt;path&gt; ...] [-stat [format] &lt;path&gt; ...] [-tail [-f] &lt;file&gt;] [-test -[defsz] &lt;path&gt;] [-text [-ignoreCrc] &lt;src&gt; ...] [-touchz &lt;path&gt; ...] [-truncate [-w] &lt;length&gt; &lt;path&gt; ...] [-usage [cmd ...]]]]></content>
  </entry>
  <entry>
    <title><![CDATA[bigdata01]]></title>
    <url>%2Fblog%2F2018%2F09%2F25%2Fbigdata01%2F</url>
    <content type="text"><![CDATA[大数据 离线 java基础增强 hadoop：海量数据存储和分析的 —-大象​ HDFS:海量数据存储的​ MAPREDUCE:海量计算的​ yarn：分布式的资源调度 hive：对外提供sql编程的 — 蜜蜂​ mysql增强 zookeeper：动物园管理员​ 协调 hbase：分布式的数据库​ 结构化的数据和半结构化的数据存储​ 不同于mysql​ nosql数据库​ redis​ no sql​ not only sql sqoop 数据迁移工具​ 关系型数据库—mysql—–大数据平台（hadoop hive hbase azkaban:任务调度的​ crontab -e 数据： 结构化的数据： 二维表的结构的数据​ mysql​ name yuwen shuxue yingyu beizhu 半结构化的数据:​ html​ css​ xml 非结构化的数据:​ 视频 图片 音频 实时: kafka：消息队列 flume:数据收集 python爬虫 scala spark 数据来源： 1. 自己的业务数据 2. 爬虫 公开数据 3. 第三方平台购买 电信数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[java增强]]></title>
    <url>%2Fblog%2F2018%2F09%2F25%2Fjava%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[集合 listarrayList底层结构:数组(长度不可变)+实现了序列化接口 实现 创建数组的时候 长度是0 第一次添加元素的时候 初始化数组的长度 10 1234567数组的扩容： 数组的元素个数超过10个的时候 扩容的工作 grow（） int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); =1.5*oldCapacity 数组扩容的时候 每次1.5倍进行扩容的 进行数组的复制的工作 1234567891011121314151617181920212223数组的上限：arrayList数组的上限：Integer_max(21亿)-815亿------15*1.5=====22.亿数组的上限 integer_maxvalue 21亿arraylist的size的最大上限是integer_maxvalue 性能瓶颈10亿左右右移1位 /2 2位 /4左移：1 *2 2 *4构造方法中有参构造 无参构造public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 123456789101112131415有参构造的使用场景：如果使用无参构造，初始化数组的长度0 第一次添加元素的时候开始 长度10 以后的每次扩容 1.5倍进行扩容100010 15 22 33 50 75 112 。。。。数组扩容----数组的拷贝的过程 消耗资源的过程使用有参构造 参数：代表的是我们数组初始化的长度参数500---750----1000+当arraylist中元素个数很多的时候 最好使用有参构造 减少底层数组的扩容的次数 提升性能add（E e） remove(E e)特点：查询快 增删慢数组有索引的 通过下标直接访问 时间复杂度o(1)时间复杂度o(1) 数组 hash linkedlist底层是一个链表结构的,有序(元素的插入顺序),可重复 链表 单向链表 1只有一个方向的链表 上一个元素知道下一个元素 但是下一个元素不知道上一个元素的 访问的时候只能从一端开始 双向链表 12两个方向的链表 每一个元素 都知道自己的上一个元素和下一个元素是谁可以从两个方向访问 环形链表:首位相连的链表 LinkedList的底层的结构 链表–线性的（1.5—&gt;单向的 1.5之后—&gt; 双向的）链表结构中的每一个元素 就叫做node 对象 Node 12345678910111213//Node的结构：private static class Node&lt;E&gt; &#123; E item; //本身元素 Node&lt;E&gt; next; //下一个元素 Node&lt;E&gt; prev; //上一个元素 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;addFirst(E e) 添加元素的时候 实际上是对Node的操作 优点：增删快 查询慢 vector：vector 和arrayList的区别​ vector：线程安全的 但是性能低​ arrayList 线程不安全的 性能高 stack：栈结构:先进后出的 比较器：内部比较器12345678910111213comparable .....ble 使。。。。。具备。。。。的能力 comparable 使。。。。具备比较的能力 如果一个类实现了这个接口 代表这个类具备了比较的能力 内部比较器 定义在对象类定义的时候 只能用于比较本类对象的 实现了comparable接口的类需要重写compareTo方法参数o用于比较的对象 和本对象比较(this)返回值: int类型 this.属性-o.属性的结果 &gt;0 :向后蹿,越大越在后面(升序) =0 :位置不变 &lt;0 :向前蹿(降序) 外部比较器专门定义一个比较器的类 这个类中定义比较规则 comparator 定义在类的外部的 可以随着传入的泛型的类型 定义比较规则的 对list集合中的元素进行排序： SetHashSet 先对key(元素)取hash值 hash冲突 hash碰撞 hash算法:就是生成一个唯一的散列的数 不存在一个绝对完美的hash算法,任意二个或多个key的hash值不同 任何一个hash算法都会存在hash冲突的问题 hash冲突:不同的key的hash值一样 对于同一个hash值,通过链表存储(查询性能低) 1.8后对链表进行了优化,将链表转换为数结构,元素超过8个(阀值)后会转换为数 去重 hash值不同的二个元素, 一定不是同一个元素 先判断hash值 equals(地址) 不存 TreeSet红黑数 排序: 存的数据必须要是可比较的,否则会报错 ​ 默认:数值:自然排序 ​ 字符串:字典排序 1;11;12;2;21;33;4 mapHashMap底层结构:数组+桶表(单向的链表)+树(红黑树) 源码: 初始容量 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; 加载因子:数组扩容的阀值 数组的容量(下标)达到数组的容量的0.75就会进行扩容 每层扩容 扩大2倍 16–32 扩容2倍的原因,这样原来的数据的hash值只能分为当前位置和新的位置,移动教少 static final float DEFAULT_LOAD_FACTOR = 0.75f; 链表转为数结构的阀值(最大值) static final int TREEIFY_THRESHOLD = 8; 树结构转为链表结构的阀值 数组扩容的原因:原来的桶表的数据被分担了二份,对于数据量少的没有必要转为树结构 static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; hashTable 和hashMaphashTable:线程安全 性能低 整个数组的线程锁 hashmap:线程非安全 性能高 ConcurrentHashMap 既可以做到线程安全 又可以保证性能 分段线程锁+读写锁 锁的分类: ​ 读锁:共享锁 所有的线程可以共用这把锁 ​ 写锁: 排它锁 同一时间只能允许一个线程操作 会对hashmap底层的数组进行分段加锁,通过具体的操作 决定加的是读锁还是写锁 排序递归 方法自己调用自己 递归原则: 1. 必须写一个独立的方法 ​ 2. 递归必须要有出口(不能是死循环) 3. 递归--- 有规律 1234567891011121314151617181920212223242526272829303132package java增强;public class Jiecheng &#123; public static void main(String[] args) &#123; // System.out.println(jc(5)); System.out.println(bsst(1)); System.out.println(bsst(2)); System.out.println(bsst(3)); System.out.println(bsst(4)); System.out.println(bsst(5)); System.out.println(bsst(6)); &#125; // 阶乘 public static int jc(int n) &#123; if (n == 1) &#123; return 1; &#125; else &#123; return n * jc(n - 1); &#125; &#125; // 不死神兔 public static int bsst(int i) &#123; if (i == 1 || i == 2) &#123; return 1; &#125; else &#123; return bsst(i - 1) + bsst(i - 2); &#125; &#125;&#125; 快速 选定基准点(一般选数组的第一个元素) 作用划分数据 ​ 基准点左侧: 比基准点小的数据 ​ 基准点右侧: 比基准点大的数据 通过循环遍历 归并计数排序]]></content>
  </entry>
  <entry>
    <title><![CDATA[redis02]]></title>
    <url>%2Fblog%2F2018%2F09%2F21%2Fredis02%2F</url>
    <content type="text"><![CDATA[持久化RDB : Redis database 默认持久化方式,将内存数据隔固定时长存储到窗磁盘文件 Redis默认的方式，redis通过快照来将数据持久化到磁盘中。 持久化文件存储的目录 在redis.conf中可以指定持久化文件存储的目录默认dum.rdb 执行原理: fork子进程,父进程和子进程 父进程处理client连接,子进程将数据库内容存储到磁盘文件 父进程创建snapshot(快照,共享信息),子进程处理的是snapshot的数据,写入到临时文件 当子进程将临时文件写入完成,关闭子进程 持久化策略:设置持久化快照的条件 123save 900 1 key修改了一次 900秒备份一次save 300 10 key修改了10次,300秒备份一次save 60 10000 key修改了10000 60秒备份一次 缺点: ​ 非法关闭,会丢失最后一次的持久化数据,如果数据不能允许丢失,那么要使用aof的方式 AOF: append only file 是将每次写操作存储到aof持久化文件中,默认是关闭的,仍然会有可能会丢失数据(os也会有缓存),强制每次执行 Aof方式的持久化，是操作一次redis数据库，则将操作的记录存储到aof持久化文件中。 第一步：开启aof方式的持久化方案将redis.conf中的appendonly改为yes，即开启aof方式的持久化方案。 启动: 672行 ;appendonly yes Aof文件存储的目录和rdb方式的一样。 Aof文件存储的名称”appendfilename &quot;apendonly.aof&quot; 结论在使用aof和rdb方式时，如果redis重启，则数据从aof文件加载。 Redis的主从复制1.1 什么是主从复制​ 持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图： 说明： 主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。 主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。 只有一个主redis，可以有多个从redis。 主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求 一个redis可以即是主又是从，如下图： 主从复制设置主机配置 无需配置 从机配置 复制出一个主机 cp -r 主机 从机 修该从机的redis.conf 查找slaverof 添加配置信息:语法:slaveof masterip masterport slaveof 192.168.2.101 6379 修改从机的port为6380 在redis.conf文件中修改 搜索修改即可 清除主机中的持久化文件 *.rdb;* aof 根据从机的配置文件启动从机 ./redis-server redis.conf 启动6380的客户端 ./redis-cli -h 192.168.2.101 -p 6380 注意 主机一旦发生增删改操作，那么从机会将数据同步到从机中 从机不能执行写操作 set s2 22212127.0.0.1:6380&gt; set s2 222(error) READONLY You can&apos;t write against a read only slave. Redis集群redis-cluster架构图 123456789架构细节(1) 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.(2)节点的fail是通过集群中 超过半数的节点检测 失效时才生效.(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点 redis-cluste 投票 :容错 123456(1)集群中所有master参与投票,如果半数以上master节点与其中一个master节点通信超过(cluster-node-timeout),认为该master节点挂掉.(2):什么时候整个集群不可用(cluster_state:fail)? 1. 如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态。也可以理解成集群的[0-16383]slot映射不完全时进入fail状态。 2. 如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。 安装ruby集群管理工具:（redis-trib.rb）是使用ruby脚本语言编写的。 第一步：安装ruby123[root@hdp01 bin2]# yum install ruby[root@hdp01 bin2]# yum install rubygems 第二步：将以下文件上传到linux系统 redis-3.0.0.gem 第三步,安装ruby和redis接口[root@hdp01 ~]# gem install redis-3.0.0.gem 第四步：将redis-3.0.0包下src目录中的以下文件拷贝到redis19/redis-cluster/1234[root@hdp01 src]# cd /usr/local/redis/[root@hdp01 redis19]# mkdir redis-cluster[root@hdp01 redis19]# cd /root/redis-3.0.0/src/[root@hdp01 src]# cp redis-trib.rb /usr/local/redis1/redis-cluster 搭建集群12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485搭建集群最少也得需要3台主机，如果每台主机再配置一台从机的话，则最少需要6台机器。端口设计如下：6380-6385第一步：复制出一个7001机器[root@hdp01 redis]# cp bin ./redis-cluster/7001 –r第二步：如果存在持久化文件，则删除[root@hdp01 7001]# rm -rf appendonly.aof dump.rdb第三步：设置集群参数 cluster-enabled yes第四步：修改端口 port 6380 第五步：复制出7002-7006机器[root@hdp01 redis-cluster]# cp 7001/ 7002 -r[root@hdp01 redis-cluster]# cp 7001/ 7003 -r[root@hdp01 redis-cluster]# cp 7001/ 7004 -r[root@hdp01 redis-cluster]# cp 7001/ 7005 -r[root@hdp01 redis-cluster]# cp 7001/ 7006 –r第六步：修改7002-7006机器的端口第七步：启动7001-7006这六台机器第八步：修改start-all.sh文件的权限[root@hdp01 redis-cluster]# chmod u+x start-all.sh第九步：创建集群[root@hdp01 redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.2.102:6380 192.168.2.102:6381 192.168.2.102:6382 192.168.2.102:6383 192.168.2.102:6384 192.168.2.102:6385&gt;&gt;&gt; Creating clusterConnecting to node 192.168.242.137:7001: OKConnecting to node 192.168.242.137:7002: OKConnecting to node 192.168.242.137:7003: OKConnecting to node 192.168.242.137:7004: OKConnecting to node 192.168.242.137:7005: OKConnecting to node 192.168.242.137:7006: OK&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:192.168.242.137:7001192.168.242.137:7002192.168.242.137:7003Adding replica 192.168.242.137:7004 to 192.168.242.137:7001Adding replica 192.168.242.137:7005 to 192.168.242.137:7002Adding replica 192.168.242.137:7006 to 192.168.242.137:7003M: 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24 192.168.242.137:7001 slots:0-5460 (5461 slots) masterM: 4f52a974f64343fd9f1ee0388490b3c0647a4db7 192.168.242.137:7002 slots:5461-10922 (5462 slots) masterM: cb7c5def8f61df2016b38972396a8d1f349208c2 192.168.242.137:7003 slots:10923-16383 (5461 slots) masterS: 66adf006fed43b3b5e499ce2ff1949a756504a16 192.168.242.137:7004 replicates 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24S: cbb0c9bc4b27dd85511a7ef2d01bec90e692793b 192.168.242.137:7005 replicates 4f52a974f64343fd9f1ee0388490b3c0647a4db7S: a908736eadd1cd06e86fdff8b2749a6f46b38c00 192.168.242.137:7006 replicates cb7c5def8f61df2016b38972396a8d1f349208c2Can I set the above configuration? (type &apos;yes&apos; to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join..&gt;&gt;&gt; Performing Cluster Check (using node 192.168.242.137:7001)M: 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24 192.168.242.137:7001 slots:0-5460 (5461 slots) masterM: 4f52a974f64343fd9f1ee0388490b3c0647a4db7 192.168.242.137:7002 slots:5461-10922 (5462 slots) masterM: cb7c5def8f61df2016b38972396a8d1f349208c2 192.168.242.137:7003 slots:10923-16383 (5461 slots) masterM: 66adf006fed43b3b5e499ce2ff1949a756504a16 192.168.242.137:7004 slots: (0 slots) master replicates 8240cd0fe6d6f842faa42b0174fe7c5ddcf7ae24M: cbb0c9bc4b27dd85511a7ef2d01bec90e692793b 192.168.242.137:7005 slots: (0 slots) master replicates 4f52a974f64343fd9f1ee0388490b3c0647a4db7M: a908736eadd1cd06e86fdff8b2749a6f46b38c00 192.168.242.137:7006 slots: (0 slots) master replicates cb7c5def8f61df2016b38972396a8d1f349208c2[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.[root@hdp01 redis-cluster]# 连接集群 ./redis-cli -h 192.168.2.102 -p 7001 –c -c：指定是集群连接 查看集群信息查看集群信息 192.168.242.137:7002&gt; cluster info 12345678910111213192.168.2.102:6381&gt; cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:2cluster_stats_messages_sent:1034cluster_stats_messages_received:1034192.168.2.102:6381&gt; 查看节点信息12345678192.168.2.102:6381&gt; cluster nodes46ca0fd9417a2bc172aa2863df2cab0da6617d2d 192.168.2.102:6382 master - 0 1537696177521 3 connected 10923-16383f53c4df09307ee23d5e06d9a7e936c581ac80b3d 192.168.2.102:6384 slave fed12b118c7d4c6ab95a3c2d3ffe49a71e9b2afa 0 1537696173493 5 connectedef29970508e820fe2f7b7c2a57befc69e9ed2589 192.168.2.102:6385 slave 46ca0fd9417a2bc172aa2863df2cab0da6617d2d 0 1537696174499 6 connected781aa9cb4deea53b8dce7405277d33176153fdc3 192.168.2.102:6383 slave d7cad0dd5dd1607eb4ca31e7be5344014d2a4cce 0 1537696176512 4 connectedfed12b118c7d4c6ab95a3c2d3ffe49a71e9b2afa 192.168.2.102:6381 myself,master - 0 0 2 connected 5461-10922d7cad0dd5dd1607eb4ca31e7be5344014d2a4cce 192.168.2.102:6380 master - 0 1537696175505 1 connected 0-5460192.168.2.102:6381&gt; jedis连接集群12345678910111213141516171819202122232425262728293031323334package test;import java.util.HashSet;import java.util.Set;import org.junit.Test;import redis.clients.jedis.HostAndPort;import redis.clients.jedis.JedisCluster;/** * jedis连接redis集群 * @author sun * */public class test3 &#123; @Test public void test() &#123; Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;(); nodes.add(new HostAndPort("192.168.2.102", 6380)); nodes.add(new HostAndPort("192.168.2.102", 6381)); nodes.add(new HostAndPort("192.168.2.102", 6382)); nodes.add(new HostAndPort("192.168.2.102", 6383)); nodes.add(new HostAndPort("192.168.2.102", 6384)); nodes.add(new HostAndPort("192.168.2.102", 6385)); JedisCluster cluster = new JedisCluster(nodes); cluster.set("s4", "sunfuliang"); String result = cluster.get("s4"); System.out.println(result); cluster.close(); &#125;&#125; Spring jedis连接redis集群123456789101112131415161718192021222324252627282930package test;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import redis.clients.jedis.JedisCluster;/** * jedis通过spring连接redis集群 * * @author sun * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:applicationContext.xml")public class test4 &#123; // redis集群 @Autowired JedisCluster jedisCluster; @Test public void testJedisCluster() &#123; jedisCluster.set("name", "zhangsan"); String value = jedisCluster.get("name"); System.out.println(value); &#125;&#125; applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="30" /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name="maxIdle" value="10" /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name="numTestsPerEvictionRun" value="1024" /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="1800000" /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name="softMinEvictableIdleTimeMillis" value="10000" /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name="maxWaitMillis" value="1500" /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name="blockWhenExhausted" value="false" /&gt; &lt;/bean&gt; &lt;!-- redis集群 --&gt; &lt;bean id="jedisCluster" class="redis.clients.jedis.JedisCluster"&gt; &lt;constructor-arg index="0"&gt; &lt;set&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.2.102"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="6380"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.2.102"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="6381"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.2.102"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="6382"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.2.102"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="6383"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.2.102"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="6384"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class="redis.clients.jedis.HostAndPort"&gt; &lt;constructor-arg index="0" value="192.168.2.102"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="6385"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1" ref="jedisPoolConfig"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- redis单机 通过连接池 &lt;bean id="pool" class="redis.clients.jedis.JedisPool" destroy-method="close"&gt; &lt;constructor-arg name="poolConfig" ref="jedisPoolConfig" /&gt; &lt;constructor-arg name="host" value="192.168.2.101" /&gt; &lt;constructor-arg name="port" value="6379" /&gt; &lt;/bean&gt; --&gt;&lt;/beans&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[redis01]]></title>
    <url>%2Fblog%2F2018%2F09%2F20%2Fredis01%2F</url>
    <content type="text"><![CDATA[nosql not only sql:解决海量数据和大型集群产生的高并发,高可用,高性能问题数据库解决方案, 非关系型数据库,不能替代关系型数据库,作为关系型数据库的一个良好补充(补充关系型数据库性能的瓶颈) 数据分类 结构化数据 数据的结构一样,使用同一的规范(格式)进行处理和维护(存储和管理)(RDBMS) 半结构化数据 介于二者之间的数据如xml 非结构化数据 无法通过统一格式进行存储管理,如文本,音频,视频等(nosql) nosql的分类 键值存储数据库 产品: Redis,Voldemont,BERKEKEY DB’ 典型应用:内容缓存,主要用于处理大量数据的高访问负债 数据模型: 一系列键值对 ​ json:{“key”:”value”, “key2”:”value2”} 优势:快速查询 劣势: 存储的数据缺少结构化 和memcache:的区别 memcache: 数据类型少,做缓存 redis:缓存数据,可以持久化,支持事务;数据类型多 列存储数据库 相关产品：Cassandra,HBase,Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型：一系列键值对 优势：数据结构要求不严格 愣势：查询性能不高，而且缺乏统一的查询语法 图形（Graph)数据库 相关数据库：Neo4j、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 Redis 是使用c语言开发的一个高性能键值数据库。Redis 可以通过一些键值类型来存储数据。也可以实现持久化支持事务操作 常用键值类型： String 字符类型 map 散列类型 list 列表类型 set 集合类型 sortedset 有序集合类型(zset) redis的应用场景缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用） 分布式集群架构中的 session分离。 聊天室的在线好友列表。 任务队列。（秒杀、抢购、12306等等） 应用排行榜。 网站访问统计。 数据过期处理（可以精确到毫秒） redis的安装 下载 安装: 准备gcc环境 yum -y install gcc-c++ make命令: yum -y install make 上传 解压:tar -zxvf redis-4.0.10.tar.gz -C /opt/ 进入:cd /opt/redis-4.0.10/ 编译:make / make distclean(清理之前的编译) ….&gt;&gt;/dev/null (黑洞) ,删掉的意思 make test():测试(安装tcl) 安装 make install(默认安装/usr/local/bin) 手动修改安装路径:make install PREFIX=/usr/local/redis cd /usr/local/redis/bin存放可执行的文件 赋值配置文件到etc目录下:cp /opt/redis-4.0.10/redis.conf /etc/ 环境变量 export REDIS_HOME=/usr/local/redis export PATH=$PATH:$JAVA_HOME/bin:$REDIS_HOME/bin; redis启动(服务器端+客户端)前端启动 不推荐,(占用一个窗口), 在目录下cd /usr/local/redis/bin 启动服务端:redis-server port:6379 关闭: 强制关闭:ctrl +C 客户端发送:./redis-cli发送 shutdown(推荐) 启动客户端 redis-cli 发送ping 响应PONG 后端启动 修改配置文件vim /etc/redis.conf 修改绑定的ip(69行) bind 192.168.2.101 修改为台守护进程运行(136行) daemonize yes databases 16: 分了16数据库 ​ 下标默认(0-15) 启动 redis-server /etc/redis.conf 查看 ps -aux|grep redis netstat -nltp 关闭服务端 kill -9 6379 redis-cli shutdown(推荐) 自带客户端连接 redis-cli -h ip地址 -p 端口 redis-cli -h 192.168.2.101 -p 6379 图形客户端 需要注意防火墙 jedis客户端Redis 数据类型字符串String命令 赋值和取值 set key value setget key value: 取值并赋值 删除 del key 数值增减 incr key :增量1 incrby key n: 增量n decr: key :减少1 decrby key n: 减少n 其他命令 append key value : 追加值 stlen key :获取值得长度 应用:自增主键 商品编号,订单号采用string的递增数值特性生成 12345定义商品: key items:id&gt; incr items:id(integer)2&gt; incr items:id(integer)3 hash类型 散列类型:支持扩展key,提供字段属性,字段,字段值之间的映射 字段值只支持字符串 键 字段名 字段值 赋值 hset:一次只能设置一个字段 hmset :一次可以设置多个字段值 hsetnx:有该key则不赋值,没有则赋值相当于hset hset不区分插入和更新,0代表更新,1代表插入 123456192.168.2.101:6379&gt; hset user:001 name zs(integer) 1192.168.2.101:6379&gt; hset user:001 name ls(integer) 0192.168.2.101:6379&gt; hmset user age 20 username lisi OK 取值 hget: 一次只能取一个字段值 HMGET key field [field …] : 一次可以获取多个字段值 hgetall key: 123456789101112192.168.2.101:6379&gt; hget user:001 name&quot;zs&quot; hmget user:sun name age1) &quot;sun&quot;2) &quot;21&quot;192.168.2.101:6379&gt; HGETALL user:0011) &quot;name&quot;2) &quot;zs&quot;3) &quot;sex&quot;4) &quot;0&quot; 删除字段 hdel :删除字段 1234567192.168.2.101:6379&gt; hedl user:001 sex(error) ERR unknown command &apos;hedl&apos;192.168.2.101:6379&gt; hdel user:001 sex(integer) 1192.168.2.101:6379&gt; HGETALL user:0011) &quot;name&quot;2) &quot;zs&quot; 增加数字 hincrby 12345678910111213141516192.168.2.101:6379&gt; hset user:001 age 15(integer) 1192.168.2.101:6379&gt; hgetall user:0011) &quot;name&quot;2) &quot;zs&quot;3) &quot;age&quot;4) &quot;15&quot;192.168.2.101:6379&gt; hincrby user:001 age 3(integer) 18192.168.2.101:6379&gt; hgetall user:0011) &quot;name&quot;2) &quot;zs&quot;3) &quot;age&quot;4) &quot;18&quot; 其他命令判断字段是否存在 haexists key 字段名 :1存在 ,0不存在 1234192.168.2.101:6379&gt; HEXISTS user:001 sex(integer) 0192.168.2.101:6379&gt; HEXISTS user:001 age(integer) 1 获取字段名或字段值 语法: ​ hkeys key ​ hvals key 1234567192.168.2.101:6379&gt; hkeys user:sun1) &quot;name&quot;2) &quot;age&quot;192.168.2.101:6379&gt; hvals user:sun1) &quot;sun&quot;2) &quot;21&quot; 获取字段的数量 hlen key 12192.168.2.101:6379&gt; HLEN user:001(integer) 2 应用 存储商品信息 商品字段 【商品id、商品名称、商品描述、商品库存、商品好评】 定义商品信息的key 商品1001的信息在 Redis中的key为：[items:1001] 存储商品信息 12192.168.101.3:7003&gt; HMSET items:1001 id 3 name apple price 999.9OK 获取商品信息 123456789192.168.101.3:7003&gt; HGET items:1001 id&quot;3&quot;192.168.101.3:7003&gt; HGETALL items:10011) &quot;id&quot;2) &quot;3&quot;3) &quot;name&quot;4) &quot;apple&quot;5) &quot;price&quot;6) &quot;999.9&quot; list列表类型arraylist 和linkedlsit的区别 arraylist 是使用数组来存储数,特点:增删慢,查询快(连续空间) linkedlist: 是使用双向链表存储数据,特定:增删快,查询慢,但是查询链表二端的数据也很快 redis的list采用链表来存储的数据,操作从二端操作 向列表二端添加元素添加元素 lpush key value : 向列表的左边增加元素 rpush key value: 向列表的右边增加元素 1234567891011192.168.2.101:6379&gt; lpush list1 a b c(integer) 3192.168.2.101:6379&gt; rpush list1 d e f(integer) 6192.168.2.101:6379&gt; LRANGE list1 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;d&quot;5) &quot;e&quot;6) &quot;f&quot; 从列表二端弹出元素 lpop key LPOP命令从列表左边弹出一个元素，会分两步完成： 第一步是将列表左边的元素从列表中移除 第二步是返回被移除的元素值。 rpop key 1234192.168.2.101:6379&gt; LPOP list1&quot;c&quot;192.168.2.101:6379&gt; rpop list1&quot;f&quot; 查看列表 lrange命令,获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 1234567891011192.168.2.101:6379&gt; lrange list1 0 21) &quot;b&quot;2) &quot;a&quot;3) &quot;d&quot;192.168.2.101:6379&gt; 192.168.2.101:6379&gt; lrange list1 0 -11) &quot;b&quot;2) &quot;a&quot;3) &quot;d&quot;4) &quot;e&quot; 获取列表中元素的个数语法:llen key 12127.0.0.1:6379&gt; llen list:1(integer) 2 其他命令删除列表中指定的值 LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 当count&gt;0时， LREM会从列表左边开始删除。 当count&lt;0时， LREM会从列表后边开始删除。 当count=0时， LREM删除所有值为value的元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051192.168.2.101:6379&gt; LRANGE list1 0 -1 1) &quot;e&quot; 2) &quot;d&quot; 3) &quot;b&quot; 4) &quot;b&quot; 5) &quot;a&quot; 6) &quot;e&quot; 7) &quot;d&quot; 8) &quot;b&quot; 9) &quot;b&quot;10) &quot;a&quot;11) &quot;b&quot;12) &quot;a&quot;13) &quot;d&quot;14) &quot;e&quot;192.168.2.101:6379&gt; LREM list1 3 a(integer) 3192.168.2.101:6379&gt; LRANGE list1 0 -1 1) &quot;e&quot; 2) &quot;d&quot; 3) &quot;b&quot; 4) &quot;b&quot; 5) &quot;e&quot; 6) &quot;d&quot; 7) &quot;b&quot; 8) &quot;b&quot; 9) &quot;b&quot;10) &quot;d&quot;11) &quot;e&quot;192.168.2.101:6379&gt; LREM list1 0 b(integer) 5------------------------------------------------192.168.2.101:6379&gt; LRANGE list1 0 -11) &quot;e&quot;2) &quot;d&quot;3) &quot;e&quot;4) &quot;d&quot;5) &quot;d&quot;6) &quot;e&quot;------------------------------------------------192.168.2.101:6379&gt; LREM list1 -2 d(integer) 2192.168.2.101:6379&gt; LRANGE list1 0 -11) &quot;e&quot;2) &quot;d&quot;3) &quot;e&quot;4) &quot;e&quot;192.168.2.101:6379&gt; 获取/设置指定索引的元素值语法:lindex key index 123456789192.168.2.101:6379&gt; LRANGE list1 0 -11) &quot;e&quot;2) &quot;d&quot;3) &quot;e&quot;4) &quot;e&quot;192.168.2.101:6379&gt; LINDEX list1 0&quot;e&quot;192.168.2.101:6379&gt; LINDEX list1 -3&quot;d&quot; 保留片段语法:ltrim key start stop 1234567891011127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot;4) &quot;2&quot;127.0.0.1:6379&gt; ltrim l:list 0 2OK127.0.0.1:6379&gt; lrange l:list 0 -11) &quot;6&quot;2) &quot;5&quot;3) &quot;0&quot; 插入某个元素的前后位置语法:linsert key before|after pivot value 该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 12345678910111213127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; linsert list after 3 4(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;4) &quot;1&quot; 将元素从一个列表转移到另一个列表语法:rpoplpush source destionation 12345678127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot;127.0.0.1:6379&gt; lrange newlist 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot; 应用123456789商品评论列表思路：在Redis中创建商品评论列表用户发布商品评论，将评论信息转成json存储到list中。用户在页面查询评论列表，从redis中取出json数据展示到页面。定义商品评论列表key：商品编号为1001的商品评论key【items: comment:1001】192.168.101.3:7001&gt; LPUSH items:comment:1001 &apos;&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;商品不错，很好！！&quot;,&quot;date&quot;:1430295077289&#125;&apos; set集合类型 集合类型 集合类型：无序、不可重复 列表类型：有序、可重复 sadd 添加和删除语法:SADD key member [member ...] 语法:SREM key member [member ...] 获得集合中的所有元素语法:smembers key sismember key member 判断是否在其中 123456789101112192.168.2.101:6379&gt; sadd set1 a b c d(integer) 4192.168.2.101:6379&gt; SREM set1 a(integer) 1192.168.2.101:6379&gt; SMEMBERS set11) &quot;c&quot;2) &quot;b&quot;3) &quot;d&quot;192.168.2.101:6379&gt; SISMEMBER set1 c(integer) 1 判断元素是否在集合中语法:sismemner key member 运算命令并集 sunion key1 key2 交集 sinter key1 key2 差集 sdiff key1 key2 其他命令获得集合中的元素个数 语法:scard key 从集合中弹出一个元素 注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 语法:spop key spop:弹出: 无序,随便弹(相当于删除一个元素) sortedset Sortedset 又叫zset 是有序集合,可排序,但是唯一 Sortedset和set的不同之处，是会给set中的元素添加一个分数，然后通过这个分数进行排序。 添加元素 向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 添加元素和分数,如果元素存在则修改分数并返回0 ,不存在返回1 语法:ZADD key score member [score member ...] 123456192.168.2.101:6379&gt; ZADD zset1 80 zs 90 ls 100 ww(integer) 3192.168.2.101:6379&gt; ZADD zset1 85 zs(integer) 0192.168.2.101:6379&gt; ZADD zset1 75 zl(integer) 1 删除元素 移除有序集key中的一个或多个成员，不存在的成员将被忽略。 当key存在但不是有序集类型时，返回一个错误。 ZREM key member [member ...] 12192.168.2.101:6379&gt; zrem zset1 zs(integer) 1 查看元素的分数 zscore key member 12192.168.2.101:6379&gt; ZSCORE zset1 zs&quot;85&quot; 获取元素的排名 从小到大: 语法zrank key member 从大到小:语法zrevrank key member 获取范围内的元素列表语法:zrange key start stop [withscores] 按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 123456789101112192.168.2.101:6379&gt; ZRANGE zset1 0 -11) &quot;zl&quot;2) &quot;ls&quot;3) &quot;ww&quot;192.168.2.101:6379&gt; ZRANGE zset1 0 -1 withscores1) &quot;zl&quot;2) &quot;75&quot;3) &quot;ls&quot;4) &quot;90&quot;5) &quot;ww&quot;6) &quot;100&quot; 倒序输出 zrevrange key start stop [withscores] 1234567891011192.168.2.101:6379&gt; ZREVRANGE zset1 0 -11) &quot;ww&quot;2) &quot;ls&quot;3) &quot;zl&quot;192.168.2.101:6379&gt; ZREVRANGE zset1 0 -1 withscores1) &quot;ww&quot;2) &quot;100&quot;3) &quot;ls&quot;4) &quot;90&quot;5) &quot;zl&quot;6) &quot;75&quot; 其他命令获取指定分数范围内的元素语法:zrangebyscore key min max [withscires] limit offset count 12345678127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES1) &quot;wangwu&quot;2) &quot;94&quot;3) &quot;lisi&quot;4) &quot;97&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 21) &quot;wangwu&quot;2) &quot;lisi&quot; 增加某个元素的分数 返回值是更改后的分数 语法: zincrby key increment member 12127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101“ 获取集合中元素的数量语法:zcard key 12127.0.0.1:6379&gt; ZCARD scoreboard(integer) 3 获取指定分数范围内的元素个数语法:zcount key min max 12127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90(integer) 1 按照排名范围删除元素语法:zremrangebyrank key start stop 1234127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1(integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -11) &quot;lisi&quot; 按照分数范围删除元素语法:zremrangebyscore key min max 1234127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan (integer) 1127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100(integer) 1 应用商品销售排行榜123456789101112需求：根据商品销售量对商品进行排行显示思路：定义商品销售排行榜（sorted set集合），Key为items:sellsort，分数为商品销售量。写入商品销售量：商品编号1001的销量是9，商品编号1002的销量是10192.168.101.3:7007&gt; ZADD items:sellsort 9 1001 10 1002商品编号1001的销量加1192.168.101.3:7001&gt; ZINCRBY items:sellsort 1 1001商品销量前10名：192.168.101.3:7001&gt; ZRANGE items:sellsort 0 9 withscores ### ## KEYS命令常用命令keys语法:keys parttern 1234567返回满足给定pattern 的所有keyredis 127.0.0.1:6379&gt; keys mylist*1) &quot;mylist&quot;2) &quot;mylist5&quot;3) &quot;mylist6&quot;4) &quot;mylist7&quot;5) &quot;mylist8&quot; exists 判断key是否存在,0不存在,1存在 12345678redis 127.0.0.1:6379&gt; exists HongWan(integer) 0redis 127.0.0.1:6379&gt; exists age(integer) 1redis 127.0.0.1:6379&gt;从结果来看，数据库中不存在HongWan 这个key，但是age 这个key 是存在的 del 删除一个key 1234redis 127.0.0.1:6379&gt; del age(integer) 1redis 127.0.0.1:6379&gt; exists age(integer) 0 rename 重命名key 12345678age 成功的被我们改名为age_newredis 127.0.0.1:6379[1]&gt; keys *1) &quot;age&quot;redis 127.0.0.1:6379[1]&gt; rename age age_newOKredis 127.0.0.1:6379[1]&gt; keys *1) &quot;age_new&quot;redis 127.0.0.1:6379[1]&gt; type 返回值的类型 1234567redis 127.0.0.1:6379&gt; type addrstringredis 127.0.0.1:6379&gt; type myzset2zsetredis 127.0.0.1:6379&gt; type mylistlistredis 127.0.0.1:6379&gt; 设置key的生存时间 缓存的数据一般都是需要设置生存时间,到期后数据笑话 expire key seconds 设置key秒之后销毁 ttl key 查看key的生存时间:默认-1 ,销毁后为-2 1234EXPIRE key seconds 设置key的生存时间（单位：秒）key在多少秒后会自动删除TTL key 查看key生于的生存时间PERSIST key 清除生存时间 PEXPIRE key milliseconds 生存时间设置单位为：毫秒 123456789101112192.168.101.3:7002&gt; set test 1 设置test的值为1OK192.168.101.3:7002&gt; get test 获取test的值&quot;1&quot;192.168.101.3:7002&gt; EXPIRE test 5 设置test的生存时间为5秒(integer) 1192.168.101.3:7002&gt; TTL test 查看test的生于生成时间还有1秒删除(integer) 1192.168.101.3:7002&gt; TTL test(integer) -2192.168.101.3:7002&gt; get test 获取test的值，已经删除(nil)]]></content>
  </entry>
  <entry>
    <title><![CDATA[linuxday05]]></title>
    <url>%2Fblog%2F2018%2F09%2F19%2Flinuxday05Shell%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Shell操作实用技巧 Shell操作日期时间1234567891011date - print or set the system date and timelinux系统为我们提供了一个命令date，专门用来显示或者设置系统日期时间的。语法格式为：date [OPTION]... [+FORMAT] 或者date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]常用的可选项有：--help：显示辅助信息--version：显示date命令版本信息-u：显示目前的格林威治时间-d：做日期时间相关的运算--date=&apos;-dateStr&apos;：做日期时间的相关运算 123456781、显示系统当前日期时间[root@hadoop ~]# date以指定格式显示日期时间[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos;2、设置系统日期时间[root@hadoop ~]# date -s &quot;2017-01-01 01:01&quot;[root@hadoop ~]# date --set=&quot;2017-01-01 01:01&quot; 123456789101112131415161718192021222324252627282930313233343536373839403、有时候，我们操作日期时间，经常会要获取前几天或者后几天的时间，那么date命令也给我们提供了实现这个功能的可选项&apos;-d&apos;和&apos;--date&apos;，请看下面细细的例子先看&apos;-d&apos;：## 获取下一天的时间[root@hadoop ~]# date -d next-day &apos;+%Y-%m-%d %H:%M:%S&apos;[root@hadoop ~]# date -d &apos;next day&apos; &apos;+%Y-%m-%d %H:%M:%S&apos;另外一种写法：[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos; -d tomorrow## 获取上一天的时间 [root@hadoop ~]# date -d last-day &apos;+%Y-%m-%d %H:%M:%S&apos;另外一种写法：[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos; -d yesterday## 获取下一月的时间[root@hadoop ~]# date -d next-month &apos;+%Y-%m-%d %H:%M:%S&apos;## 获取上一月的时间 [root@hadoop ~]# date -d last-month &apos;+%Y-%m-%d %H:%M:%S&apos;## 获取下一年的时间[root@hadoop ~]# date -d next-year &apos;+%Y-%m-%d %H:%M:%S&apos;## 获取上一年的时间 [root@hadoop ~]# date -d last-year &apos;+%Y-%m-%d %H:%M:%S&apos;## 获取上一周的日期时间：[root@hadoop ~]# date -d next-week &apos;+%Y-%m-%d %H:%M:%S&apos;[root@hadoop ~]# date -d next-monday &apos;+%Y-%m-%d %H:%M:%S&apos;[root@hadoop ~]# date -d next-thursday &apos;+%Y-%m-%d %H:%M:%S&apos;那么类似的，其实，last-year，last-month，last-day，last-week，last-hour，last-minute，last-second都有对应的实现。相反的，last对应next，自己可以根据实际情况灵活组织接下来，我们来看&apos;--date&apos;，它帮我实现任意时间前后的计算，来看具体的例子：## 获取一天以后的日期时间[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos; --date=&apos;1 day&apos;[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos; --date=&apos;-1 day ago&apos;## 获取一天以前的日期时间[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos; --date=&apos;-1 day&apos;[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos; --date=&apos;1 day ago&apos;上面的例子显示出来了使用的格式，使用精髓在于改变前面的字符串显示格式，改变数据，改变要操作的日期对应字段，除了天也有对应的其他实现：year，month，week，day，hour，minute，second，monday（星期，七天都可） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474、date 能用来显示或设定系统的日期和时间，在显示方面，使用者能设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下：使用范例：[root@hadoop ~]# date &apos;+%Y-%m-%d %H:%M:%S&apos;日期方面：%a : 星期几 (Sun..Sat) %A : 星期几 (Sunday..Saturday) %b : 月份 (Jan..Dec) %B : 月份 (January..December) %c : 直接显示日期和时间 %d : 日 (01..31) %D : 直接显示日期 (mm/dd/yy) %h : 同 %b %j : 一年中的第几天 (001..366) %m : 月份 (01..12) %U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形) %w : 一周中的第几天 (0..6) %W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形) %x : 直接显示日期 (mm/dd/yyyy) %y : 年份的最后两位数字 (00.99) %Y : 完整年份 (0000..9999)时间方面：%%: 打印出%%n : 下一行%t : 跳格%H : 小时(00..23)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地AM或PM%P : 显示本地am或pm%r : 直接显示时间(12 小时制，格式为 hh:mm:ss [AP]M)--&gt; %s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间(24小时制)%X : 相当于%H:%M:%S %p%Z : 显示时区若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]MM 为月份， DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数例子：date &quot;050602032017.55&quot; 123456789101112131415161718195、有用的小技巧## 获取相对某个日期前后的日期：[root@hadoop ~]# date -d &apos;may 14 -2 weeks&apos;Mon Apr 30 00:00:00 CST 2018## 把时间当中无用的0去掉，比如：01:02:25会变成1:2:25[root@hadoop ~]# date &apos;+%-H:%-M:%-S&apos;## 显示文件最后被更改的时间[root@hadoop ~]# date &quot;+%Y-%m-%d %H:%M:%S&quot; -r bin/removeJDK.sh## 求两个字符串日期之间相隔的天数[root@hadoop ~]# expr &apos;(&apos; $(date +%s -d &quot;2016-08-08&quot;) - $(date +%s -d &quot;2016-09-09&quot;) &apos;)&apos; / 86400expr `expr $(date +%s -d &quot;2016-08-08&quot;) - $(date +%s -d &quot;2016-09-09&quot;)` / 86400r## shell中加减指定间隔单位[root@hadoop ~]# A=`date +%Y-%m-%d` [root@hadoop ~]# B=`date +%Y-%m-%d -d &quot;$A +48 hours&quot;` 高级文本处理命令wc1234567891011121314151617功能： 统计文件行数、字节、字符数常用选项：-l：统计多少行-w：统计字数-c：统计文件字节数，一个英文字母1字节，一个汉字占2-4字节（根据编码）-m：统计文件字符数，一个英文字母1字符，一个汉字占1个字符-L：统计最长行的长度， 也可以统计字符串长度-help：显示帮助信息--version：显示版本信息一个汉字到底几个字节？占2个字节的：〇 占3个字节的：基本等同于GBK，含21000多个汉字占4个字节的：中日韩超大字符集里面的汉字，有5万多个一个utf8数字占1个字节一个utf8英文字母占1个字节 1234567891011121314151617181920示例：统计文件信息[linux@linux ~]$ wc wc.txt4 8 77 wc.txt行数 单词数 字节数 文件名统计字符串长度[linux@linux ~]$ echo &quot;hello&quot; | wc -L5统计文件行数：[linux@linux ~]$ wc -l mingxing.txt 6 mingxing.txt统计文件字数：[linux@linux ~]$ wc -w mingxing.txt 7 mingxing.txt sort123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566功能：排序文本，默认对整列有效常用可选项：-f：忽略字母大小写，就是将小写字母视为大写字母排序-M：根据月份比较，比如 JAN、DEC-h：根据易读的单位大小比较，比如 2K、1G-g：按照常规数值排序-n：根据字符串数值比较-r：倒序排序-k：位置1,位置2根据关键字排序，在从第位置1开始，位置2结束-t：指定分隔符-u：去重重复行-o：将结果写入文件准备数据：aaa:10:1.1ccc:20:3.3bbb:40:4.4eee:40:5.5ddd:30:3.3bbb:40:4.4fff:30:2.2示例：[linux@linux ~]$ cat sort.txt ## 准备排序文件，查看该内容 aaa:10:1.1ccc:20:3.3bbb:40:4.4eee:40:5.5ddd:30:3.3bbb:40:4.4fff:30:2.2 [linux@linux ~]$ sort sort.txt ## 直接排序，把整行当做一列字符串，字典顺序 aaa:10:1.1bbb:40:4.4bbb:40:4.4ccc:20:3.3ddd:30:3.3eee:40:5.5fff:30:2.2[linux@linux ~]$ sort -nk 2 -t : sort.txt ## 以:作为分隔符，取第二个字段按照数值进行排序 aaa:10:1.1ccc:20:3.3fff:30:2.2ddd:30:3.3bbb:40:4.4bbb:40:4.4eee:40:5.5 [linux@linux ~]$ sort -nk 2 -u -t : sort.txt ## 和上一个不一样的是-u为了去重 aaa:10:1.1ccc:20:3.3ddd:30:3.3bbb:40:4.4 多列排序：以:分隔，按第二列数值排倒序，第三列正序[linux@linux ~]$ sort -n -t: -k2,2r -k3 sort.txt bbb:40:4.4bbb:40:4.4eee:40:5.5fff:30:2.2ddd:30:3.3ccc:20:3.3aaa:10:1.1 uniq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172功能：去除重复行，只会统计相邻的常用选项：-c：打印出现的次数-d：只打印重复行-u：只打印不重复行-D：只打印重复行，并且把所有重复行打印出来-f N：比较时跳过前N列-i：忽略大小写-s N：比较时跳过前N个字符-w N：对每行第N个字符以后内容不做比较准备数据：abcxyzcdecdexyzabd示例1：[linux@linux ~]$ uniq uniq.txt ## 直接去重，只能在相邻行去重abcxyzcdexyzabd[linux@linux ~]$ sort uniq.txt | uniq ## 先给文件排序，然后去重abcabdcdexyz[linux@linux ~]$ sort uniq.txt | uniq -c ## 打印每行重复次数 1 abc 1 abd 2 cde 2 xyz[linux@linux ~]$ sort uniq.txt | uniq -u -c ## 打印不重复行，并给出次数 1 abc 1 abd[linux@linux ~]$ sort uniq.txt | uniq -d -c ## 打印重复行，并给出次数 2 cde 2 xyz[linux@linux ~]$ sort uniq.txt | uniq -w 2 ## 以开头前两个字符为判断标准去重abccdexyz示例2：先准备两个文件：a.txt 和 b.txt文件内容分别为：需求：1、求两个文件的交集：[hadoop@hadoop04 data]$ cat a.txt b.txt | sort | uniq -d2、求两个文件的并集：[hadoop@hadoop04 data]$ cat a.txt b.txt | sort | uniq3、求a.txt和b.txt的差集[hadoop@hadoop04 data]$ cat a.txt b.txt b.txt | sort | uniq -u4、求b.txt和a.txt的差集[hadoop@hadoop04 data]$ cat b.txt a.txt a.txt | sort | uniq -u cut12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758cut命令可以从一个文本文件或者文本流中提取文本列cut语法cut -d&apos;分隔字符&apos; -f fields ## 用于有特定分隔字符cut -c 字符区间 ## 用于排列整齐的信息选项与参数： -d：后面接分隔字符。与 -f 一起使用-f：依据 -d的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思-c：按照字符截取-b：按照字节截取例子1：首先看PATH变量：[root@localhost ~]# echo $PATH/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin将PATH变量取出，找出第五个路径[root@localhost ~]# echo $PATH | cut -d &apos;:&apos; -f 5/usr/sbin将PATH变量取出，找出第三和第五个路径，以下三种方式都OK[root@localhost ~]# echo $PATH | cut -d &apos;:&apos; -f 3,5[root@localhost ~]# echo $PATH | cut -d : -f 3,5[root@localhost ~]# echo $PATH | cut -d: -f3,5/sbin:/usr/sbin将PATH变量取出，找出第三到最后一个路径[root@localhost ~]# echo $PATH | cut -d &apos;:&apos; -f 3-/sbin:/bin:/usr/sbin:/usr/bin:/root/bin将PATH变量取出，找出第一到第三，还有第五个路径[root@localhost ~]# echo $PATH | cut -d &apos;:&apos; -f 1-3,5/usr/local/sbin:/usr/local/bin:/sbin:/usr/sbin例子2：先准备已空格分开的这么段数据：黄渤 huangbo 18 jiangxi徐峥 xuzheng 22 hunan王宝强 wangbaoqiang 44 liujiayao获取中间的年龄：[root@localhost ~]# cut -f 3 -d &apos; &apos; cut.txt 182244获取第二个字符到第五个字符之间的字符：[root@localhost ~]# cut -c 2-5 cut.txt 渤 hu峥 xu宝强 w获取第四个字节到第六个字节中的字符：[root@hadoop ~]# cut -b 4-6 cut.txt渤峥宝 grep（文本生成器）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091grep是一种强大的文本搜索工具，他能使用正则表达式搜索文本，并把匹配的行统计出来命令：grep [选项] [–color=auto] ”搜索字符串” filename 常用参数： -c：统计符合条件的字符串出现的总行数。 -E：支持扩展正则表达式。 -i：忽略字符大小写。 -n：在显示匹配到的字符串前面加上行号。 -v：显示没有”搜索字符串”内容的那一行。 -l：列出文件内容中有搜索字符串的文件名称。 -o：只输出文件中匹配到的部分。 -color=auto：将匹配到的字符串高亮出来。1、基本使用查询包含hadoop的行grep hadoop /etc/passwd[root@localhost ~]# grep hadoop /etc/passwdhadoop:x:500:504:hadoop01:/home/hadoop:/bin/bashgrep huangbo ./*.txt ## 寻找当前路径下所有txt当中内容那些是带了huangbo字符串的[root@localhost ~]# grep huangbo ./*.txt./mazhonghua.txt:my name is huangbo is is huangbo ./sutdent.txt:huangbo 18 jiangxi 2、先看一份数据：grep.txthuangbo is shuaigehuangxiaoming is shuaigeliuyifei is meinvhello world hello tom hello kitty#how old are you#one two three four five six seven eight nine ten2.1、统计出现某个字符串的行的总行数grep -c &apos;hello&apos; grep.txtgrep -c &apos;is&apos; grep.txt [hadoop@hadoop04 ~]# grep -c &apos;hello&apos; grep.txt[hadoop@hadoop04 ~]# grep -c &apos;is&apos; grep.txt2.2、查询不包含is的行grep -v &apos;is&apos; grep.txt[hadoop@hadoop04 ~]# grep -v &apos;is&apos; grep.txt2.3、正则表达包含huanggrep &apos;.*huang.*&apos; grep.txt[hadoop@hadoop04 ~]# grep &apos;.*huang.*&apos; grep.txt2.4、输出匹配行的前后N行（会包括匹配行）使用-A参数输出匹配行的后一行：grep -A 1 &quot;huangxiaoming&quot; grep.txt使用-B参数输出匹配行的前一行：grep -B 1 &quot;huangxiaoming&quot; grep.txt使用-C参数输出匹配行的前后各一行：grep -C 1 &quot;huangxiaoming&quot; grep.txt3、正则表达(点代表任意一个字符)grep &apos;h.*p&apos; /etc/passwd4、正则表达以hadoop开头grep &apos;^hadoop&apos; /etc/passwd5、正则表达以hadoop结尾grep &apos;hadoop$&apos; /etc/passwd以h或r开头的grep &apos;^[hr]&apos; /etc/passwd 不是以h和r开头的grep &apos;^[^hr]&apos; /etc/passwd不是以h到r开头的grep &apos;^[^h-r]&apos; /etc/passwd正则表达式的简单规则：. : 任意一个字符a* : 任意多个a(零个或多个a)a? : 零个或一个aa+ : 一个或多个a.* : 任意多个任意字符\. : 转义.o\&#123;2\&#125; : o重复两次[A-Z][ABC]查找不是以#开头的行grep -v &apos;^#&apos; grep.txt | grep -v &apos;^$&apos; [root@localhost ~]# grep -v &apos;^#&apos; grep.txt # 不是以#开头的行,该行不是空行[root@localhost ~]# grep -v &apos;^#&apos; grep.txt | grep -v &apos;^$&apos; sed（流编辑器）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107sed叫做流编辑器，在shell脚本和Makefile中作为过滤一使用非常普遍，也就是把前一个程序的输出引入sed的输入，经过一系列编辑命令转换成为另一种格式输出。sed是一种在线编辑器，它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为&quot;模式空间&quot;,接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出。选项: -n：一般sed命令会把所有数据都输出到屏幕，如果加入-n选项的话，则只会把经过sed命令处理的行输出到屏幕。-e：允许对输入数据应用多条sed命令编辑。 -i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。动作: a：追加，在当前行后添加一行或多行。 c：行替换，用c后面的字符串替换原数据行。 i：插入，在当前行前插入一行或多行。 p：打印，输出指定的行。 s：字符串替换，用一个字符串替换另外一个字符串。格式为&apos;行范围s/旧字符串/新字符串/g&apos; (如果不加g的话，则表示只替换每行第一个匹配的串)1、删除：d命令sed &apos;2d&apos; sed.txt -----删除sed.txt文件的第二行。sed &apos;2,$d&apos; sed.txt -----删除sed.txt文件的第二行到末尾所有行。sed &apos;$d&apos; sed.txt -----删除sed.txt文件的最后一行。sed &apos;/test/d &apos; sed.txt -----删除sed.txt文件所有包含test的行。sed &apos;/[A-Za-z]/d &apos; sed.txt -----删除sed.txt文件所有包含字母的行。2、整行替换：c命令将第二行替换成hello worldsed &apos;2c hello world&apos; sed.txt3、字符串替换：s命令sed &apos;s/hello/hi/g&apos; sed.txt ## 在整行范围内把hello替换为hi。如果没有g标记，则只有每行第一个匹配的hello被替换成hi。sed &apos;s/hello/hi/2&apos; sed.txt## 此种写法表示只替换每行的第2个hello为hised &apos;s/hello/hi/2g&apos; sed.txt## 此种写法表示只替换每行的第2个以后的hello为hi（包括第2个）sed -n &apos;s/^hello/hi/p&apos; sed.txt ## (-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的hello被替换成hi，就打印它。sed -n &apos;2,4p&apos; sed.txt## 打印输出sed.txt中的第2行和第4行sed -n &apos;s/hello/&amp;-hi/gp&apos; sed.txtsed &apos;s/^192.168.0.1/&amp;-localhost/&apos; sed.txt sed &apos;s/^192.168.0.1/[&amp;]/&apos; sed.txt ## &amp;符号表示追加一个串到找到的串后。所有以192.168.0.1开头的行都会被替换成它自已加 -localhost，变成192.168.0.1-localhost。第三句表示给IP地址添加中括号sed -n &apos;s/\(liu\)jialing/\1tao/p&apos; sed.txtsed -n &apos;s/\(liu\)jia\(ling\)/\1tao\2ss/p&apos; sed.txt## liu被标记为\1，所以liu会被保留下来（\1 == liu）## ling被标记为\2，所以ling也会被保留下来（\2 == ling）## 所以最后的结果就是\1tao\2ss == &quot;liu&quot; + &quot;tao&quot; + &quot;ling&quot; + &quot;ss&quot;此处切记：\1代表的是被第一个()包含的内容，\1代表的是被第一个()包含的内容，……上面命令的意思就是：被括号包含的字符串会保留下来，然后跟其他的字符串比如tao和ss组成新的字符串liutaolingsssed &apos;s#hello#hi#g&apos; sed.txt## 不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，&quot;#&quot;在这里是分隔符，代替了默认的&quot;/&quot;分隔符。表示把所有hello替换成hi。选定行的范围：逗号sed -n &apos;/today/,/hello/p&apos; sed.txt## 所有在模板today和hello所确定的范围内的行都被打印。都找第一个，也就是说，从第一个today到第一个hellosed -n &apos;5,/^hello/p&apos; sed.txtsed -n &apos;/^hello/,8p&apos; sed.txt## 打印从第五行开始到第一个包含以hello开始的行之间的所有行。sed &apos;/today/,/hello/s/$/www/&apos; sed.txt## 对于模板today和hello之间的行，每行的末尾用字符串www替换。sed &apos;/today/,/hello/s/^/www/&apos; sed.txt## 对于模板today和hello之间的行，每行的开头用字符串www替换。sed &apos;/^[A-Za-z]/s/5/five/g&apos; sed.txt## 将以字母开头的行中的数字5替换成five4、多点编辑：e命令sed -e &apos;1,5d&apos; -e &apos;s/hello/hi/&apos; sed.txt## (-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用hello替换hi。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。sed --expression=&apos;s/hello/hi/&apos; --expression=&apos;/today/d&apos; sed.txt## 一个比-e更好的命令是--expression。它能给sed表达式赋值。5、从文件读入：r命令sed &apos;/hello/r file&apos; sed.txt## file里的内容被读进来，显示在与hello匹配的行下面，如果匹配多行，则file的内容将显示在所有匹配行的下面。6、写入文件：w命令sed -n &apos;/hello/w file&apos; sed.txt## 在huangbo.txt中所有包含hello的行都被写入file里。7、追加命令：a命令sed &apos;/^hello/a\\---&gt;this is a example&apos; sed.txt ## &apos;---&gt;this is a example&apos;被追加到以hello开头的行(另起一行)后面，sed要求命令a后面有一个反斜杠。8、插入：i命令sed &apos;/will/i\\some thing new -------------------------&apos; sed.txt## 如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。9、下一个：n命令sed &apos;/hello/&#123;n; s/aa/bb/;&#125;&apos; sed.txt 替换下一行的第一个aased &apos;/hello/&#123;n; s/aa/bb/g;&#125;&apos; sed.txt 替换下一行的全部aa## 如果hello被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。10、退出：q命令sed &apos;10q&apos; sed.txt## 打印完第10行后，退出sed。同样的写法：sed -n &apos;1,10p &apos; sed.txt awk（报表生成器）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113Awk是一个强大的处理文本的编程语言工具，其名称得自于它的创始人Alfred Aho、Peter Weinberger和Brian Kernighan 姓氏的首个字母，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。简单来说awk就是扫描文件中的每一行，查找与命令行中所给定内容相匹配的模式。如果发现匹配内容，则进行下一个编程步骤。如果找不到匹配内容，则继续处理下一行。1、假设last -n 5的输出如下:[root@localhost ~]# last -n 5root pts/0 192.168.123.1 Wed Dec 28 01:55 still logged in reboot system boot 2.6.32-573.el6.x Tue Dec 27 04:25 - 03:11 (22:46) root pts/1 192.168.123.1 Tue Dec 27 02:00 - 02:00 (00:00) root pts/1 192.168.123.1 Tue Dec 27 01:59 - 02:00 (00:00) root pts/0 192.168.123.1 Tue Dec 27 01:59 - down (00:16)2、只显示五个最近登录的账号：[root@localhost ~]# last -n 5 | awk &apos;&#123;print $1&#125;&apos;rootrebootrootrootrootawk工作流程是这样的：读入有&apos;\n&apos;换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&quot;空白键&quot; 或 &quot;[tab]键&quot;,所以$1表示登录用户，$3表示登录用户ip,以此类推3、显示/etc/passwd的账户：[root@localhost ~]# cat /etc/passwd |awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos;rootbindaemonadmlp这种是awk+action的示例，每行都会执行action&#123;print $1&#125;。-F指定域分隔符为&apos;:&apos;4、显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割[root@localhost ~]# cat /etc/passwd |awk -F &apos;:&apos; &apos;&#123;print $1&quot;\t&quot;$7&#125;&apos;root /bin/bashbin /sbin/nologindaemon /sbin/nologinadm /sbin/nologinlp /sbin/nologin5、BEGIN and END如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以逗号分割,而且在所有行添加列名name,shell,在最后一行添加&quot;blue,/bin/nosh&quot;。cat /etc/passwd |awk -F &apos;:&apos; &apos;BEGIN &#123;print &quot;name,shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&apos;cat /etc/passwd | awk -F &apos;:&apos; &apos;BEGIN &#123;print &quot;name \t shell&quot;&#125; &#123;print$1&quot;\t&quot;$7&#125; END &#123;print &quot;blue,/bin/bash&quot;&#125;&apos;name,shellroot,/bin/bashdaemon,/bin/sh....blue,/bin/nosh awk工作流程是这样的：先执行BEGIN，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录••••••直到所有的记录都读完，最后执行END操作。6、搜索/etc/passwd有root关键字的所有行awk -F: &apos;/root/&apos; /etc/passwdroot:x:0:0:root:/root:/bin/bash这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。搜索支持正则，例如找root开头的: awk -F: &apos;/^root/&apos; /etc/passwd搜索/etc/passwd有root关键字的所有行，并显示对应的shellawk -F &apos;:&apos; &apos;/root/&#123;print $7&#125;&apos; /etc/passwd /bin/bash这里指定了action&#123;print $7&#125;6、awk常见内置变量FILENAME：awk浏览的文件名FNR：浏览文件的记录数，也就是行数。awk是以行为单位处理的，所以每行就是一个记录NR：awk读取文件每行内容时的行号NF：浏览记录的域的个数(列数)。可以用它来输出最后一个域FS：设置输入域分隔符，等价于命令行-F选项OFS：输出域分隔符统计/etc/passwd:文件名，每行的行号，每行的列数，对应的完整行内容awk -F &apos;:&apos; &apos;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,columns:&quot; NF &quot;,linecontent:&quot;$0&#125;&apos; /etc/passwdawk -F&apos;:&apos; &apos;&#123;print &quot;filename:&quot; FILENAME &quot;,linenumber:&quot; NR &quot;,colums:&quot; NF &quot;linecotent:&quot; $0&#125;&apos; /etc/passwdfilename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/shfilename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh使用printf替代print,可以让代码更加简洁，易读 awk -F &apos;:&apos; &apos;&#123;printf(&quot;filename:%s,linenumber:%s,columns:%s,linecontent:%s\n&quot;,FILENAME,NR,NF,$0)&#125;&apos; /etc/passwd指定输入分隔符，指定输出分隔符：awk &apos;BEGIN &#123;FS=&quot;:&quot;; OFS=&quot;\t&quot;&#125; &#123;print $1, $2&#125;&apos; /etc/passwdsshd xtcpdump xlinux x8、实用例子A：打印最后一列：awk -F: &apos;&#123;print $NF&#125;&apos; /etc/passwdawk -F: &apos;&#123;printf(&quot;%s\n&quot;,$NF);&#125;&apos; /etc/passwdB：统计文件行数：awk &apos;BEGIN &#123;x=0&#125; &#123;x++&#125; END &#123;print x&#125;&apos; /etc/passwdC：打印9*9乘法表：awk &apos;BEGIN&#123;for(n=0;n++&lt;9;)&#123;for(i=0;i++&lt;n;)printf i&quot;*&quot;n&quot;=&quot;i*n&quot; &quot;;print &quot;&quot;&#125;&#125;&apos;awk &apos;BEGIN &#123;for(i=1;i&lt;=9;i++)&#123;for(j=1;j&lt;=i;j++)&#123;printf i&quot;*&quot;j&quot;=&quot;i*j&quot; &quot;;&#125;print &quot;&quot;&#125;&#125;&apos;awk &apos;BEGIN &#123;for(i=9;i&gt;=1;i--)&#123;for(j=i;j&gt;=1;j--)&#123;printf i&quot;*&quot;j&quot;=&quot;i*j&quot; &quot;;&#125;print &quot;&quot;&#125;&#125;&apos;awk &apos; BEGIN &#123; for(i=1;i&lt;=9;i++) &#123; for(j=1;j&lt;=i;j++) printf j&quot;\*&quot;i&quot;=&quot;i*j&quot; &quot;; print &quot;&quot;; &#125; &#125; &apos;D：计算1-100之和：echo &quot;sum&quot; | awk &apos;BEGIN &#123;sum=0;&#125; &#123;i=0;while(i&lt;101)&#123;sum+=i;i++&#125;&#125; END &#123;print sum&#125;&apos; 9、更多详细用法参见官网：http://www.gnu.org/software/gawk/manual/gawk.html find搜索文件目录层次结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667格式： find path -option actionsfind &lt;路径&gt; &lt;选项&gt; [表达式]常用可选项：-name 根据文件名查找，支持(&apos;* &apos; , &apos;? &apos;)-type 根据文件类型查找(f-普通文件，c-字符设备文件，b-块设备文件，l-链接文件，d-目录)-perm 根据文件的权限查找，比如 755-user 根据文件拥有者查找-group 根据文件所属组寻找文件-size 根据文件小大寻找文件-o 表达式 或-a 表达式 与-not 表达式 非示例：[linux@linux txt]$ ll ## 准备的测试文件total 248-rw-rw-r--. 1 linux linux 235373 Apr 18 00:10 hw.txt-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 LINUX.pdf-rw-rw-r--. 1 linux linux 3 Apr 22 05:50 liujialing.jpg-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 mingxing.pdf-rw-rw-r--. 1 linux linux 57 Apr 22 04:40 mingxing.txt-rw-rw-r--. 1 linux linux 66 Apr 22 05:15 sort.txt-rw-rw-r--. 1 linux linux 214 Apr 18 10:08 test.txt-rw-rw-r--. 1 linux linux 24 Apr 22 05:27 uniq.txt[linux@linux txt]$ find /home/linux/txt/ -name &quot;*.txt&quot; ## 查找文件名txt结尾的文件/home/linux/txt/uniq.txt/home/linux/txt/mingxing.txt/home/linux/txt/test.txt/home/linux/txt/hw.txt/home/linux/txt/sort.txt## 忽略大小写查找文件名包含linux[linux@linux txt]$ find /home/linux/txt -iname &quot;*linux*&quot; /home/linux/txt/LINUX.pdf## 查找文件名结尾是.txt或者.jpg的文件[linux@linux txt]$ find /home/linux/txt/ \( -name &quot;*.txt&quot; -o -name &quot;*.jpg&quot; \) /home/linux/txt/liujialing.jpg/home/linux/txt/uniq.txt/home/linux/txt/mingxing.txt/home/linux/txt/test.txt/home/linux/txt/hw.txt/home/linux/txt/sort.txt另一种写法：find /home/linux/txt/ -name &quot;*.txt&quot; -o -name &quot;*.jpg&quot;使用正则表达式的方式去查找上面条件的文件：[linux@linux txt]$ find /home/linux/txt/ -regex &quot;.*\(\.txt\|\.jpg\)$&quot;/home/linux/txt/liujialing.jpg/home/linux/txt/uniq.txt/home/linux/txt/mingxing.txt/home/linux/txt/test.txt/home/linux/txt/hw.txt/home/linux/txt/sort.txt## 查找.jpg结尾的文件，然后删掉[linux@linux txt]$ find /home/linux/txt -type f -name &quot;*.jpg&quot; -delete[linux@linux txt]$ lltotal 248-rw-rw-r--. 1 linux linux 235373 Apr 18 00:10 hw.txt-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 LINUX.pdf-rw-rw-r--. 1 linux linux 0 Apr 22 05:43 mingxing.pdf-rw-rw-r--. 1 linux linux 57 Apr 22 04:40 mingxing.txt-rw-rw-r--. 1 linux linux 66 Apr 22 05:15 sort.txt-rw-rw-r--. 1 linux linux 214 Apr 18 10:08 test.txt-rw-rw-r--. 1 linux linux 24 Apr 22 05:27 uniq.txt Shell操作字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651663.1、字符串截取Linux中操作字符串，也是一项必备的技能。其中尤以截取字符串更加频繁，下面为大家介绍几种常用方式，截取字符串1、#截取，删除左边字符串（包括制定的分隔符），保留右边字符串预先定义一个变量：WEBSITE=&apos;http://hadoop//centos/huangbo.html&apos;[root@hadoop ~]# echo $&#123;WEBSITE#*//&#125;结果：hadoop//centos/huangbo.html2、##截取，删除左边字符串（包括指定的分隔符），保留右边字符串，和上边一个#不同的是，它一直找到最后，而不是像一个#那样找到一个就满足条件退出了。[root@hadoop ~]# echo $&#123;WEBSITE##*//&#125;结果：centos/huangbo.html3、%截取，删除右边字符串（包括制定的分隔符），保留左边字符串[root@hadoop ~]# echo $&#123;WEBSITE%//*&#125;结果：http://hadoop4、%%截取，删除右边字符串（包括指定的分隔符），保留左边字符串，和上边一个%不同的是，它一直找到最前，而不是像一个%那样找到一个就满足条件退出了。[root@hadoop ~]# echo $&#123;WEBSITE%%//*&#125;结果：http:总结以上四种方式：# 去掉左边，最短匹配模式， ##最长匹配模式。% 去掉右边，最短匹配模式， %%最长匹配模式5、从左边第几个字符开始，以及截取的字符的个数[root@hadoop ~]# echo $&#123;WEBSITE:2:2&#125;结果：tp6、从左边第几个字符开始，一直到结束[root@hadoop ~]# echo $&#123;WEBSITE:2&#125; 结果：tp://hadoop//centos//huangbo.html7、从右边第几个字符开始，以及字符的个数[root@hadoop ~]# echo $&#123;WEBSITE:0-4:2&#125;结果：ht8、从右边第几个字符开始，一直到结束[root@hadoop ~]# echo $&#123;WEBSITE:0-4&#125;结果：html9、利用awk进行字符串截取[root@hadoop ~]# echo $WEBSITE | awk &apos;&#123;print substr($1,2,6)&#125;&apos; 结果：ttp://10、利用cut进行字符串截取[root@hadoop ~]# echo $WEBSITE | cut -b 1-4http[root@hadoop ~]# echo $WEBSITE | cut -c 1-4http[root@hadoop ~]# echo $WEBSITE | cut -b 1,4hp[root@hadoop ~]# echo $WEBSITE | cut -c 1,4hp11、获取最后几个字符[root@hadoop ~]# echo $&#123;WEBSITE:(-3)&#125;结果：tml12、截取从倒数第3个字符后的2个字符[root@hadoop ~]# echo $&#123;WEBSITE:(-3):2&#125;结果：tm3.2、字符串替换使用格式：$&#123;parameter/pattern/string&#125;例子：定义变量VAR：[linux@linux ~]$ VAR=&quot;hello tom, hello kitty, hello xiaoming&quot;替换第一个hello：[linux@linux ~]$ echo $&#123;VAR/hello/hi&#125;hi tom, hello kitty, hello xiaoming替换所有hello：[linux@linux ~]$ echo $&#123;VAR//hello/hi&#125;hi tom, hi kitty, hi xiaoming3.3、获取字符串长度在此为大家提供五种方式获取某字符串的长度1、使用wc -L命令[root@hadoop ~]# echo $&#123;WEBSITE&#125; |wc -L352、使用expr的方式去计算[root@hadoop ~]# expr length $&#123;WEBSITE&#125;353、通过awk + length的方式获取字符串长度[root@hadoop ~]# echo $&#123;WEBSITE&#125; | awk &apos;&#123;print length($0)&#125;&apos; 354、通过awk的方式计算以&quot;&quot;分隔的字段个数[root@hadoop ~]# echo $&#123;WEBSITE&#125; |awk -F &quot;&quot; &apos;&#123;print NF&#125;&apos; 355、通过#的方式获取字符串（最简单，最常用）[root@hadoop ~]# echo $&#123;#WEBSITE&#125;354、Shell脚本自动安装MySQL安装mysql脚本：#!/bin/bash## auto install mysql## 假如是第二次装，那么要先停掉服务，并且卸载之前的mysqlservice mysql stopEXISTS_RPMS=`rpm -qa | grep -i mysql`echo $&#123;EXISTS_RPMS&#125;for RPM in $&#123;EXISTS_RPMS&#125;do rpm -e --nodeps $&#123;RPM&#125;done## 删除残留文件rm -fr /usr/lib/mysqlrm -fr /usr/include/mysqlrm -f /etc/my.cnfrm -fr /var/lib/mysql## 从服务器获取安装mysql的rpm包wget http://linux/soft/MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpmwget http://linux/soft/MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm## 删除之前的密码文件，以免产生干扰rm -rf /root/.mysql_secret## 安装服务器rpm -ivh MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm## 获取到生成的随机密码##PSWD=`cat /root/.mysql_secret | awk -F &apos;:&apos; &apos;&#123;print substr($4,2,16)&#125;&apos;`PSWD=` grep -v &apos;^$&apos; /root/.mysql_secret | awk -F &apos;:&apos; &apos;&#123;print substr($4,2,16)&#125;&apos;`##PSWD=$&#123;PWD:1:16&#125;## 安装客户端rpm -ivh MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm## 然后删除刚刚下下来的rpm包rm -rf MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpmrm -rf MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm## 提示安装的步骤都完成了。echo &quot;install mysql server and client is done .!!!!!!&quot;## 打印出来刚刚生成的mysql初始密码echo &quot;random password is:$&#123;PSWD&#125;&quot;## 开启mysql服务service mysql start手动第一次登陆，然后改掉密码[root@hadoop bin]# mysql -uroot -pZjVIWvOGD18bT7oXmysql&gt; set PASSWORD=PASSWORD(&apos;root&apos;);现在就可以写脚本链接mysql进行操作了[root@hadoop bin]# vi initMysql.sh#!/bin/bashmysql -uroot -proot &lt;&lt; EOF GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION; FLUSH PRIVILEGES; use mysql; select host, user, password from user;EOF]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux--shell]]></title>
    <url>%2Fblog%2F2018%2F09%2F18%2FLinuxday04%2F</url>
    <content type="text"><![CDATA[初识shell什么是shell shell程序:接口,提供了用户和内核交互桥梁。 shell语言: 命令语言,编程语言。解释性语言(编译型语言) 。shell脚本。 shell解释器: sh(unix默认) bash(linux默认) shell基本格式1234#!/bin/bash #设置默认的shell解释器,如果指定使用某个解释器执行，则此行不生效echo aa# echo bb shell脚本执行指定解释器执行sh 脚本名称 bash 脚本名称 内部命令source或 . 脚本名称 功能： .:使Shell读入指定的Shell程序文件并依次执行文件中的所有语句(脚本调用另外脚本) source:用于重新执行刚修改的初始化文件,使之立即生效,而不必注销并重新登录 通过路径执行(有执行的权限) 修改权限 chmod 755 a.sh ./a.sh: 当前路径下的a.sh(相对路径) 绝对路径: /root/a.sh(/root目录下的a.sh) shell注释 单行注释:shell中以#号开头的代码就是注释 多行注释::&lt;&lt;! 多行注释 ! shell基本语法变量 系统的内置变量: 查看 :set ;取出:echo $USER,echo $PATH 自定义变量 变量名=值: 规范: =号附近不能用空格 变量名推荐使用大写字母 变量的值有空格的时候(字符串) 单引号: 内部不能取值,(会脱意) 双引号: 内部可以取值 12345678A='this is zs'echo $A # this is zsB="this is ls"echo $B # this is ls----------------------------C=wwecho "this is $C" # this is wwecho 'this is $C' # this is $C 获取变量值可以使用${变量名} 只读变量:readonly 变量名 = 变量值(不可删除和修改) 删除变量 :unset 变量名 案例1234567891011121314151617181920212223a.sh#!/bin/bashA="A in a.sh"echo $A/root/b.sh # 创建子进程读取b.sh. /root/b.sh # 使用内部命令执行,b.sh内容读到付进程echo $Bb.sh#!/bin/bashB="B in b.sh"echo $Becho $A调用a.shA in a.shB in b.shA in a.shB in b.sh调用b.shB in b.sh 总结: 1. a.sh 直接调用b.sh ,会让b.sh 在a.sh 所在的子空间中执行 2. 子进程空间只能访问父进程中用export定义的变量 3. 一个shell进程无法将自己定义的变量提升到父进程空间中去 4. source 或 “.”执行脚本的时候会让脚本在调用者所在的shell进程的空间中执行 反引号赋值 先将反引号内的结果运算完毕，然后赋值,也可以说$() 将当前的系统时间赋值给B B=`date` B=`$(date)` echo $B 输出家目录下的文件:B=`ll ~/` echo -e “$B” 变量的有用技巧 ${var:-aa}:没有值时输出aa ${var:+aa}:有值是输出aa ${var:=aa}:没有值时赋值为aa ${var:?aa}:检测变量是否有值,var为空或者被删除(unset),message会送到标准输出, 出现在shell脚本中,脚本会停止运行 特殊变量 脚本执行的时候可以传递参数,参数用空格隔开,尽量使用${} $?:上一次命令执行的状态码(正确 0 否则返回正数),还可以接收返回值 $$:查看进程编号 $0:查看脚本名称 $n:查看脚本参数 $#:参数个数 $*:所有的参数 $@: 所有的参数 1234567891011#!/bin/bashecho $?echo $$echo $0echo $1echo $2echo $#echo $*echo $@bash c.sh cs1 cs2 $*,$@的区别 echo的每一句输出默认会换行 $* 和 $@ 都表示传递给函数或脚本的所有参数 没有双引号” “: 二者都以$1 $2 ... $n的形式组成参数列表 有引号的时候: ​ $*将所有的参数作为一个整体 ,以&quot;$1 $2 ... $n&quot;的形式组成一个整串 ​ $@将所有的参数分开,以&quot;$1&quot; &quot;$2&quot; ... &quot;$n&quot;的形式组成一个参数列表 1234567891011121314151617181920212223242526272829303132333435363738#!/bin/bashfor A in $*do echo $Adoneecho "======================"for A in $@do echo $Adoneecho "======================"for A in "$*"do echo $Adoneecho "======================"for A in "$@"do echo $Adoneecho "======================"运行:sh a.sh aa bb ccaabbcc======================aabbcc======================aa bb cc======================aabbcc====================== 运算符算术运算符:expr 运算:二边要加空格,只能计算整数 +:加 A=`expr 2 + 3` #5 -:减 \*:乘号需要转义 A=`expr 2 * 3` # 6 /:没有小数点 A=`expr 3 / 2` ()—&gt; `expr \( 2 + 3 \) * 4`:可以不写$符号 123456789101112A=`expr \( 2 + 3 \) \* 4` echo $AA=$((2+3)): 不用管空格A=$[2+3]: 不用管空格let A=2: let D=A+C :省略$,不可以使用空格let D=A++ ()—&gt; $((A+B)):可以不写$符号 ()—&gt; $[A+B]: ()—&gt; let C=A+B: bc命令:计算小数12345678910echo &quot;2.3+3.5&quot; #2.3+3.5echo &quot;2.3+3.5&quot; | bc #5.8浮点数运算: echo &quot;2.3+3.5&quot; | bc比较运算: echo &quot;1&lt;2&quot; | bc (true 为1 ,false 为0)设置小数点位数: echo &quot;scale=2;10/3&quot; | bc (3.33 保留二位小数)设置进制: echo &quot;ibase=2;111&quot; | bc (将二进制111转为10进制 7)进制转换: echo &quot;ibase=10;obase=8;10&quot; | bc (将10进制的10转为8进制 12)高级运算: echo &quot;3^3&quot; | bc (计算3的3次幂) echo &quot;sqrt(4)&quot; | bc (4的开方) 三元运算符 [ condition ] &amp;&amp; 真 || 假 [ ]两侧必须有空格 12[root@hdp01 ~]# [ $(echo &quot;3&gt;2&quot; | bc) -gt 1 ] &amp;&amp; echo yes || echo no no 关系运算符 运算符 等同运算符 说明 -eq = 检测二个数相等 ,相等返回true -nq != 检测二个数不相等,不相等返回true -ge >= 检测左边大于等于右边,是true -gt &gt; 检测左边大于右边,是true -le &lt;= 检测左边小于等于右边,是true -lt &lt; 检测左边小于右边,是true 布尔云算法 运算符 等同运算符 说明 -a &amp;&amp; 与运算,二者为true,返回true -o \ \ 或运算 ! ! 字符串运算符 运算符 说明 = 检测二个字符串是否相等,相等返回true != 检测二个字符串是否相等,不相等返回true -z 检测字符串长度是否为0 , 为0返回true -n 检测字符串长度是否为0, 不为0 返回true str 检测字符 串是否为空,不为空返回true 文件运算符 运算符 说明 -d 检测是否是目录,是true -f 检测是否为普通文件,不是目录和设备文件,是true -e 检测是否存在,是true -s 检测文件是否为空,(文件大小是否大于0),不为空true -r 是否可读,是true -w 是否可写,是true -x 是否可执行,是true -b 是否为块设备文件,是true -c 是否是字符设备文件 流程控制语句if read -p 相当于Scanner,读取控制台的数据 if [ condition ]是一句 the 语句1是一句 ;和回车相当于是结束符 12345678910if [condition]; then 语句1;elif[ condition ]; then 语句2; ...else 语句3;fi 12345678#!/bin/bashread -p "请输入成绩:" SCOREif [ $SCORE -gt 80 ] then echo "优秀"elif [ $SCORE -gt 60 ] then echo "良好" else echo "一般般"fi case12345678910case $1 in值1) 语句1; ;;值2) 语句二; ;;*) 语句三esac 12345678910111213141516171819202122#!/bin/bashread -p "请输入成绩:" SCORESCORE=`expr $SCORE / 10 `case $SCORE in 10) echo "优秀" ;;9) echo "优秀" ;;8) echo "优秀" ;;7) echo "良好" ;;6) echo "一般" ;;*) echo "不及格"esac while12345678910111213141516171819202122232425262728293031while [expression]/((expression))do command ...done#--------------------i=1while((i&lt;=3))do echo $i let i++done#--------------------#!/bin/bashi=1while [ $i -le 3 ]do echo $i let i++ i=$((i+1))done--result:----------12 3 12345678910111213141516171819202122#!/bin/bashi=1result=0while ((i&lt;=100))do let result=result+i let i++doneecho $result------------------------#!/bin/bashi=1result=0while [ $i -le 100 ]do let result=result+i let i++doneecho $result for 列表是一组值(数字,字符串)组成的序列,每个值通过空格分隔,每循环一次,就将列表中的下一个值赋给变量 第一种: 12345678for 变量 in 列表do command ......donefor N in 1 2 3;do echo $N ;done 第二种: 1for N in &#123;1..3&#125;;do echo $N ; done 第三种 1for((i=0;i&lt;=2;i++));do echo &quot;welcome $i times&quot;; done 例子 12345678//求一百的和#!/bin/bashresult=0for((i=1;i&lt;=100;i++))do let result=result+idoneecho $result until expression 一般为条件表达式,如果返回false 则继续执行循环体,否则跳出循环 为true是跳出循环,和while相反 12345until expression((条件))/[]do command ......done 123456789#!/bin/bashi=1;sum=0;until ((i&gt;100))dolet sum=sum+i let i++doneecho $sum 九九乘法表12345678910#!/bin/bashfor((i=1;i&lt;=9;i++)) do for((j=1;j&lt;=i;j++)) do echo -ne "$j * $i = `expr $i \* $j`\t" # echo -ne "$j*$i=$[i*j]\t" done echo done 数组 使用小括号 ,数组内的元素用空格隔开 1234567891011121314151617181920211. 数组的声明 arr=(aa bb cc)2.获取某一个元素 echo $&#123;arr[0]&#125;3.添加元素 arr[3]=dd4.输出全部 echo $&#123;arr[*]&#125; echo $&#123;arr[@]&#125;5.获取数组的长度 echo $&#123;#arr[*]&#125;6.获取数组的下标 echo $&#123;!arr[*]&#125;7. 数组的连接(+=),下标接之间的最大值开始算 arr+=(dd ee ff) echo $&#123;arr[*]&#125; #aa bb cc dd ee ff8.删除数组 删除数组元素,会保留数组对应位置的下标unset $&#123;arr[index]&#125; unset arr[0]9.数组的分片 $&#123;arr[@]:number1:number2&#125; 起始位置,取多少 12345678910arr=(aa bb cc)arr[10]=5echo $&#123;arr[*]&#125;# aa bb cc 5echo $&#123;#arr[*]&#125;# 4echo $&#123;!arr[*]&#125;# 0 1 2 10没有给值得位置没有值 数组的遍历 数组可能不是连续的,不能使用for(;;)的形式遍历 1234561. for元素循环遍历for a in $&#123;arr[*]&#125;;do echo $a ;done2. 遍历下标for a in $&#123;!arr[*]&#125;;do echo $&#123;arr[$a]&#125; ;donefor a in $&#123;!arr[*]&#125;;do echo $&#123;arr[a]&#125; ;done 函数 一段代码块 声明: 函数名(){command…} 调用:函数名 1234567891011-- fun.sh#!/bin/bashhello()&#123; echo "aa"&#125;# 调用函数hello----------------sh fun.sh 带参数和返回值12345678910111213141516171819-- fun.sh#!/bin/bashhello()&#123; echo $1 echo $2&#125;# 调用函数hello aa bb# 接收返回值echo $?--------------------------------aabb10 跨脚本调用函数123456789101112131415--base.sh#!/bin/bashtest()&#123; echo "hello"&#125;--other.sh#!/bin/bash./root/base.sh ## 引入脚本test ## 调用引入脚本当中的test函数-----[root@hdp01 ~]# sh other.sh hello 集群自动安装软件12345678910集群自动安装jdk1.软件一致: httpd / yum2.集群自动安装: 2.1 一台机器自动安装(写脚本 autoInstall.sh) 2.2 批量发送自动安装的脚本,自动执行脚本(send.sh) 准备: 1.传输文件到http服务器 2.编写自动下载安装的脚本 12345678910111213141516--autoInstall.sh#!/bin/bash#下载jdkwget http://192.168.2.101/jdk/jdk8.tar.gz#解压jdktar -zxvf jdk8.tar.gz -C /opt/#配置环境变量cat &gt;&gt; /etc/profile &lt;&lt; EOFexport JAVA_HOME=/opt/jdk8export PATH=$PATH:$JAVA_HOME/bin/EOF# 执行/etc/profilesource /etc/profile# 测试java -version]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linuxday03]]></title>
    <url>%2Fblog%2F2018%2F09%2F15%2FLinuxday03%2F</url>
    <content type="text"><![CDATA[Linux下的软件安装 jdk mysql 进程管理 httpd apache http服务器 默认端口80 service –status-all|grep httpd service httpd status: 查看httpd服务 yum install -y httpd : 下载 service httpd start/stop http服务的启动与关闭 /var/www/html : 资源文件的根目录 /etc/httpd/:配置文件 关闭防护墙 开启httpd 设置ip映射 您现在可以将内容添加到根目录/ var / www / html / 挂载 将设备文件连接到一个已经存在的目录 挂载源:设备文件 挂载点: 存在的目录 临时挂载:mount -t iso9660 -o ro/loop 挂载源 挂载点 永久挂载:vim /etc/fstab 卸载: umount 挂载点 将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载。把该子目录称为挂载点。 注意： ​ 1、挂载点必须是一个目录。 ​ 2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。 ​ 3、mount命令没有建立挂载点的功能，因此你应该确保执行mount命令时，挂载点已经存在。（不懂？说白了点就是你要把文件系统挂载到哪，首先要先建上个目录。） 格式：mount [-参数][设备名称][挂载点] -t&lt;文件系统类型&gt; 指定设备的文件系统类型，常见的有： ​ minix linux最早使用的文件系统 ​ ext2 linux目前常用的文件系统 ​ msdos MS-DOS的fat，就是fat16 ​ vfat windows98常用的fat32 ​ nfs 网络文件系统 ​ iso9660 CD-ROM光盘标准文件系统 ​ ntfs windows NT 2000的文件系统 ​ hpfs OS/2文件系统 ​ auto 自动检测文件系统 -o&lt;选项&gt; 指定挂载文件系统时的选项。有些也可用在/etc/fstab中。常用的有 codepage=XXX 代码页 ​ iocharset=XXX 字符集 ​ codepage指定文件系统的代码页，简体中文中文代码是936；iocharset指定字符集，简体中文一般用cp936或gb2312。 ​ ro 以只读方式挂载 ​ rw 以读写方式挂载 ​ nouser 使一般用户无法挂载 ​ user 可以让一般用户挂载设备 mount -t iso9660 /dev/cdrom /mnt/cdrom 自动挂载 在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。 第一列：/dev/cdrom：挂载源，要挂在的磁盘分区或者存储设备，或者文件系统 第二列：/mnt/cdrom：挂载点，挂载位置 第三列：iso9660：文件系统类型，ext4文件系统，swap表示交换分区，…… 第四列：defaults：挂载参数 第五列：0：表示dump选项，dump工具通过这个选项位置上的数字来决定文件系统是否需要备份。如果是0，dump就会被忽略，事实上大多数的dump设置都是0 第六列：0：读取文件系统时候的检查顺序，允许的数字是0,1,2，根目录应当获得最高的优先权 1, 其它所有需要被检查的设备设置为2，0表示不检查 查看时间和时区 date -R 简写 : date date ‘+%Y-%m-%d %H:%M:%S’ 时区 查看时区:cat /etc/sysconfig/clock CentOS中时区是以文件形式存在，当前正在使用的时区文件位于/etc/localtime,其他时区文件则位于/usr/share/zoneinfo,其中中国时区使用/usr/share/zoneinfo/Asia/Shanghai PS：如果没有Asia/Shanghai时区文件，请使用tzselect命令去生成时区文件，生成好的时区文件就在/usr/share/zoneinfo目录下 修改时区,用时区文件覆盖/etc/localtime cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 时间 我们一般使用”date -s”命令来修改系统时间 123[root@hadoop01 ~]# date -s 12/25/2016[root@hadoop01 ~]# date -s 19:57:30[root@hadoop01 ~]# date -s “2016-12-25 19:57:30” 同步网络时间 12345[root@hadoop01 ~]# ntpdate time.nist.gov[root@hadoop01 ~]# ntpdate 202.120.2.101上海交通大学网络中心NTP服务器地址：202.120.2.101（ntp.sjtu.edu.cn）中国国家授时中心服务器地址：cn.pool.ntp.org若以上提供的网络时间服务器不可用，请自行上网寻找可用的网络时间服务器 一劳永逸 1234567891、使用命令：crontab -e:编辑当前用户的计划任务[root@hadoop01 ~]# crontab -ecrontab的使用后面会有详细讲解2、然后往里加入一行内容*/10 * * * * ntpdate cn.pool.ntp.org上面的配置表示，每隔十分钟从202.120.2.101该时间服务器同步一次时间。保存退出即可 软件安装二进制发布包 软件已经针对具体平台编译打包发布，只要解压，修改配置即可 RPM发布包软件已经按照RedHat（Redhat Package Manager）的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用rpm命令进行安装(如:mysql) 123456789101112131415161718191、安装：rpm -ivh 包名参数：-i ：安装的意思-v ：可视化-h ：显示安装进度另外在安装一个rpm包时常用的附带参数有：--force 强制安装，即使覆盖属于其他包的文件也要安装--nodeps 当要安装的rpm包依赖其他包时，即使其他包没有安装，也要安装这个包2、升级包：rpm -Uvh filename-U 升级3、卸载包rpm -e filename (--nodpes)（这里的filename是通过rpm的查询功能所查询到的）4、查询一个包是否安装：rpm -q 包名（这里的包名，是不带有平台信息以及后缀名的）5.查询当前安装的所有rpm包：rpm -qa查询当前安装的和sql相关的包：rpm -qa | grep &apos;sql&apos;查询sqlite安装路径：rpm -ql sqlite Yum在线安装Yum（Yellow dog Updater, Modified）是一个在CentOS和RedHat以及SUSE中的Shell前端软件包管理器。比如软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上存在的rpm软件，并且会自动解决软件安装过程中的库依赖问题（注：类似于maven），yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记 yum仓库服务器本质上就是一台http服务器，服务器的目录中放置了rpm包，及rpm包的索引信息文件，即可为yum客户端提供rpm文件下载 安装示例： yum install nc yum命令工具使用举例 yum update 升级系统 yum install ~ 安装指定软件包 yum update ~ 升级指定软件包 yum remove ~ 卸载指定软件 源码编译安装软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署 安装示例：资料-Redis的安装 安装JDK linux获取sjdk的发布包,上传sftp scrt:alt+p,默认为当前用户的家目录 解压:/usr/loc | /opt 配置: 查询:rpm -qa | grep java 卸载:rpm -e 程序 error: Failed dependencies: 1rpm -e java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.x86_64 --nodeps 配置: vim /etc/profile export JAVA_HOME=/usr/local/jdk1.8.0_73export PATH=$PATH:$JAVA_HOME/bin 执行配置文件 source /etc/profile 安装Mysql 下载上传 查询安装 rpm -qa | grep -i mysql 卸载已安装 rpm -e 程序名 安装服务器端 rpm -ivh MySQL-server-5.6.26-1.linux_glibc2.5.x86_64.rpm 安装客户端 rpm -ivh MySQL-client-5.6.26-1.linux_glibc2.5.x86_64.rpm 启动服务 service mysql start netstat -nltp 查看网络接口 登录 获取初始密码 cat /root/.mysql_secret 设置密码 set PASSWORD=PASSWORD(‘root’); 退出登陆验证，看是否改密码成功 增加远程登录权限 GRANT ALL PRIVILEGES ON . TO ‘root‘@’%’ IDENTIFIED BY ‘root’ WITH GRANT OPTION; FLUSH PRIVILEGES; grant 权限 1,权限 2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by ‘连接口令’;PS：1,权限 2,…权限 n 代表 select，insert，update，delete，create，drop，index，alter，grant,references，reload，shutdown，process，file 等 14 个权限当权限 1,权限 2,…权限 n 被 all privileges 或者 all 代替，表示赋予用户全部权限。当数据库名称.表名称被.代替，表示赋予用户操作服务器上所有数据库所有表的权限。用户地址可以是 localhost，也可以是 ip 地址、机器名字、域名。也可以用’%’地址连接. mysql配置文件 /use/my.cnf复制到/etc/my.cnf 配置本地yum 源 /etc/yum.repos.d/ :配置yum源 查看可用的yum源: yum repolist 准备一个http服务器 在httpd服务的web目录中放入rpm库， 12345678比如，将centos安装光盘中的rpm库放入：mkdir /var/www/html/centoscp -r /mnt/cdrom/ /var/www/html/centos/注：上面这种方式比较浪费空间，可以不用拷贝，其实只要创建一个软连接即可ln -s /mnt/cdrom /var/www/html/centos 用浏览器访问一下httpd服务，看看是不是能看到这些东西 地址：http://192.168.123.202/centos 配置yum客户端repo地址文件 将本地http服务器加入repo地址 12345678910111213141516 首先，将内置的源全部disable掉 cd /etc/yum.repos.d/ rename .repo .repo.bak * 然后，新建一个repo源：开始--&gt;vi CentOS-Local.repo [CentOS-Local] name=CentOS-Local baseurl=http://192.168.123.202/centos/cdrom0 http://192.168.123.202/centos/cdrom1 gpgcheck=0 enabled=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 接下来，我们检查我们自定义的源是否生效，使用命令：yum repolist 再接下来，就可以使用yum像从公网安装软件一样在内网服务器上下载软件进行安装了 yum install -y 你要的软件 12345678910111213在安装完CentOS后一般需要修改yum源，才能够在安装更新rpm包时获得比较理想的速度。国内比较快的有163源、sohu源。这里以163源为例子。1. cd /etc/yum.repos.d2. mv CentOS-Base.repo CentOS-Base.repo.backup3. wget http://mirrors.163.com/.help/CentOS6-Base-163.repo4. mv CentOS6-Base-163.repo CentOS-Base.repo5.yum clean all最后在使用yum 就可以了。 进程 进程是程序的执行过程，相对于程序，进程是动态的，在linux系统中，它与用户权限相关，程序与进程并没有一一对应，一个程序可能对应多个进程。 子进程与父进程：一个进程产生另外一个进程，产生的进程称为子进程，生成另外一个进程的进程称为父进程 进程状态 总体来看主要包括三种，分别是就绪状态、运行状态、等待状态，就绪状态指的是进程除了CPU资源，其他运行资源都已获得，当就就绪状态的进程得到CPU资源时，则进入进程进入运行状态，运行状态的进程在时间片用完后会重新转换成就绪状态，如果在运行时进程遇到IO等阻塞操作，则进程会进入等待状态，等待状态的进程当阻塞操作完成后，进程将进入就绪状态。 进程管理 ps命令:用于报告当前系统的进程状态。 123456789101112131415161718192021222324252627282930313233343536373839404142ps 命令常用选项包括：1、a显示所有用户的进程2、u显示用户名和启动时间3、x显示所有进程，包括没有控制终端的进程4、e显示所有进程，包括没有控制终端的进程，较x选项，信息更为简略5、l显示进程详细信息，按长格式显示ps -au 显示所有用户进程，并给出用户名和启动时间等详细信息ps -aux 显示所有用户进程，包括没有控制终端的进程，并给出用户和和启动埋单等详细信息ps -el 按长格式显示进程详细信息USER: 进程所有者PID: 进程号PPID: 进程的父进程ID%CPU: CPU占用率C: 进程的CPU占用率%MEM: 内存占用率VSZ: 表示如果一个程序完全驻留在内存的话需要占用多少内存空间;RSS: 指明了当前实际占用了多少内存;TTY: 终端的次要装置号码 (minor device number of tty)F：进程的标志S：进程的状态STAT: 该进程程的状态，有以下值D: 不可中断的静止R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的进程N: 低优先序的进程L: 有记忆体分页分配并锁在记忆体内PRI：进程的优先权NI：进程的Nice值ADDR：进程的地址空间SZ：进程占用内存的大小WCHAN：进程当前是否在运行TTY：进程所属终端START: 进程开始时间TIME: 执行的运行时间COMMAND：所执行的指令CMD：进程的命令 PID %CPU: CPU占用率 C: 进程的CPU占用率 COMMAND：所执行的指令 kill/pidof/pkill命令1234561、kill pid 直接杀死进程，但不能保证一定能杀死2、kill -9 pid 强制杀死进程3、pidof命令用于查看某个进程的进程号（例如：pidof mysqld）4、pkill命令可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉 进程切换 前台进程指的是进程在执行时会将命令行阻塞，直到进程执行完毕； 后台进程指的是进程在执行时不会阻塞当前命令行，而是在系统后台执行 123451、ctrl + c 终止进程2、ctrl + z 挂起进程3、fg命令将进程转换到前台执行4、bg命令将进程转换到后台执行5、jobs命令查看任务 top命令 Top 命令可以定期显示所有正在运行和实际运行并且更新到列表中， 它显示出 CPU 的使用、内存的使用、交换内存、缓存大小、缓冲区大小、过程控制、用户和更多命令。 它也会显示内存和 CPU 使用率过高的正在运行的进程。 按q键退出查看 pstree命令 将进程间的关系以树结构的形式展示，能清楚看各进程之间的父子关系 pstree ：以树状形式显示进程 pstree -p ： 以树状形式显示进程，并且显示进程号 JPS命令 JPS命令是JDK提供的一个检查系统是否启动了JVM进程的一个进程。 不是linux系统自带的。主要任务就是用来检查java进程的。 计划任务 计划任务在linux的体现主要分为at 和crontab,其中” at: 通过 at命令安排任务在某一时刻执行一次 crontab: 通过crontab命令,可以在固定的间隔时间执行指定的系统指令 或shell script脚本,时间间隔的单位可以是分钟,小时,日,月,周及以上的任意组合,适合周期性的日志分析和数据备份等工作. atcrontab 安装 yum -y install crontabs 服务操作说明 service crond start :启动服务 service crond stop: 关闭服务 service crond restart: 重启服务 service crod status :服务的状态 使用 crontab [-u user ] file crontab [ -u user ][-e -l -r] -u:指定用户 -e:编辑用户的crontab文件。 -l:查看用户的crontab -r:删除用户的crontab;从/var/spool/cron目录中删除 file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。 配置说明123456789基本格式 : * * * * * command 分 时 日 月 周 命令 第1列表示分钟1～59 每分钟用*或者 */1表示; */10表示10分钟第2列表示小时0～23（0表示0点） 7-9表示：7点到9点之间 多个时间段用逗号隔开7-9,11 */1每小时第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令 配置示例1234567891011121314151617181920212223242526272829*/1 * * * * date &gt;&gt; /root/date.txt上面的例子表示每分钟执行一次date命令30 21 * * * /usr/local/etc/rc.d/httpd restart上面的例子表示每晚的21:30重启apache45 4 1,10,22 * * /usr/local/etc/rc.d/httpd restart上面的例子表示每月1、10、22日的4 : 45重启apache10 1 * * 6,0 /usr/local/etc/rc.d/httpd restart 上面的例子表示每周六、周日的1 : 10重启apache0,30 18-23 * * * /usr/local/etc/rc.d/httpd restart上面的例子表示在每天18 : 00至23 : 00之间每隔30分钟重启apache0 23 * * 6 /usr/local/etc/rc.d/httpd restart上面的例子表示每星期六的11 : 00 pm重启apache* */1 * * * /usr/local/etc/rc.d/httpd restart上面的例子每一小时重启apache* 23-7/1 * * * /usr/local/etc/rc.d/httpd restart上面的例子晚上11点到早上7点之间，每隔一小时重启apache0 11 4 * mon-wed /usr/local/etc/rc.d/httpd restart上面的例子每月的4号与每周一到周三的11点重启apache0 4 1 jan * /usr/local/etc/rc.d/httpd restart 上面的例子一月一号的4点重启apache 克隆 vim /etc/udev/rules.d/70-persistent-net.rules将eth0 删除，然后将eth1换成eth0 之后复制 然后将ATTR{address}=后面的复制 修改网络配置 删除uid和硬件地址 修改ip vim /etc/sysconfig/network-scripts/ifcfg-eth0 修改主机名 vim /etc/sysconfig/network 修改主机和ip的映射 vim /etc/hosts ssh 免密登录 Secure Shell 安全外壳的协议((一种网络协议),服务器端进行交互的协议 ssh 就是专为远程登录会话和其他网络服务提供安全性的协议,默认端口22 ssh是有客户端和服务器的软件组成 组成 服务器端是: sshd的守护程序,在后台运行并相应来自客户端的连接请求 包含:ssh程序以及scp(远程拷贝),slogin(远程登录),sftp(安全文件传输)等其他应用程序 ssh认证机制 从客户端来看,ssh提供二种认证机制 基于口令;知道账户和口令,就可以登录到远程主机 基于密钥的安全验证 生成私钥和公钥 将公钥放到目标主机的授权池中 请求访问 主机通过公钥加密一段数据后响应 透过私钥解密后登陆目标主机 使用 ssh ip/ 域名 : 远程访问某台机器 scp -r 文件 用户@ip/域名:目录:远程拷贝 ​ :scp -r /root/a.txt root@hdp02:~/ 使用密钥验证 ssg-keygen,一路回车,得到公钥和私钥 发送公钥到授权池中~/.ssh/ ssh-copy-id 把公钥复制到远程主机上:ssh-copy-id user@host $ ssh-copy-id -i .ssh/id_rsa.pub 用户名字@192.168.x.xxx 12&gt; ssh-copy-id root@hdp02&gt; 注意: ssh-copy-id 将key写到远程机器的 ~/ .ssh/authorized_key.文件中]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linuxday02]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2FLinuxday02%2F</url>
    <content type="text"><![CDATA[VI编辑器 操作系统内置的文本编辑器,vim是增强版本 使用 vi/vim 文件 三种模式 命令模式 vi 文件 进入命令模式 a/i/o 进入插入模式 编辑模式/插入模式 esc 进入命令模式 底行模式 :命令 q:退出 w:保存 q!:强制退出 wq!:强制保存退出 命令模式下常用命令 光标的移动 字符移动 上下左右键,一个一个字符移动 hjkl:左/下/上/右 单词移动 w:移动到下一个单词首字母(包含标点) W:移动到下一个单词首字母(不包含标点) b:移动到上一个单词首字母(包含标点) B:移动到上一个单词首字母(不包含标点) e/E移动到下一个单尾字母/(包含标点) 逐句移动 (:移动到句子的开头 ):移动到句子的结尾 段落 {:移动到段落的开头 }:移动到段落的结尾 开始:G 结束gg M:移动到屏幕的中央 编辑模式 a:光标下一位 A:光标的行尾 i:光标之前 I:光标行的头 o:光标下一行 O:在光标这一行(当前行挤下去) yy:复制 ​ 3yy:从当前行复制3行 dd:删除 ​ 3dd:从当前行删除3行 p:粘贴 u:撤销 底行模式 :set nu 显示行号 :set nonu 不显示行号 :/查找内容 ​ n:下一个 ​ N:上一个 :noh 取消高亮 :N 跳转到N行 :开始行,结束行 s/被替换的诗句/替换的内容 ​ :1 s/sad/ddd(/g) 将第一行的sad替换为ddd (不带,第一个,带g所有替换) .代表当前光标行 $ 缓冲区的最后一行 网络管理ifconfig(centos 6) centos 7 :ip addr lo: 回环地址 -a 显示所有的网络接口(默认活动的) ifconfig 网卡名 up/down 开启/关闭网络接口 ping 查看网络的连接信息 虚拟机和宿主机通讯方式 bridged(桥接模式:访问外网) 主机的网卡和虚拟交换机(vmnet0)之间通过虚拟网桥连接 主机和虚拟机的ip是在同一个网段 缺点:不利于搭建大型集群 NAT模式(可以vmnet8局域网和外网): 虚拟系统借助NAT(网络地址转换)功能,通过宿主机的 宿主机创建vet8的虚拟网卡,虚拟机交换机用(vmnet8)建立连接,局域网 NAT地址转化,连接虚拟交换机和网卡,访问外网 DHCP协议:动态地址分配 仅主机模式,没有NAT设备(访问局域网)(vmnet1) 设置静态ip图形界面 设置虚拟网络编辑器,设置vmnet8的子网Ip 192.168.2.0 点击NAT设置,找到网关:192168.2.2 windows系统下vmnet8的ip地址192.168.2.1 network connections -eth0 -ipv4setting-manual -add 添加 192.168.2.101 -255.255.255-192.168.2.2 DNS:网关地址192.168.2.2 service network restart重启网络服务 命令方式 vim /etc/sysconfig/network-scripts/ifcfg-eth0 1234567891011121314151617DEVICE=eth0TYPE=EthernetUUID=8543ec50-f2b0-43c6-956e-5c059c1f83b6ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=noneDEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noNAME=&quot;System eth0&quot;HWADDR=00:0C:29:7C:77:1BIPADDR=192.168.2.101PREFIX=24GATEWAY=192.168.2.2DNS1=192.168.2.2LAST_CONNECT=1536895478NETMASK=255.255.255.0 service network restart 修改主机名 hostname: 查看和修改主机名称 hostname 查看主机名 hostname 主机名(临时有效,重启后失效) 永久修改(重启生效) vim /etc/sysconfig/network 12NETWORKING=yesHOSTNAME=hdp01 重启: reboot 修改主机名与ip映射 域名和ip地址的映射 windows C:\Windows\System32\drivers\etc linux: vi /etc/hosts 添加 1234127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.2.101 hdp1 测试:ping hdp1 其他常用命令 host :域名解析 host www.bai.du.com netstat :查看网络接口 netstat -nltp kill -9 pid 防火墙:控制网络访问”出入”状态 /ect/sysconfig/iptables 查看防护墙状态: service iptables status 关闭防火墙:service iptables stop(重启自动打开) start/restart chkconfig --list:查看服务的开机自启状态 chkconfig --list|grep iptables:查看iptables的启动管理 chkconfig iptables on/off:开机启动/关闭 vim /etc/sysconfig/iptables下添加规则 iptables -A INPUT -p tcp --dport22 -j DROP禁止SSH登陆 iptables -D INPUT -p tcp --dport22 -j DROP:删除规则 iptables -I INPUT -p tcp --dport 80 -j accept:添加一条规则,开放80端口 开启http服务 service httpd status 查看状态 service httpd start 开启(临时开启) chkconfig –list|grep httpd chkconfig httpd on 系统的启动级别 runlevel:查看当前的系统启动级别(0-6) 0:关机 1:单用户 2:多用户,不能访问网络 3:多用户,能访问网络(全功能,不带图形界面,速度快) 4:未使用 5:带有图形界面系统模式 6.重启 修改启动级别 vim /etc/inittab id:3:initdefault: reboot:重启 SecureCRT-8.1.4设置: option – global options –default Session – edit default session Terminal–Enulation–Terminal —&gt; “Linux”,勾选ANSI color,勾选Use color Scheme Appearance—&gt;Current color scheme 设置主题和字体 character encoding utf-8 ok 应用到所有 操作: 复制: 按住鼠标左键,选择文本 粘贴:右键即可 用户,组 用户:能够获取系统权限集合 组:权限的容器 ll查询的信息-rw-r–r–. 1 root root 13 Sep 14 09:43 a.txtdrwxr-xr-x. 2 root root 4096 Sep 14 10:09 Desktop 权限 链接数(文件链接数1 目录:子目录个数) root :所属用户 root: 所属用户组 4096: 文件大小 Sep 14 10:09:修改日期 Desktop 文件名称 用户类型 管理员root 具有使用所有权限的用户,uid为0 系统用户 保障系统运行的用户,一般不提供密码登录系统uid(1-499之间) 普通用户 一般用户,使用系统的权限受限,uid(500~60000之间) 查看用户信息 cat /etc/passwd 1234567891011root:x:0:0:root:/root:/bin/bashroot: 用户名称x: 密码的占位符 密码信息:/etc/gshadow0: 用户id0: 用户组idroot: 备注信息/root 家目录/bin/bash: shell 解释器类型新建从500开始:hdp01:x:500:500:hdp01:/home/hdp01:/bin/bash 操作用户添加用户 useradd用户名 修改用户 usermod [选项] 用户名 ​ -l 修改名称 ​ -G 修改组 ​ -c 修改备注信息 删除用户 userdel -r 用户名 修改密码 passwd用户名 1234567cat /etc/passwdcat /etc/groupuseradd sunusermod -G hdp01 sun hdp01:x:500:sunusermod -c beizu sun sun:x:501:501:beizu:/home/sun:/bin/bashusermod -l sun1 sun sun1:x:501:501:beizu:/home/sun:/bin/bashuserdel sun1 //删除后创建的sun1组还存在 用户组类型 系统组 一般加入一些系统用户 普通用户组 可以加入多个用户 私有组/基本组 创建用户的时候,没有指明所属的组,就为该用户设一个与用户名同名的私有组,该私有组添加了用户会变成普通组 查看用户组123456hdp01:x:500:sunhdp01: 用户组名称x: 组密码的占位符500: 组idsun 组中的用户 操作用户组 创建用户组: groupadd 修改用户组: groupmod -n:(修改名称) 删除用户组:groupdel 向组中添加删除用户:gpasswd -a:添加 -d:删除 1234567groupadd testuseradd test1gpasswd -a test1 testgpasswd -d test1 testgroupdel test1groupdel testusredel test1 为用户配置sudoer权限 给普通用户赋予更大的权限做一次操作 用root编辑/etc/sudoers文件 12root ALL=(ALL) ALL用户名 ALL=(ALL) ALL 切换用户su 用户名 文件权限 d rwx r-x r-x （也可以用二进制表示 111 101 101 –&gt; 755） 数字 4 、2 和 1表示读、写、执行权限 d：标识节点类型（d：文件夹 -：文件 l：链接） r：可读 w：可写 x：可执行 文件 文件夹 r 可读取内容 可以ls w 可修改文件的内容 可以在其中创建或者删除子节点 x 能否运行这个文件 能否cd进入这个目录 u第一组rwx： ## 表示这个文件的拥有者对它的权限：可读可写可执行 g第二组r-x： ## 表示这个文件的所属组用户对它的权限：可读，不可写，可执行 o第三组r-x： ## 表示这个文件的其他用户（相对于上面两类用户）对它的权限：可读，不可写，可执行 修改文件的权限chmod g-rw haha.dat ## 表示将haha.dat对所属组的rw权限取消 chmod o-rw haha.dat ## 表示将haha.dat对其他人的rw权限取消 chmod u+x haha.dat ## 表示将haha.dat对所属用户的权限增加x chmod a-x haha.dat ## 表示将haha.dat对所用户取消x权限 u +(加入) r/w/x 文件的拥有者 chmod g -(除去) r/w/x 所属组用户 o =(设定) r/w/x 其他用户 a 所用户 修改文件所有权chown angela aaa ## 改变所属用户 chown :angela aaa ## 改变所属组 chown angela:angela aaa/ ## 同时修改所属用户和所属组 对于文件夹的X 如果对文件夹有rw的权限:ls的时候,仅仅能知道目录下有文件,看不到详细信息 没有x权限:不能进入文件夹 有rwx权限的文件夹可以删除目录下的所有文件(没有对文件的权限也可以) 压缩和打包z：gzip，通过gzip格式压缩或者解压缩 c：create，创建压缩文件 x：extract，解压缩文件，或者叫还原文件 v：verbose，显示过程 f：file，指定文件 t：list，列出文件 j：支持bzip2压缩和解压缩 gzip压缩 gzip test.txt 压缩test.txt—&gt; test.txt.gz,不会多出文件 gzip解压缩 gzip -d test.txt.gz bzip2压缩 bzip2 test.txt 压缩test.txt –&gt; test.txt.bz2,不会多出文件 bzip2解压缩 bzip2 -d test.txt.bz2 或者 bunzip2 test.txt.bz2 打包 tar -cvf test.txt.tar test.txt 将test.txt 打包为test.txt.tar ,会多出一个test.txt.tar文件 追加打包 tar -rvf test.txt.tar test2.txt 表示将est2.txt文件追加到test.txt.tar当中 解包 tar -xvf test.txt.tar 打包并压缩 tar -zcvf ma.tar.gz /root/test 解包并解压缩 tar -zxvf ma.tar.gz 解包解压缩到指定的路径 tar -zxvf ma.tar.gz -C /test 查看压缩包的内容 tar -ztvf ma.tar.gz 打包并压缩车bz2 tar -jcvf test.tar.bz2 解压: tar-jxvf test.bar.bz2 Linux 开关机和重启开机: 开机键 关机:shutdown ,halt, init 0 ,poweroff 重启 init6 Shutdown命令详解： shutdown -h now ## 立刻关机 shutdown -h +10 ## 10分钟以后关机 shutdown -h 12:00:00 ##12点整的时候关机]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linuxday01]]></title>
    <url>%2Fblog%2F2018%2F09%2F13%2FLinuxday01%2F</url>
    <content type="text"><![CDATA[Linux要求 掌握: Linux的介绍 安装 文件系统和目录 基本命令 安装 安装虚拟机软件vmware(虚拟化技术：虚拟出计算机系统） 虚拟机软件中安装linux系统(centos) 虚拟化技术使用前提： 计算机必须支持虚拟化技术（默认关闭) 开启(进入bios): 关机 —&gt; 关机 —&gt; 进入bios 找到(inter vm technology) Enter 进入 上下键 选择 F10保存退出 Linux介绍什么是Linux Linux系统是一套免费使用和自由传播的类UNIX操作系统（主要用在服务器上），是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了UNIX以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux产生背景 1969年,贝尔实验室开发unix操作系统:1937年用c语言编写 1983年,理查德.托斯曼(黑客),,GUN计划(创建一套完全自由的操作系统),所有的软件都可以自由的使用复制修改和发布 Linux的文件系统和目录结构文件目录 windows :ntf4 centos 6:ext4 /7xfs linux文件系统介绍 linux:一切皆文件(目录/普通文件) 普通文件和目录名称要求 1. 长度:&lt;=255 2. 组成:A-Za-z0-9_... 3. 区分大小写 4. 文件扩展名:Linux没有扩展名(添加扩展名用于区分文件) Linux的目录结构 /:根目录,有多个功能的目录 /home:家目录(存放普通用户的数据) /root:root用户的家目录 /bin:/sbin:/usr/bin::可执行文件 /etc:存放配置信息 /usr:存放应用程序的信息 /usr/local:安装外置应用程序 /var:存放变量数据 日志信息/httpd服务器资源存放位置 /media/mnt:常用的挂载目录(挂载:将文件连接到一个已经存在的目录) /dev:设备目录,将设备的文件生成一个文件,需要放到挂载目录才能使用 /opt:额外安装软件的目录 终端工具的使用 open in Terminal [用户名@主机名称 当前位置] # 代表管理员 $普通用户 命令的格式1. 选项 : -简写单词(短模式) / --单词 (长模式) 常见命令 cd 路径 (切换目录) pwd : 查看当前路径 ls -a 隐藏 -A 不展示(./..) -h 友好显示大小 -l 详细信息 -R:递归显示 ll–&gt; ls -l 的别名 alisa(查看别面) du:查看目录和文件的磁盘占用 -a 统计所有,不仅仅是目录 -h 友好的形式暂时 -s 展示整体的占用 du - h :统计文件夹的大小(默认4k) df:显示磁盘相关信息 挂载:Mounted on df -h touch :创建/修改文件信息 touch 文件名 file:查看文件类型 根据文件内容 mkdir: 创建文件夹 -p 级联创建 ,父级目录不存在也创建 cp:复制 -i 覆盖时提示 -r 文件夹复制时要迭代 -p 源文件的属性不变 cp 源文件路径 目标文件路径 cp 源文件路径 目标文件路径/新的名字名 mv :剪切 -i 覆盖时提示 -f 强制覆盖,不询问 -u: 新文件覆盖旧文件 rmdir:删除空目录 rm: 删除文件和文件夹 -r 递归删除,一层层询问 -f 强制不询问 rm -rf /(小心) cat:查看文件,连接文件打印到控制台(不适合大文件,缓冲区有限) -n: 设置行号 tac:倒置输出 head :屏幕显示文件开头若干行 -n :设置行数(默认10行) tail: 显示结尾若干行 -n: 设置行数(默认10行) -f: 查看最新追加的内容 more : 翻页 less :分屏滚动显示 G:跳到结尾 gg:跳到开始 q:退出 echo : 输出指定的字符串和变量 A=12 echo $A -e: 能识别特殊字符 -ne:输出不换行;最后是不换行的 echo -e “aa\n\b” echo -ne “aa\n\b” > :重定向 ,覆盖 &gt;&gt;追加 alias:别名 alias:查看别名 alias la =’ll -a’ : 设置别名 unalias ls :取消别名 ln :设置连接 硬链接: 软链接:快捷方式 -s : 设置软连接 ln -s a.txt a1.txt su 切换用户 Ctrl+ C 终止程序 | :管道符,表示把前面命令内容的输出当做后面命令的输入]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday14版本控制工具]]></title>
    <url>%2Fblog%2F2018%2F09%2F12%2Fjavaeeday14%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[SVN 和 Maven 版本控制工具 集中式的版本控制工具 需要安装客户端和服务器端 集中式 开始开发,从服务器端检出(checkout),获取版本号为0; 更新项目,添加内容,提交(commit)后,服务器端版本号增加 下一个人员操作,先更新后提交 集中式: 所有代码的托管都在服务器端 版本号从0开始 操作的时候,先更新后提交 应用: svn应用于局域网 集中式,需要备份服务器 更新,速度慢 分布式 每一台机器都当做是服务器 SVN的使用 安装 服务器端工具 a安装客户端工具 eclipse使用svn 在eclipse安装目录创建svn文件夹 将features和plugins目录复制到svn 在dropiins目录下创建svn.link病编辑 path=eclipse创建的svn的目录 删除configration目录下的org.eclipse.update文件夹 项目–右键,选择Team—share project Maven 是项目构建,依赖管理,项目信息管理的工具 不涉编码 编码方式 eclipse: 手工操作较多 ide的配置有差异 ant:项目构建工具 maven:项目管理和依赖管理工具 基于pom(项目对象模型),xml配置 a) 项目依赖 b) 构建信息 对项目的目录有一定约束(优先于配置文件) 依赖管理:提供中央仓库 使用 需要jdk1.7以上 http://mvnrepository.com/ 定位jar 下载安装 使用 bin:可执行文件 boot:启动依赖的jar conf: 配置Maven的信息 配置本利仓库的路径 中央仓库路径(私服) jdk的版本 lib: 依赖的jar 配置环境变量 M2_HOME=maven安装路径 PATH=%M2_HOME%\bin 测试:mvn -v 1234567C:\Users\sun&gt;mvn -vApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T15:58:13+08:00)Maven home: D:\develop\maven\apache-maven-3.5.2\bin\..Java version: 1.8.0_144, vendor: Oracle CorporationJava home: D:\develop\Java\jdk1.8.0\jreDefault locale: zh_CN, platform encoding: GBKOS name: "windows 10", version: "10.0", arch: "amd64", family: "windows" eclipse使用骨架方式 Maven开发mybatis 在main /test 目录下添加resource file 文件名 resource 新建实体类 编写mybatis.xml文件,在src/main/目录下编写 需要编写在起别名的时候用全限定名称 12345678910&gt; &lt;typeAliases&gt;&gt; &lt;package name="com.lee.mybatisdemo.pojo" /&gt;&gt; &lt;/typeAliases&gt;&gt; &gt; &lt;mappers&gt;&gt; &lt;!-- &lt;mapper resource=" deptMapper.xml" /&gt; --&gt;&gt; &lt;!--批量加载配置文件 --&gt;&gt; &lt;package name="mappecom.lee.mybatisdemo.mapper" /&gt;&gt; &lt;/mappers&gt;&gt; 编写main/java/com.lee.mybatisdemo.mapper/UserMapper.java通过注解select等等 也使用配置文件,同包同名UserMapper.xml 配置文件应该放在main/resource包下 新建main/resource/com.lee.mybatisdemo.mapperuserMapper.xml 编写xmL的内容 导入数据库连接/mybatis/log4j/junit的包 run as 选择第一个build 填写 compile 出现问题,运行环境要是jdk,修改 选择run as 测试,src/test/java/Test/Test.java新建立一个test方法 通过Maven进行测试 Maven 开发web项目 新建立一个maven项目 勾选create a simple project 填写group id,artiface id ,version packaging打包为war 建立项目后会包错,没有web.xml和web-INF路径 修改项目的特性 项目右键 –properties-project faets ,修改dynamic web module为3.1 右键-javaee tools 工具生成 新建jsp页面src/main/webapp 新建立一个index.jsp 报错:The superclass “javax.servlet.http.HttpServlet” was not found on the Java Build Path 当前项目没有HttpServlet这个类 ,在servelet-api中 解决:在pom导入servlet-api 在sec/main/java下编写servlet类 测试 建项目打包为一个war包 发布到tomcat上 启动tomcat,进行访问 右键项目,runas –maven builde 输入:package 打包 可以在target目录下得到servletdemo-0.0.1-SNAPSHOT.war 名字太长,我们可以在pom.xml打包起名字 123&lt;build&gt; &lt;finalName&gt;test&lt;/finalName&gt;&lt;/build&gt; 清理 clean ,重新打包package;可以联合到一起clean package 将生成的test.war得到放到tomcat,tomcat会默认对war进行解包 将生成的jar包放到tomcat的webapps下 运行tomcat webapps会得到test文件夹 打开浏览器: http://127.0.0.1:8080/test/ 这样打包放上去比较麻烦,有问题需要修改后打包,放到tomcat 清理项目,配置直接运行项目 在&lt;build&gt;标签内添加插件标签&lt;plugin&gt; 1234567891011121314151617&lt;build&gt; &lt;finalName&gt;test&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;!-- 配置插件 --&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;!-- 对当前项目的tomcat进行配置 --&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 当前项目用"localhost:8080/servlet"就可以访问 --&gt; &lt;path&gt;/servlet&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 运行tomcat的插件: 项目右键,运行run as maven build: tomcat7:run]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday13SpringMVC]]></title>
    <url>%2Fblog%2F2018%2F09%2F11%2Fjavaeeday13SpringMVC%2F</url>
    <content type="text"><![CDATA[SpringMVC和ssm框架的整合 SpringMVC参数的封装 简单数据: url中参数名 对象: url参数名称和对象 数组: url参数名称和数组名称一致 list和map集合:不能直接封装，需要作为对象的属性存在 手动使用request对象1234567891011// 参数的接收// 手动给出request和response@RequestMapping("/login.do")public String login(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(request.getAttribute("username")); return "show";&#125; SpringMVC的方式 springMVC底层已经将链接后的参数获取,我们只需要手动接收 123456789http://localhost:8080/springMVCDemo02/login.do?username=zs&amp;pwd=123456@RequestMapping("/login.do") public String login(String username, String password) &#123; System.out.println(username + ":" + password); //zs:null System.out.println(username + ":" + pwd); //zs:123456 return "show"; &#125; 使用对象接收 类对象的属性名称要和连接中的参数名称保持一致 123456789101112//1. 创建一个user.class,给出username和password属性//2.给出访问器和toString方法//访问:http://localhost:8080/springMVCDemo02/login.do?username=zs&amp;password=123456&amp;hobby=book&amp;hobby=fruit@RequestMapping("/login.do")public String login(User user, String[] hobby) &#123; System.out.println(Arrays.toString(hobby)); //[book, fruit] System.out.println(user); //User [username=zs, password=123456] return "show";&#125; 封装到list/map集合 不能直接封装 123456789&lt;form action="login.do" method="get"&gt; 用户名:&lt;input type="text" name="username"&gt;&lt;br&gt; 密码:&lt;input type="text" name="password"&gt;&lt;br/&gt; 爱好:&lt;input type="text" name="aaa[0]"&gt; &lt;input type="text" name="aaa[1]"&gt;&lt;br&gt; 备注: &lt;input type="text" name="map[name]"&gt; &lt;input type="text" name="map[age]"&gt; &lt;input type="submit" value="注册"&gt;&lt;/form&gt; 12345678910111213141516//实体类private String username;private String password;private List aaa;private Map map;@RequestMapping("/login.do")public String login(User user, String[] hobby) &#123; System.out.println(Arrays.toString(hobby)); System.out.println(user); return "show";&#125;//结果User [username=aa, password=bb, aaa=[cc, dd], map=&#123;age=ff, name=ee&#125;] 数据的回显 Model 相当于request域 1234567891011121314@RequestMapping("/user.do")public String login(User user, Model model) &#123; System.out.println(user); //相当于request域 model.addAttribute("user", user); return "show";&#125;//show.jsp获取&lt;body&gt; hello,$&#123;user.uname &#125;&lt;/body&gt; 转发和重定向 forward:url:转发 redirect:url: 重定向 123456789101112@RequestMapping("/login.do")public String login(User user, String[] hobby) &#123; System.out.println(Arrays.toString(hobby)); System.out.println(user); // return "show"; // 转发 return "forward:user.do"; // 重定向:requsetd中的值会丢失 // return "redirect:user.do";&#125; 编码问题 过滤器处理编码 在web.xml中配置过滤器 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;charset&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;charset&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; ssm整合 Mybatis 数据持久层 Spring 业务逻辑层(对象管理) SpringMVC 表示层 12345678910111213141516171819202122232425262728293031323334351.需求使用ssm实现查询所有用户信息并展示。 index.jsp 展示 show.jsp 1)创建web项目,导入jar mybatis: mysql.jar mybatis.jar mybatis-spring.jar：spring创建管理mybatis中的对象 spring: 4+1 spring-aop.jar spring-aspects.jar aopalliance.jar aspectjweaver.jar spring-web.jar spring-test.jar spring-jdbc.jar (连接池) spring-orm.jar (整合orm框架) spring-tx.jar (事务管理) springMVC： spring-webmvc.jar jackson-all.jar 其他: log4j.jar jstl.jar 2)mybatis项目实现数据查询 3)mybatis和spring整合 3.1 连接和事务管理交给spring 3.2 SqlsessionFactory，sqlsession，mapper对象创建交给spring 4)整合springMVC 整合出现的问题,整合mybatis 将mybatis.xml文件的上下文环境交给spring创建 1234567891011121314151617181920&lt;context:component-scan base-package="service"&gt;&lt;/context:component-scan&gt;&lt;!-- 1.创建管理连接 四个参数 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;bean id="ds" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;user&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt;&lt;/bean&gt;&lt;!-- 2.SqlsessionFactory --&gt;&lt;bean id="ssf" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="configLocation" value="classpath:mybatis.xml"&gt;&lt;/property&gt; &lt;property name="dataSource" ref="ds"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--3.创建mapper 两种方式: 单个mapper创建 批量创建--&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="sqlSessionFactoryBeanName" value="ssf"&gt;&lt;/property&gt; &lt;property name="basePackage" value="mapper"&gt;&lt;/property&gt;&lt;/bean&gt; 测试 1234567@AutowiredUserService service;@org.junit.Testpublic void test() &#123; System.out.println(service.queryAll());&#125; 测试时候出现问题,空指针 原因: 创建service的时候没有加载applicationContext.xml的配置文件,依赖注入失败 解决办法: 加载applicationContext.xml 12345678910111213141516171819202122232425262728@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext.xml")public class Test &#123; /* //mybatis的使用 * public void test() throws IOException &#123; * * // 1.加载配置文件 Reader rd = Resources.getResourceAsReader("mybatis.xml"); // * 2.创建sqlsession工厂 SqlSessionFactory factory = new * SqlSessionFactoryBuilder().build(rd); * * // 创建session * * SqlSession session = factory.openSession(true); UserMapper mapper = * session.getMapper(UserMapper.class); List&lt;UserInfo&gt; info = * mapper.queryAll(); System.out.println(info); session.close(); * * * &#125; */ @Autowired UserService service; @org.junit.Test public void test() &#123; System.out.println(service.queryAll()); &#125;&#125; 整合SpringMVC整合小节 mybatis是数据持久层的框架(dao) 将mybatis.xml文件的上下文环境交给spring创建 mybatis.xml只用 加载jdbc的配置文件, 给实体类起别名 作用,在给mybatis.xml的映射文件中的sql标识返回值 123456789101112&lt;typeAliases&gt; &lt;!-- 设置单一别名 --&gt; &lt;!-- &lt;typeAlias type="pojo.User" alias="user" /&gt; --&gt; &lt;!-- 批量起别名 默认的名称为类名 --&gt; &lt;package name="pojo" /&gt;&lt;/typeAliases&gt;//映射文件的resultType可以用user代替&lt;select id="selectDeptinfo" resultType="pojo.User"&gt; select * from dept where deptno =#&#123;deptno&#125;&lt;/select&gt; 给实体类添加映射器&lt;mappers&gt; 可以批量添加一个包下mapper Spring 调用service 层 ,service 调用mapper映射对象,需要加载applicationContext.xml 编写springMVC层,建立一个后端控制器(Controller),调用service 编写前端控制器web.xml 注意: 我们需要指定SpringMVC.xml的路径,默认在web-INF 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写springMVC.xml 扫描控制器(映射器,适配器)需要在头文件上添加mvc的信息,能够识别controller包下的注解 123xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot; 编写视图解析器 注意:出现找不到Userservice 1No qualifying bean of type [service.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125; Service是由Spring进行管理的,使用service对象的时候,应该先加载applicationContext.xml文件 12applicationContext.xml&lt;context:component-scan base-package="service"&gt;&lt;/context:component-scan&gt; 解决办法:在web.xmL文件中添加监听器(保证在发请求之前就加载配置文件) 1234567891011121314151.添加监听器,在请求之前就要加载配置文件//指定路径&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;//监听的时候加载配置文件&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;servlet&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday12Spring]]></title>
    <url>%2Fblog%2F2018%2F09%2F08%2Fjavaeeday12Spring%2F</url>
    <content type="text"><![CDATA[Spring Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。 Spring是一个分层的JavaSE/EE full-stack(**一站式)** 轻量级开源框架。 学习核心:1. IOC控制反转 ; 2. 面向切面编程 1.方便解耦，简化开发 通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。 2.AOP编程的支持 通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 3.声明式事务的支持 在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。 4.方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。 5.方便集成各种优秀框架 Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。 6.降低Java EE API的使用难度 Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。 7.Java 源码是经典学习范例 Spring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。 什么是ICO 控制反转,用户创建对象的权利反转给spring容器 创建对象和管理对象的关系都有spring容器操作 DL:依赖注入:在运行过程中将数据动态注入对象依赖的过程(反射实现) Spring IOC（控制反转）的理解 入门案例开发 jar包(4+1) spring-core spring-beans spring-context spring-ecpression commons-logging （archive.apache.org）,mybatis中可以找到 新建java程序 创建dao接口和实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package dao;public interface UserDao &#123; void addUser(); void deleteUser();&#125;//---实现类1------------------------------------------package dao.impl;import dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void addUser() &#123; System.out.println("添加用户"); &#125; @Override public void deleteUser() &#123; System.out.println("删除用户"); &#125;&#125;//---实现类2------------------------------------------package dao.impl;import dao.UserDao;public class UserDaoImpl2 implements UserDao &#123; @Override public void addUser() &#123; System.out.println("添加用户2"); &#125; @Override public void deleteUser() &#123; System.out.println("删除用户2"); &#125;&#125; 创建service接口和实现类 1234567891011121314151617181920212223242526272829303132package service;public interface UserService &#123; void addUser(); void deleteUser();&#125;//---实现类1------------------------------------------package service.impl;import dao.UserDao;import dao.impl.UserDaoImpl2;import service.UserService;public class UserServiceImpl implements UserService &#123; @Override public void addUser() &#123; dao.addUser(); &#125; @Override public void deleteUser() &#123; dao.deleteUser(); &#125;&#125; 新建source fFolder,编写applicationContext.xml 通过配置文件来创建对象,一个&lt;bean&gt;为一个对象 id是对象的唯一标识 class:实现类的全限定名称 依赖注入dl 接口+setter方法 配置文件调用构造方法给属性赋值&lt;property&gt; name:对象的属性名 value/ref:基本类型/引用类型() 接口+有参构造: &lt;constructor-arg&gt; 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 创建一个对象 id:对象唯一标识 class:类的全限定名称 --&gt; &lt;bean id="userdao" class="dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; &lt;bean id="userdao2" class="dao.impl.UserDaoImpl2"&gt;&lt;/bean&gt; &lt;!-- 调用无参构造创建对象 --&gt; &lt;bean id="userservice" class="service.impl.UserServiceImpl"&gt; 属性标签: name:属性的名称 value:简单类型的值 ref:引用 &lt;property name="dao" ref="userdao2"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 有参构造 --&gt; &lt;bean id="userservice" class="service.impl.UserServiceImpl"&gt; &lt;!-- name:名称 value:简单类型 ref:应用 index:参数的索引 type:参数类型 --&gt; &lt;constructor-arg name="dao" ref="userdao2"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 12345678910111213141516/**** 程序需要就自己创建依赖对象,* 就产生了耦合*/public static void main(String[] args) &#123; //不使用反转 //创建对象调用方法 UserDao dao = new UserDaoImpl(); dao.addUser(); dao.deleteUser();&#125;----------------添加用户删除用户 123456789101112131415&lt;bean id="userdao" class="dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;bean id="userdao2" class="dao.impl.UserDaoImpl2"&gt;&lt;/bean&gt;//1. 加载配置文件(spring容器) ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");//2. 从容器中获取对象,根据&lt;bean&gt;标签的id的到创建的对象,后面写类类型规定类型UserDao bean = context.getBean("userdao", UserDao.class);UserDao bean2 = context.getBean("userdao2", UserDao.class);//3.对象调用方法bean.addUser();bean.deleteUser();bean2.addUser();bean2.deleteUser(); 123456789101112131415161718192021222324252627282930313233343536//构造器/setter方法&lt;bean id="userservice" class="service.impl.UserServiceImpl"&gt; &lt;!-- 属性标签,借助属性的set访问器赋值: name:属性的名称 value:简单类型的值 ref:应用 --&gt; &lt;property name="dao" ref="userdao"&gt;&lt;/property&gt;&lt;/bean&gt;-------------------------UserDao dao;//setter方法public void setDao(UserDao dao) &#123; this.dao = dao;&#125;--------------------------------------/*** service 需要调用dao,之前是直接写* 通过spring容器给对象的属性赋值*/ // 1. 加载配置文件(spring容器) ApplicationContext context = new ClassPathXmlApplicationContext( "applicationContext.xml"); // 2. 从容器中获取对象,根据&lt;bean&gt;标签的id的到创建的对象,后面写实现类类型规定类型 UserServiceImpl bean = context.getBean("userservice", UserServiceImpl.class); // 3.对象调用方法 bean.addUser(); bean.deleteUser(); 使用&lt;constructor-arg&gt;是通过调用带参构造实现的 如果要使用无参构造和访问器,一定要给出 给出了带参构造之后,要手动给出默认无参构造,(…当时这里出现问题,好久才知道原因,感觉自己傻傻的…) 否则会报错:org.springframework.beans.BeanInstantiationException: Failed to instantiate [service.impl.UserServiceImpl]: No default constructor found; 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 使用带参构造 --&gt;&lt;bean id="userService2" class="service.impl.UserServiceImpl"&gt; &lt;!-- name:名称 //value;简单类型// ref:引用 //index: 参数索引 type:参数类型 --&gt; &lt;!-- 看到源码: 通过name value//ref对属性赋值 name="dao" ref="userdao" --&gt; &lt;!-- 不知道源码: 通过index value/ref进行赋值 当构造函数有多个参数时，可以使用constructor-arg标签的index属性，index属性的值从0开始。 index="1" ref="userdao" --&gt; &lt;constructor-arg index="0" ref="userdao" &gt;&lt;/constructor-arg&gt; &lt;!-- &lt;constructor-arg name="dao" ref="userdao2"&gt;&lt;/constructor-arg&gt; --&gt;&lt;/bean&gt;---------------------UserDao dao;public UserServiceImpl(UserDao dao) &#123; this.dao = dao;&#125;public UserServiceImpl() &#123;&#125;--------------------------// 1. 加载配置文件(spring容器) ApplicationContext context = new ClassPathXmlApplicationContext( "applicationContext.xml");// 2. 从容器中获取对象,根据&lt;bean&gt;标签的id的到创建的对象,后面写实现类类型规定类型UserServiceImpl bean = context.getBean("userservice2", UserServiceImpl.class);// 3.对象调用方法bean.addUser();bean.deleteUser(); 注解实现装配 导入spring-aop-4.1.6.RELEASE.jar @Component &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;基本注解，标识一个受Spring管理的Bean组件 @Controller:表示层 @service:业务逻辑层 @repository:数据持久层,注解指定此类是一个容器类，是DA层类的实现。标识持久层Bean组件 @Scope指定此spring bean的scope是单例 @Resources: 实现依赖注入 @Autowired: 注解告诉spring，这个字段需要自动注入 @Qualifie(“”):实现依赖注入 6.7二个标签联合使用 开发 建立javaproject 导入(4+1)和spring-aop-4.1.6.RELEASE.jar 编写dao接口和实现类 编写service接口和实现类 编写applicationContext.xml 配置完&lt;context:component-scan&gt;标签后，spring就会去自动扫描base-package对应的路径或者该路径的子包下面的java文件，如果扫描到文件中带有@Service,@Component,@Repository,@Controller等这些注解的类，则把这些类注册为bean 在注解后加上例如@Component(value=”abc”)时，注册的这个类的bean的id就是adc. use-default-filters属性的默认值为true,这就意味着会扫描指定包下标有@Service,@Component,@Repository,@Controller的注解的全部类，并注册成bean。 &lt;context:component-scan base-package=&quot;com.sparta.trans&quot;/&gt; Use-default-filter此时为true 如果你只想扫描指定包下面的Controller，那该怎么办？此时子标签&lt;context:incluce-filter&gt;就可以发挥作用了。 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="dao,service"&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 给dao实现类添加注解 123456789101112131415161718192021package dao.impl;import org.springframework.stereotype.Repository;import dao.UserDao;//设置实现类对象的id为userdao,可以通过配置文件使用@Repository("userdao")public class UserDaoImpl implements UserDao &#123; @Override public void addUser() &#123; System.out.println("添加用户"); &#125; @Override public void deleteUser() &#123; System.out.println("删除用户"); &#125;&#125; 给Service实现类添加注解 12345678910111213141516171819202122232425262728293031323334353637383940414243package service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import dao.UserDao;import service.UserService;//设置实现类对象的id为userdao2,可以通过配置文件使用@Service("userservice")public class UserServiceImpl implements UserService &#123; // 接口 + 构造器/setter方法 UserDao dao; public UserServiceImpl() &#123; &#125; // 1.构造器 public UserServiceImpl(UserDao dao) &#123; this.dao = dao; &#125; // 2.setter方法 @Autowired @Qualifier("userdao") //这样Spring会找到id为userdao的bean进行装配。 public void setDao(UserDao dao) &#123; this.dao = dao; &#125; @Override public void addUser() &#123; dao.addUser(); &#125; @Override public void deleteUser() &#123; dao.deleteUser(); &#125;&#125; 遇到的问题1org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from class path resource [com/ckinghan/spring7_auto/beans.xml]; nested exception is java.lang.NoClassDefFoundError: org/springframework/aop/TargetSource 解决办法:导入spring-aop-4.1.6.RELEASE.jar 代理 访问真实的对象之前和之后对请求进行预处理以及过滤等功能 静态代理 在编译期间,为每个真实类创建代理类在代理类中提供预处理和过滤功能 好处: 业务分离 缺点:必须给每个接口写代理类，代理方法代码不能复用 实现 新建一个代理类实现dao的接口 代理类进行业务处理与过滤功能 测试 多态创建代理类的对象 对象调用dao的方法 1234567891011121314151617181920212223242526272829303132//对dao的实现类进行代理,在之前之后添加功能package dao.proxy;import dao.IUserDao;import dao.impl.UserDaoImpl;public class UserDaoProxy implements IUserDao &#123; UserDaoImpl dao ; public UserDaoProxy(UserDaoImpl dao) &#123; this.dao=dao; &#125; @Override public void addUser() &#123; // TODO Auto-generated method stub System.out.println("开启事务.."); dao.addUser(); System.out.println("关闭事务"); &#125; @Override public void deleteUser() &#123; // TODO Auto-generated method stub System.out.println("开启事务.."); dao.deleteUser(); System.out.println("关闭事务"); &#125;&#125; 测试 12345678910111213141516171819202122package Test;import dao.IUserDao;import dao.impl.UserDaoImpl;import dao.proxy.UserDaoProxy;public class Test &#123; public static void main(String[] args) &#123; IUserDao dao = new UserDaoProxy(new UserDaoImpl()); dao.addUser(); dao.deleteUser(); &#125;&#125;---------------------------------开启事务..创建user1对象关闭事务开启事务..销毁user1对象关闭事务 动态代理 在运行期间,为每个真实对象创建代理对象的方式 jdk:动态代理:接口 + 实现类 cglib:动态代理:委托类 创建委托类对象 创建代理类对象 设置父类(cglib) 添加增强功能 生产代理对象(cglib) 代理调用方法 jdk实现动态代理 不用编写一个代理类实现dao接口 Proxy.newProxyInstance(loader, interfaces, InvocationHandler h) 12345678910111213141516171819202122232425262728293031323334353637383940package Test;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import dao.IUserDao;import dao.impl.UserDaoImpl;public class ProxyTest &#123; public static void main(String[] args) &#123; //1.创建委托类对象 IUserDao dao = new UserDaoImpl(); //2.生成代理对象 IUserDao proxy = (IUserDao) Proxy.newProxyInstance( ProxyTest.class.getClassLoader(), dao.getClass().getInterfaces(), //委托类对象实现的接口 new InvocationHandler() &#123; //proxy:代理类对象 //method:委托类对象方法描述对象 //args:方法的参数 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("开启事务"); //手动调用拦截的方法 Object obj = method.invoke(dao, args); System.out.println("提交事务"); return obj; &#125; &#125;); //3.调用代理对象方法 proxy.addUser(); proxy.deleteUser(); &#125;&#125; cglib动态代理 不用编写一个代理类实现dao接口 需要导入cglib,asm的.jar,但是spring core.jar中包含了这些jar 1234567891011121314151617181920212223242526272829303132333435363738package Test;import java.lang.reflect.Method;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import dao.impl.UserDaoImpl;public class CglibTest &#123; public static void main(String[] args) &#123; //1.创建委托类对象 UserDaoImpl userdao = new UserDaoImpl(); //2.创建代理类对象 Enhancer enhancer = new Enhancer(); //设置父类 enhancer.setSuperclass(UserDaoImpl.class); //添加增强功能 enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy proxyMethod) throws Throwable &#123; System.out.println("开启事务"); Object obj = method.invoke(userdao, args); System.out.println("提交事务"); return obj; &#125; &#125;); UserDaoImpl proxy = (UserDaoImpl) enhancer.create(); //3.调用 proxy.addUser(); proxy.deleteUser(); &#125;&#125; spring aop面向切面编程 采用横向抽取方式,在运行阶段,动态向目标对象织入增强代码的一种思想,底层采用原理:动态代理 原理 jdk 和cglib动态代理 应用场景 事务管理,性能检测,日志管理,缓存… aop框架 spring aop aspectj jboss aop 专业术语 target:目标对象(需要添加增强代码的对象) advince:通知,增强代码类的对象 jointpoint:连接点目标对象的方法 pointCut;切入点,添加了增强代码的方法 weaver:织入(动态过程),增强代码添加到目标对象方法的过程 aspect:切面,增强代码和目标对象的方法之间形成的面 aop的开发 新建立java project—- 导入jar(9个) 4+1 spring -aop.jar spring-aspects:aspectj的规范 aopoliance.jar:aop联盟,设置通知的规范 aspectjweaver-1.8.5.jar:织入的实现 编写dao接口和实现类,添加注解 编写Service接口和实现类,添加注解 抽取出增强代码类aspect—-MyAspect.java,写入增强代码 修改applicationContext.xml &lt;cop:config&gt;:声明代理的方式,默认jdk代理 配置切入点&lt;aop:pointcut&gt; 使用id标识切入点 使用expression表达式找到需要切入的方法 格式:exection(访问修饰符 包名.类型.方法名(参数列表)),*号代表通配符 exection( srevice.impl.UserServiceImpl.()):UserServiceImpl类下的无参方法 exection( srevice..(..)): service包下的所有类和所有方法 配置切面&lt;aop:aspecct&gt; ref:增强代码的对象(目标类的实现类的对象) 前置增强:方法调用之前的增强代码&lt;aop:before /&gt; &lt;pointcut-ref&gt;:声明那个切入点(切入点的id) &lt;method&gt;:增强的方法 后置增强:方法调用之后执行的增强代码&lt;aop:after /&gt; &lt;pointcut-ref&gt;:声明那个切入点(切入点的id) 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--1.创建目标类对象 --&gt; &lt;bean id="userservice" class="service.impl.UserServiceImpl"&gt;&lt;/bean&gt; &lt;!--2.创建增强代码类对象 --&gt; &lt;bean id="myaspect" class="aspect.MyAspect"&gt;&lt;/bean&gt; &lt;!--3.aop织入增强代码 proxy-target-class:true代表强制使用cglib动态代理 --&gt; &lt;aop:config&gt; &lt;!-- 切入点: 找方法 id:切入点标识 expression:表达式 --&gt; &lt;aop:pointcut expression="execution(* service..*(..))" id="myPointCut"/&gt; &lt;!-- 配置切面: 增强代码+切入点 ref：增强代码对象 --&gt; &lt;aop:aspect ref="myaspect"&gt; &lt;!-- 前置增强 --&gt; &lt;aop:before method="before" pointcut-ref="myPointCut"/&gt; &lt;!-- 后置增强 --&gt; &lt;aop:after-returning method="after" pointcut-ref="myPointCut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试 12345678910111213141516171819202122package test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.IUserSerivice;public class Test &#123; public static void main(String[] args) &#123; // 1.加载容器 ApplicationContext context = new ClassPathXmlApplicationContext( "applicationContext.xml"); // 2.获取目标对象 IUserSerivice service = context.getBean("userService", IUserSerivice.class); // 3.调用方法 service.addUser(); service.deleteUser(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeday11mybatis框架]]></title>
    <url>%2Fblog%2F2018%2F09%2F07%2Fjavaeeday11mybatis%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[什么是框架将繁琐的,重复性工作封装起来,使开发者能够将更多精力放在业务分析的理解上的这套程序. 框架的优点 简化开发,提升开发效率 屏蔽细节,安全性高 Mybatis框架 传统jdbc的问题 连接的四个参数有硬编码问题,(配置文件) sql的定制不够灵活 频繁打开和关闭连接 是一个持久层框架,支持定制化sql,存储过程和高级映射 mybatis通过xml或者注释实现定制 mybatis是一个orm框架 orm:对象关系映射 (java对象和关系型数据库表记录之间的映射问题) 关注点 sql 输入的参数 输出结果 入门案例 jar mybatis:核心jar 数据库的connection-jar 底层封装jdbc 注册驱动 获取链接(全局配置文件:连接池配置 事务管理器) 发送sql(映射文件:定制化sql(输入参数和输出结构的映射)) 接收处理(java 代码读取配置文件调用api测试) 释放资源 步骤: 导入jar包 src–pojo 新建立一个source File–config config下建立jdbc.properties config下创建mybatis.xml文件 5.1 加载配置文件 1&lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; 5.2 起别名 设置单一别名 批量设置别名 123&lt;typeAliases&gt; &lt;!-- 设置单一别名 --&gt; &lt;typeAlias type="pojo.User" alias="user" /&gt;&lt;/typeAliases&gt; 1234&lt;typeAliases&gt; &lt;!-- 批量起别名 默认的名称为类名 --&gt; &lt;package name="pojo" /&gt; &lt;/typeAliases&gt; 5.2.3 配置环境 ​ 1. 数据源 ​ 2. 事务管理器 12345678910111213141516&lt;environments default="development"&gt; &lt;!-- 具体环境:id:当前环境的唯一标识 --&gt; &lt;environment id="development"&gt; &lt;!-- 事务管理器 type:事务管理器的类型 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据源 type:pooled 连接池管理 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 5.3.4 配置映射器 ​ 1. 单个映射 123&lt;mappers&gt; &lt;mapper resource="UserInfoMapper.xml" /&gt;&lt;/mappers&gt; 2. 批量加载映射文件 &gt; mapper接口和mapper映射文件必须同包同名 --&gt; 1234&lt;mappers&gt; &lt;!-- 批量加载映射文件: mapper接口和mapper映射文件必须同包同名 --&gt; &lt;package name="mapper"/&gt;&lt;/mappers&gt; 具体的mybatis.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 约束dtd/schema --&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;!-- 环境 --&gt;&lt;configuration&gt; &lt;!-- 配置文件 --&gt; &lt;properties resource="jdbc.properties"&gt;&lt;/properties&gt; &lt;typeAliases&gt; &lt;!-- 设置单一别名 --&gt; &lt;!-- &lt;typeAlias type="pojo.User" alias="user" /&gt; --&gt; &lt;!-- 批量起别名 默认的名称为类名 --&gt; &lt;package name="pojo" /&gt; &lt;/typeAliases&gt; &lt;environments default="development"&gt; &lt;!-- 具体环境:id:当前环境的唯一标识 --&gt; &lt;environment id="development"&gt; &lt;!-- 事务管理器 type:事务管理器的类型 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据源 type:pooled 连接池管理 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 映射器 --&gt; &lt;mappers&gt; &lt;mapper resource="UserInfoMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; config–建立UserInfoMapper.xml 映射器的名字与mybatis.xml中单个定义时候相同 1. `#{name}`:表示一个**占位符** 为string,基本类型的时候,名字随便写 如果传入的参数是pojo类型,那么#{}中的变量名称必须是pojo中的属性.属性.属性… ${value}:表示拼接符:字符串原样拼接 拼接符有可能造成sql注入 具体的UserInfoMapper.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace:命名空间(隔离sql) --&gt;&lt;mapper namespace="DeptMapper"&gt; &lt;!-- 根据id查询dept的表中的数据 --&gt; &lt;select id="selectDeptinfo" resultType="pojo.User"&gt; select * from dept where deptno =#&#123;deptno&#125; &lt;/select&gt; &lt;!-- 查询全部的数据,返回的是list,用User接收--&gt; &lt;select id="selectAll" resultType="pojo.User"&gt; select * from dept &lt;/select&gt; &lt;!-- 模糊查询 --&gt; &lt;select id="selectlikeName" resultType="pojo.User"&gt; select * from dept where dname like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加 --&gt; &lt;insert id="insertInfo"&gt; &lt;!-- value与实体类中的一致 --&gt; insert into dept(deptno,dname,loc) values(#&#123;deptno&#125;,#&#123;dname&#125;,#&#123;loc&#125;) &lt;/insert&gt;&lt;/mapper&gt; 增删改查案例 准备阶段和入门案例一样,对UserInfoMapper.xml进行操作 增&lt;insert id=&quot; &quot;&gt;SQL &lt;/insert&gt; 删&lt;delete id=&quot;&quot;&gt;SQL &lt;/delete&gt; 改&lt;update id=&quot;&quot;&gt;SQL &lt;/update&gt; 查&lt;select id=&quot; &quot;&gt;SQL &lt;/select&gt; 具体代码: 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace:命名空间(隔离sql) --&gt;&lt;mapper namespace="DeptMapper"&gt; &lt;!--查询 --&gt; &lt;select id="selectDeptinfo" resultType="pojo.User"&gt; select * from dept where deptno =#&#123;deptno&#125; &lt;/select&gt; &lt;select id="selectAll" resultType="pojo.User"&gt; select * from dept &lt;/select&gt; &lt;!-- 模糊查询 --&gt; &lt;select id="selectlikeName" resultType="pojo.User"&gt; select * from dept where dname like '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加 --&gt; &lt;insert id="insertDept"&gt; &lt;!-- value与实体类中的一致 --&gt; insert into dept(deptno,dname,loc) values(#&#123;deptno&#125;,#&#123;dname&#125;,#&#123;loc&#125;) &lt;/insert&gt; &lt;!--修改 --&gt; &lt;update id="updateDept"&gt; update dept set dname=#&#123;dname&#125;,loc=#&#123;loc&#125; where deptno =#&#123;deptno&#125; &lt;/update&gt; &lt;!-- 删除 --&gt; &lt;delete id="deleteDept"&gt; delete from dept where deptno = #&#123;deptno&#125; &lt;/delete&gt;&lt;/mapper&gt; 测试 123456789101112131415161718192021222324public static void main(String[] args) &#123; try &#123; // 1.加载配置文件 Reader rd = Resources.getResourceAsReader("mybatis.xml"); SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(rd); // 2.SqlSession的方法来处理增删改查 // SqlSession session = ssf.openSession(); //开启事务自动提交 SqlSession session = ssf.openSession(true); //使用映射文件的命名空间和操作的id // User info = session.selectOne("DeptMapper.selectDeptinfo", 10); // List&lt;User&gt; info = session.selectList("DeptMapper.selectAll"); // List&lt;User&gt; info =session.selectList("DeptMapper.selectlikeName","s"); User user = new User(1,"zs","654321"); int info =session.insert("DeptMapper.insertDept",user); //释放资源 session.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; mapper代理实现dao开发 Mapper接口开发方法只需要编写Mapper接口（实际上相当于DAO接口）然后由Mybatis根据接口定义创建接口的动态代理对象。换句话说也就是不用自己编写DAO接口的实现类了。 要求: 1. mapper接口和mapper映射文件必须同包同名 2． mapper映射的namespace和接口全限定名称保持一致 3． mapper标签的id值和接口的方法名称一致 4． 标签的输入参数和接口方法的输入参数类型一致 5． 标签的结果类型和接口方法的返回值类型一致 实现dao之前,编写了mybatis.xml 1. 加载了配置文件 2. 对pojo下的类批量起别名 3. 配置了环境 4. 批量加载mapper下的映射文件 UserInfoMapper.java 1234567package mapper;import pojo.User;public interface UserInfoMapper &#123; User selectById(int uid);&#125; UserInfoMapper.xml 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;!-- namespace写接口的全限定名称 --&gt; &lt;mapper namespace="mapper.UserInfoMapper"&gt; &lt;!-- id和接口的方法名称一致 --&gt; &lt;!-- 标签的输入参数和接口方法的输入参数类型一致 --&gt; &lt;!-- 标签的结果类型和接口方法的返回值类型一致 --&gt; &lt;select id="selectById" parameterType="_int" resultType="user"&gt; select * from dept where deptno=#&#123;deptno&#125; &lt;/select&gt; &lt;/mapper&gt; 测试 123456789101112131415public static void main(String[] args) throws IOException &#123; // 1.加载配置文件mybatis.xml Reader rd = Resources.getResourceAsReader("mybatis.xml"); // 使用工厂模式创建SqlSession SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(rd); //自动提交为true SqlSession Session = factory.openSession(true); //获取Mapper接口的实现类对象 mapper UserInfoMapper mapper = Session.getMapper(UserInfoMapper.class); User info = mapper.selectById(10); System.out.println(info);&#125; 使用注解实现 mapper代理要写mapper的接口和映射文件 可以写在一个接口中,在接口中使用注解减少工作量 UserInfoMapper2.java文件 1234public interface UserInfoMapper2 &#123; @Select("select * from dept where deptno = #&#123;deptno&#125;") User selectById(int uid);&#125; 高级映射 resultType: 结果集字段名称和属性名一致则映射成功; 结果集字段和属性名部分一致则部分映射成功; 结果集字段和属性名都不一致不会创建对象。 一对多12345678910111213141516171819&lt;!-- type:对象类型 orm --&gt; &lt;resultMap type="dept" id="deptMap"&gt; &lt;!-- 主键字段映射 --&gt; &lt;id column="deptno" property="deptno"/&gt; &lt;!-- 非主键字段映射 --&gt; &lt;result column="dname" property="dname"/&gt; &lt;result column="loc" property="loc"/&gt; &lt;!-- 封装结果到集合 property:属性 javaType:每个对象类型 --&gt; &lt;collection property="emps" ofType="emp" column="deptno"&gt; &lt;id column="empno" property="empno"/&gt; &lt;result column="ename" property="ename"/&gt; &lt;result column="job" property="job"/&gt; &lt;result column="hiredate" property="hiredate"/&gt; &lt;result column="mgr" property="mgr"/&gt; &lt;result column="sal" property="sal"/&gt; &lt;result column="comm" property="comm"/&gt; &lt;result column="deptno" property="deptno"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 一对一12345678910111213141516171819&lt;resultMap type="emp" id="empMap"&gt; &lt;id column="empno" property="empno"/&gt; &lt;result column="ename" property="ename"/&gt; &lt;result column="job" property="job"/&gt; &lt;result column="hiredate" property="hiredate"/&gt; &lt;result column="mgr" property="mgr"/&gt; &lt;result column="sal" property="sal"/&gt; &lt;result column="comm" property="comm"/&gt; &lt;result column="deptno" property="deptno"/&gt; &lt;!-- 封装结果到对象中 --&gt; &lt;association property="dept" column="deptno" javaType="dept"&gt; &lt;id column="deptno" property="deptno"/&gt; &lt;result column="dname" property="dname"/&gt; &lt;result column="loc" property="loc"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findEmpAndDept" resultMap="empMap"&gt; select * from emp left join dept on emp.deptno = dept.deptno &lt;/select&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeday10JSP]]></title>
    <url>%2Fblog%2F2018%2F09%2F06%2Fjavaeeday10JSP%2F</url>
    <content type="text"><![CDATA[转发和重定向转发 服务器端的行为 request.getRequestDispatcher(&quot;URL&quot;).forward(request, response); 客户端只发送一次请求 服务器端将该请求在内部实现共享(request,response) 重定向 客户端的 行为 response.sendRedirect(&quot;show.jsp&quot;); 客户端发送第一次请求, 服务器返回302状态码和新的请求路径(location); 客户端拿到该数据,向心得路径发送第二次请求 ServletContext application 域对象,作用域 整个应用程序有效,共享的数据(网站的在线人数) 不建议存放过多数据, getServletContext(); setAttribute(name, object); getAttribute(name); removeAttribute(name); 12345//创建ServletContentext数据ServletContext servletContext = getServletContext();servletContext.setAttribute(name, object);servletContext.getAttribute(name);servletContext.removeAttribute(name); 会话 会话可以代表与服务器端的一次连接。 通过三次握手域服务器建立连接，此时会话开始； 会话超时或者主动断开连接此时会话失效。 一次会话之内可以有多次请求和响应。 Cookie 和session会话跟踪技术: cookie: 一段保存于客户端的文本 服务器接收到请求后,创建cookie,返回给客户端 默认浏览器不关闭,,cookie有效 客户端每一次请求都会携带cookie信息 不安全,隐私度不高的数据 Cookie cookie = new Cookie(name, value); response.addCookie(cookie); 有效时长: 默认: 关闭浏览器,cookie失效 手动设置: cookie.setMaxAge(3600*24*365);//单位秒 获取:从request请求中获取 request.getCookies(); // cookie不止一个,获取全部cookie 遍历: getName() getValue() 123456789Cookie cookie = new Cookie("username", username);response.addCookie(cookie);cookie.setMaxAge(30);Cookie[] cookies = request.getCookies();for (Cookie c : cookies) &#123; if ("user".equals(c.getName())) &#123; System.out.println(c.getValue()); &#125;&#125; session (保存用户信息,实现登录验证) session保存于服务器,返回seesionID(自动生成) session 的标识: sessionId;(存放于cookie) 每一个用户单独拥有一个session 关闭浏览器session不会失效,但是sessionid会丢失 session :也是一个域对象 创建 HttpSession session = request.getSession(); 保存 session.setAttribute(&quot;username&quot;, username); 获取 session.getAttribute(&quot;username&quot;); 登录验证: 正常登录得到session 不正常时候,没有session 判断session为空,去登录页面 失效 默认: 30分钟 手动设置: session.setMaxInactiveInterval(3600);//单位秒 注销:立即失效 invalidate(); EL表达式和JSTL 使用EL表达式获取数据语法：”${标识符}“ EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回”” （注意，不是null，而是空字符串）。 EL表达式可以很轻松获取JavaBean的属性，或获取数组、Collection、Map类型集合的数据 获取域中的数据 12345&lt;% request.setAttribute("name","孤傲苍狼");%&gt; &lt;%--$&#123;name&#125;等同于pageContext.findAttribute("name") --%&gt; 使用EL表达式获取数据：$&#123;name&#125; 获取bean的属性 123456&lt;% Person p = new Person(); p.setAge(12); request.setAttribute("person",p);%&gt; 使用el表达式可以获取bean的属性：$&#123;person.age&#125; 获取对象中的对象的属性 123456789&lt;% Person person = new Person();Address address = new Address();person.setAddress(address);request.setAttribute("person",person);%&gt; $&#123;person.address.name&#125; 获取list集合中指定位置的数据 123456789101112131415&lt;% Person p1 = new Person(); p1.setName("孤傲苍狼"); Person p2 = new Person(); p2.setName("白虎神皇"); List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); list.add(p1); list.add(p2); request.setAttribute("list",list);%&gt;$&#123;list[1].name&#125; 迭代list集合 123&lt;c:forEach var="person" items="$&#123;list&#125;"&gt; $&#123;person.name&#125;&lt;/c:forEach&gt; 获取map集合的数据 123456789101112&lt;% Map&lt;String,String&gt; map = new LinkedHashMap&lt;String,String&gt;(); map.put("a","aaaaxxx"); map.put("b","bbbb"); map.put("c","cccc"); map.put("1","aaaa1111"); request.setAttribute("map",map);%&gt; &lt;!-- 根据关键字取map集合的数据 --&gt; $&#123;map.c&#125; //cccc $&#123;map["1"]&#125; //aaaa1111 迭代map集合 JSTL 导入jstl的jar包 过滤器 过滤请求和响应 应用场景: 全局编码设置 用户登录验证(首页,登录页面,登录处理servlet不能拦截) 将servletRequest强转为HttpServletRequest HttpServletRequest req =(HttpServletRequest) request; 获取请求的链接 String uri=req.getRequestURI(); 敏感词汇的过滤 图片上传后压缩 init()方法：这是过滤器的初始化方法，在Web容器创建了过滤器实例之后将调用这个方法进行一些初始化的操作，这个方法可以读取web.xml中为过滤器定义的一些初始化参数。 doFilter()方法：这是过滤器的核心方法，会执行实际的过滤操作，当用户访问与过滤器关联的URL时，Web容器会先调用过滤器的doFilter方法进行过滤。 destory()方法：这是Web容器在销毁过滤器实例前调用的方法，主要用来释放过滤器的资源等。 chain.doFilter(request, response);放行 监听器监听域对象自身的创建和销毁的事件监听器监听对象(request/session/application)的创建和销毁,以及属性的变化 监听application域, ServletContext,继承ServletContextListener 实现该接口中的contextInitialized和contextDestroyed方法, 启动服务器创建应用程序上下文时和关闭服务器销毁程序上下文时执行的操作。 监听 Session 域, HttpSession,继承HttpSessionListener 监听的是用户会话对象的创建和销毁事件 初始页面index.jsp，会发现控制台打印sessionCreated，关闭用户会话，这时会打印sessionDestroyed。 监听request域, ServletRequest,继承ServletRequestListener 启动项目，访问index.jsp?name=imooc，这里定义一个名为name的参数，参数值是imooc，提交请求 首先用户提交请求时，请求对象被创建，监听器监听到请求对象创建的事件，这时执行监听器的initialize方法，同时监听器获取到参数名为name的参数值并打印。因为request对象只在一次请求有效，所以服务器返回响应后请求对象便被销毁，这时执行监听器的destory方法。 监听域对象中属性的增加和删除的事件监听器 这一类监听器主要监听ServletContext、HttpSession和ServletRequest这三个域对象中属性的创建、销毁和修改的事件，要实现这三种监听器，就需要继承ServletContextAttributeListener、HttpSessionAttributeListener和ServletRequestAttributeListener这三个接口， Ajax AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） 点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 同步请求: 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。 异步请求 4.处理响应数据 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200: “OK” 404: 未找到页面 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 1234567//监听请求状态xhr.onreadystatechange=function()&#123; console.log(xhr.status);//状态码:200响应成功 if(xhr.readyState==4&amp;&amp;xhr.status==200)&#123; &#125;&#125; jQuery $.get(); $.post(); 12345678910function myFunction()&#123; loadXMLDoc("/try/ajax/ajax_info.txt",function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125; 123$.get("ajax?key="+val,function()&#123; &#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2Fblog%2F2018%2F09%2F05%2Fjavaeeday09jQuery%2F</url>
    <content type="text"><![CDATA[JQuery样式的修改 css(“样式名” , “属性值”) addClass(“类选择器名”) removeClass():删除类属性 1234567891011121314151617.red &#123; width: 200px; height: 200px; background: red;&#125;.green &#123; width: 300px; height: 500px; background: green;&#125;&lt;div&gt; &lt;/div&gt;$("div").addClass("green");$("div").removeClass("green")$("div").addClass("red"); 事件 与原生的大致相同,不用on 12345678910111213141516&lt;div onclick="togreen()"&gt;&lt;/div&gt;function togreen()&#123; $("div").css("background","green");&#125;$("div").click(function()&#123; $(this).css("background","green");&#125;);$("div").mouseover(function()&#123; $(this).css("background","pink");&#125;);$("div").mouseout(function()&#123; $(this).css("background","red");&#125;); onload事件 onload(): —–&gt; $(document).ready(fun());—–&gt; 简写$(); 12345&lt;script&gt; $(function()&#123; console.log($("div"))&#125;);&lt;/script&gt; 事件的绑定 on(“事件类型,事件类型”, 函数); off(“事件类型”) 123456789&lt;script&gt; $("div").on("click mouseover", function() &#123; // $(this).css("background", "blue"); console.log("123"); &#125;); $("div").off("mouseover");&lt;/scrip&gt; 服务器 性能强大的计算机(硬件) 操作系统(windows/Linux) 服务器软件(部署资源供外部访问) web应用程序(处理 浏览器端请求) 服务器软件 IIS 服务器:Microsoft 大型服务软件 weblogic:oracle服务器软件(支持13种动态网页开发技术) webphere: IBM大型服务器软件 apache: apache,开源软件基金会,开源 nginx: web服务器/反向代理服务器(分布式) Tomcat: Apache下的项目,开源,免费的web应用服务器 Tomcat 开源,免费web服务器 ,主要有Apache ,sun 以及其他进行开发和维护 需要jdk环境支持,能兼容最新的jdk. 下载 下载:https://tomcat.apache.org/download-80.cgi http://archive.apache.org/dist/ 安装 解压 目录 bin:可执行文件(启动startup,关闭shutdown Tomcat) conf:配置文件 lib: 类库,依赖的jar log.tomcat :日志信息 temp:临时文件 webapps: 项目目录 work: 工作的目录jsp页面处理, 检验:http://127.0.0.1:8080/ web应用程序 eclipse集成Tomcat 配置server环境 创建Tomcat服务器 配置Tomcat的目录和映射位置(servre locations use tomcat installation ,deploy path: webapps) 创建dynamic web project context root: 项目在Tomcat中的根目录(webapps下的目录名称) content directory:放置所有的资源都在该目录底下,应用程序中的目录(在磁盘中不真实存在) 对应root WebContent:资源文件的根目录 WEB-INF:该目录下的所有资源不能被外部直接访问 lib:存放jar包 web.xml:应用程序配置文件 xml:可扩展的标记语言 声明:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 123456&lt;!-- 约束(dtd/schema) xmlns: xml的命名空间(规定标签) schemaLocation: 约束文件的地址 .xsd:schema约束的路径 .dtd:dtd文件的约束路径--&gt; &lt;welcome-file-list&gt; 123456789&lt;!-- 欢迎文件列表(首页) --&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; servlet 运行于服务器端应用程序,必须实现servlet借口 接受和处理用户请求(http);对客户端进行相应 开发servlet 创建servlet类,实现servlet接口–&gt;继承HttpServlet(javax.servlet.http.HttpServlet;) 配置servlet路径 &lt;servlet&gt; &lt;servlet-name&gt; &lt;servlet-class&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt; 访问规则: 1234567891011121314151617&lt;servlet&gt; &lt;!-- 名称 --&gt; &lt;servlet-name&gt;user&lt;/servlet-name&gt; &lt;!-- 类的全限定名称 --&gt; &lt;servlet-class&gt;servlet.UserServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射(servlet对象和URL之间的映射) --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;user&lt;/servlet-name&gt; &lt;!-- 访问规则: /路径: http://localhost:8080/项目根路径/路径 /* : http://localhost:8080/项目根路径/任意路径 *.do: http://localhost:8080/项目根路径/任意路径.do --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 测试 http://localhost:8080/javaweb01/user http://localhost:8080/javaweb01/index.html 123456789&lt;form action="user.do" method="post"&gt; &lt;label&gt;用户名:&lt;/label&gt; &lt;input type="text" name="username"&gt; &lt;br /&gt; &lt;label&gt;密码:&lt;/label&gt; &lt;input type="password" name="password"&gt; &lt;br /&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 状态码 200:请求成功 302:重定向 4XXX:客户端的问题 404:文件没有找到 405:客户端异常 5XXX: 服务器异常 502: 503 HttpServletRequest 请求对象(请求行,请求头,请求体) get: 请求行 post:请求体 getParameter(name);获取名字获取提交的信息 getRemoteAddr();客户端的ip getRemotePort();客户端的端口 getMethod:获取请求的方式 HttpServletResponse 响应对象 1234//流PrintWriter writer = resp.getWriter();writer.println("success");writer.close(); 页面内容较多时,使用printwrite不方便, 解决:jsp 乱码问题: 原因:编码不一致 解决: 请求 统一使用utf-8; get:修改tomcat服务器tomcat (7之前)的conf/server.xml–&gt;URIEncoding 1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; post:req.setCharacterEncoding(“utf-8”); 响应 resp.setCharacterEncoding(“utf-8”); 浏览器需要以响应的编码的格式显示 1234//设置响应头信息//本质不是设置编码的//服务器给客户端响应的数据类型resp.setContentType(&quot;text/html;charset=utf-8&quot;); get请求,没有乱码, 8.0之后,tomcat 默认编码改为了utf-8(7–&gt; lanter1) post请求,出现乱码 域 实现数据的共享 request域 HttpServletRequest req; 作为域对象的时候,共享数据 req.setAttribute(name, value); req.getAttribute(name); req.removeAttribute(name); 作用域:一次请求内有效jsp jsp形式:html+java 本质:servlet eclipse编写jsp:preferences;修改编码 请求index.jsp页面 服务器翻译为index.jsp.java 将jsp中的标签通过响应的流的write方法写出. 编译index.jsp.class文件 java代码的编写需要用&lt;% java代码%&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday08]]></title>
    <url>%2Fblog%2F2018%2F09%2F02%2Fjavaeeday08%2F</url>
    <content type="text"><![CDATA[JavaScriptjavascript和java的一些区别：1). javascript是一个解释性语言,java是编译解释性语言 2). javascript是一个弱势语言，Java是一个强势语言 3). 在页面上引入的方式不同javascript代表用&lt;script&gt;引入，Java代码&lt;%&gt; 4). JS是基于对象，Java是面向对象。 JavaScript语言的组成：1234EcMAScript + BOM + DOM ECMAScript: 规定了一些语法，变量，for循环等等结构 BOM: Browser object Model 浏览器对象模型 DOM: Document object Model 文档对象模型 JavaScript与Html的结合方式(掌握)Javascript与HTML的结合方式有三种： 1.采用事件来调用，代码写在字符串中 &lt;button onclick = &quot;alert(&apos;大家好&apos;)&quot;&gt;点击&lt;/button&gt; 2.采用定义函数的方式: 用function来定义函数 function fun(){ alert(&apos;你好&apos;)} ; 3.采用外部js文件. 利用&lt;script src = &quot;a.js&quot;&gt;&lt;/script&gt;引入 JavaScript基本语法(掌握)定义变量 采用var关键字来定义.定义的变量的类型是由给定的值来决定的。 数据类型： undifined,表示未定义类型。 Number类型。代表了一切数字类型 String类型。字符串类型 Boolean类型。布尔类型 Function类型。函数类型. Null类型。 判断变量的类型 采用typeof 函数判断：typeof(a) ==”Sttring” 采用instanceof 运算符； 三大结构 顺序结构 选择结构 循环结构for ,while ,do…while 运算符 一元运算符 +(正号) - ++ – 二元运算符 +(加法) - * / % 三元运算符 ？ ： 等号 == 判断的是内容, === 全等于 ,判断类型和内容 类型的转换1. Number转String : 3 + &quot;&quot; 2. Number转Boolean ：在javascript中，非0为真，0为假。如果变量为null或者undefined，也为假. 3. String转Number: a. parseInt,parseFloat b. 乘以1即可 JavaScript 函数定义（掌握）函数的定义有三种方式： 1.采用function关键字来定义 2.采用匿名的方式来定义 3.采用new Function()的方式(了解,不推荐) 123456789101112131415function fun()&#123; alert("大家好") ;&#125;// fun() ;var a = function()&#123; alert("我是匿名函数") ;&#125;// a() ;var b = new Function("x","y","z","alert(x+y+z)") ;小括号中最后一个参数是函数体，之前所有的参数都是形参.// b(3,4,5) ; 函数的调用 没有重载的概念 函数调用的时候参数可以传递多个，可以和函数定义的形参个数不符合 如果函数重名了，那么调用的时候一定是调用最后一个，与参数无关。 函数的劫持 改变函数本身的作用.改变javascript的预定义的函数预定义好的功能 1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; //函数劫持:改变javascript的预定义的函数预定义好的功能 window.alert = function(x)&#123; document.write(x) ; &#125; alert(&quot;abc&quot;) ; /*var a = function()&#123; alert(&quot;1&quot;) ; &#125; a = function()&#123; alert(&quot;2&quot;) ; &#125;*/ //不是函数劫持 &lt;/script&gt; JavaScript 全局函数(掌握) isNaN (掌握)：用来判断变量是否是数字类型的字符串 NaN: not a Number ,不是一个数字 返回TRUE不是数字 parseInt,parseFloat eval(掌握): 把字符串转换成数字 a.主要执行字符串,将结果转换为数字 b.将json格式的字符串转换为json {&quot;a&quot;:&quot;中国&quot;,&quot;b&quot;:&quot;美国&quot;,&quot;c&quot;:&quot;日本&quot;} escape(): 编码 unescape(): 解码 encodeURI(): 对网址（URL）进行编码 decodeURI(): 对网址（URL）进行解码 1234567891011121314151617181920if(isNaN(a))&#123; alert("不是数字") ;&#125;else alert("是数字") ;-----------------alert(eval("3 + 10") + eval("2")) ;//15--------------------- var b = "中国" ;var c = escape(b) ;alert(c) ; //%u4E2D%u56FDalert(unescape(c)) ; //中国---------------------------------------var e = "http://www.sohu.com?a=中国&amp;b=美国" ;var f = encodeURI(e) ;alert(f) ; //http://www.sohu.com?a=%E4%B8%AD%E5%9B%BD&amp;b=%E7%BE%8E%E5%9B%BDalert(decodeURI(f)) ; JavaScript常用对象（掌握）Array对象 数组对象，进行数组操作 typeof(数组名):得到的是object var arr = new Array() ; //定义一个数组arr,初始长度为0 var arr1 = new Array(4) ; //定义一个数组arr1,初始长度是4 var arr2 = new Array(1,2,3,4,5) ; //定义一个数组arr2，初始化数据是1,2,3,4,5 var arr3 = [] ; //定义了一个数组，里面是空的var arr3 = [3,2,4,5] ; //定义了一个数组，同时初始化数据 定义方式 1.采用new的方式2.采用中括号[]来定义 **数组的长度可以随时改变** 特点： 1.javascript中数组的大小可以随时改变 2.javascript中数组的下标可以是任意对象。 12345678910111213141516171819202122232425262728var arr = new Array() ; //定义一个数组arr,初始长度为0var arr1 = new Array(4) ; //定义一个数组arr1,初始长度是4/*arr1[0] = 1 ; arr1[1] = 10 ; alert(arr1[2]) ; //弹出来undefined,没有初始化 alert(arr1[100]); //相当于定义了一个变量arr1[100],没有赋值*///-----------------------var arr3 = [] ; //定义了一个数组，里面是空的var arr3 = [3,2,4,5] ; //定义了一个数组，同时初始化数据//改变数组的的长度alert(arr4.length) ;//arr4.length = 100 ; //将数组的长度变为100//alert(arr4.length) ;//arr4[100] = 100 ; //将数组的长度变为101//alert(arr4.length) ;arr4.length = 2 ; //将数组的长度变为2，多于的数据将消失了//alert(arr4[2]) ; //弹不出原来的数据了，弹出来undefined//--数组下标的访问------------------var arr5 = ["中国","美国","日本"] ;arr5["中国"] = ["北京","上海","天津"] ;alert(arr5["中国"][0]) ; //北京 与java中数组的差别：a. Java中数组是有类型的，意味着一旦类型确定，则数组中所有的数据都是同一种类型。 javascript中数组时没有类型的，意味着数组中的数据可以存放任意类型 (不推荐,取出转换麻烦) b. java中数组的长度一旦确定就不能再更改了 javascript中数组的长度是可以变化的(扩大缩小都可以) 变长的两种办法 : 1) 指定length属性的值 2) 指定某个数组中元素的值 c. java中的数组的数据引用必须用下标引用，小标必须是整数. javascript中数组的数据引用可以用任意对象 方法 方法： 1.join() : 把数组的所有元素放入一个字符串. 默认用逗号连接 2.push() : 向数组的末尾添加一个元素 4.reverse() :反转 3.shift() : 删除并返回数组的第一个元素 4.sort() ; 排序 .默认同类型的数据相比较. 默认情况下先将能转换为number类型的字符串和number类型的放一起比较(转为string类型比较) 转换不成的作为一组进行比较 如果想按自己的规则进行比较，那么需要传递一个function类型的参数制定比较规则。 12345678910111213141516171819202122232425var arr = ["中国","美国","日本"] ;//alert(arr.join()) ; //默认用逗号连接alert(arr.join("")) ; //用空字符串连接arr.push("韩国") ;alert(arr.join()) ;arr.reverse() ;alert(arr.join()) ;alert(arr.shift()) ; //---------------------var arr1 = [3,8,"23","34",123,"abc","ab"] ;//alert(arr1.sort()) ; //123,23,3,34,8,ab,abc(转为string类型比较)alert(arr1.sort(function(a,b)&#123; //升序排序 //传递一个function类型参数，制定我们的比较规则 if(a *1 &gt; b*1) return 1 ; else return -1 ;&#125;)) ; String对象方法String对象的方法： substr(): 截取子字符串,两个参数，第一个参数是下标，第二个参数是截取的长度 substring(): 截取子字符串，两个参数，代表的是下标 charAt():拿到指定位置的字符 split():切割 fontcolor():使用指定的颜色显示字符串 fontsize(): link():将字符串显示为超链接 big(); bold();字体变粗(一次) 属性:length 12345678910var s = "abcdefg" ;//alert(s.substring(2,3)) ;//c//alert(s.substring(3,2)) ;//c当大于长度,按最大当为负数,按最小位置可相反// alert(s.substring(300,-200)) ; //abcdefgalert(s.substr(2,3)) ; //3是i长度，不是索引 cde Math对象 执行数学任务 ceil():向上取整 floor():向下取整 min(x,y):最小值 max(x,y):最大值 random():0~1之间的随机数(可以等于0，永远不能取得1) round(x):四舍五入 pow(x,y):x的y次幂 1234var a = 3.1;alert(Math.floor(a)) ; //3alert(Math.ceil(a)) ; //4alert(Math.round(a)) //3 Date对象 用于处理日期和时间 Date对象： 代表一个时间 方法： getXXX() : 拿到年月日,时分秒 12345678910var d = new Date() ;alert(d.toLocaleString()) ; //转换为11alert(d.getYear()) ; //返回的是 "当前年份-1900" 的值（即年份基数是1900）alert(d.getFullYear()); //获取正确的4位年份alert(d.getMonth()); //月:0-11alert(d.getDate()) ; //天alert(d.getDay()) ; //0-6;星期天位0alert(d.getHours()); 0-23alert(d.getMinutes());alert(d.getSeconds()); RegExp正则表达式对象 RegExp 对象正则表达式对象 写法： 1. new的方式 var r = new RegExp(&quot;ab&quot;) ; 2. 采用/正则表达式/ (推荐) var r = /ab/ ; 123456var reg = /(..)./ ; //括号表示子匹配，就是对结果进一步匹配var s = "abcde" ;alert(reg.test(s)) ; //测试字符串中是否包含正则表达式中所匹配的字符串,返回的是boolean类型的alert(reg.exec(s).length) ; //以数组的形式返回匹配的正则表达式的字符串 2alert(reg.exec(s)[0] + ":" + reg.exec(s)[1]) ; abc: ab(对abc再次进行匹配) 出现的问题innerHTML和innerText的区别 innerHTML必须是有开始标签和结束标签的标签对象才能使用 获取开始标签和结束标签之间的内容 innerText:获取的是文本 对于input 1234//拿到文本框中的内容var txt = form.username.value ; 姓名:&lt;input type="text" name="username"&gt;&lt;span id = "sname"&gt;&lt;/span&gt;&lt;br&gt; 案例标题栏的滚动1234567891011121314151617181920212223&lt;body onload="init()"&gt; &lt;script type="text/javascript"&gt; //示例：标题栏的滚动 function init() &#123; //1.拿到标题栏的文本 var title = document.title; //alert(title) ; //2.将文本字串转换为数组 var arr = title.split(""); //3.拿到数组的第一个元素，并从数组中删除 var first = arr.shift(); //4.将第一个元素添加到数组的最后 arr.push(first); //5.将数组再组合成一个字符串 title = arr.join(""); //6.将字符串再赋值回标题栏 document.title = title; //7.每隔1秒做一遍前6步 setTimeout("init()", 1000); &#125; &lt;/script&gt;&lt;/body&gt; 字体变变变1234567891011function fun()&#123; //1.拿到p标签对象 var p = document.getElementById("p") ; //2.拿到p标签对象的主体内容 var txt = p.innerHTML ; //innerHTML必须是有开始标签和结束标签的标签对象才能使用 //3.改变字体内容，再赋值回去 p.innerHTML = txt.big().big() ;&#125;&lt;p id = "p"&gt;大&lt;/p&gt;&lt;input type="button" value="变变变" onclick="fun()"&gt; 字体颜色随机变换123456789101112131415161718var arr = ["red","blue","green","yellow","#666666"] ;function fun1()&#123; //1.拿到p标签对象 var p = document.getElementById("p") ; //2.随机取得一个整数作为数组的下标 var index = Math.floor(Math.random()*arr.length) ; //3. 拿到p标签对象的主体内容 // var txt = p.innerHTML ; var txt = p.innerText ; //3.给p标签对象的主体内容改变颜色，并赋值回去 p.innerHTML = txt.fontcolor(arr[index]) ; // alert(p.innerHTML) ; setTimeout("fun1()",500) ;&#125;&lt;p id = "p"&gt;大&lt;/p&gt;&lt;input type="button" value="变变变1" onclick="fun1()"&gt; BOM browser object modal :浏览器对象模型。 浏览器对象：window对象。 Window 对象会在 或 每次出现时被自动创建。 windows对象window的属性 innerHeight: 返回文档显示区的高度 ( IE不支持) innerWidth: 返回文档显示区的宽度( IE不支持) 通用写法： 1. document.body.clientWidth 2. document.body.clientHeigh outerheight 包括了工具栏，菜单栏等的高度 outerwidth 包括滚动条的宽度 12345function init()&#123; var x = window.document.body.clientWidth ; var y = window.document.body.clientHeight ; alert(x + &quot;:&quot; + y) ;&#125; status：设置窗口状态栏的文本。 12345678910111213&lt;script&gt; function init() &#123; //拿到当前时间 var d = new Date(); //设置状态栏的文本 self.status = d.toLocaleString(); setTimeout("init()", 1000); &#125; &lt;/script&gt; &lt;body onload="init()"&gt; &lt;/body&gt; windows的三种对话框1)消息框 alert() ; 2)确认框 confirm() ;返回Boolean类型的值 3)输入框 prompt() ; 返回输入的字符串(了解) 123456789101112&lt;script&gt; window.alert("你好");while(true) &#123; if(confirm("你爱我吗？") == false) continue; break;&#125;var a = prompt("请输入年龄：", 12); //默认显示12alert(a);&lt;/script&gt; windows对象的计时器 setTimeout(): 隔一段时间调用某个函数(只调用一次),返回的是一个计时器(理解成一个手表)clearTimeout() ：销毁由setTimeout()产生的计时器2. setInterval(): 每隔一段时间调用某个函数(多次调用) clearInterval(): 销毁由setInterval()产生的计时器 windows的打开 self :等同于window对象 parent：是打开窗口的父窗口对象 opener：是打开窗口的父窗口对象。 frames[]: 数组类型，代表子窗口的window对象的集合,可以通过frames[索引]拿到子窗口的window对象。 2种情况下使用opener: 1.使用winodw.open()方法打开的页面 2.超链（里面的target属性要设置成_blank） 2种情况下使用parent: 1.iframe 框架 2.frame 框架 子窗口中的文本框中的数据传递到父窗口中的文本框中显示 使用open（）打开 12345678910//父窗口，使用open打开子页面function fun()&#123; window.open("sub.html") ;&#125;&lt;body&gt; &lt;input type="text" name="" id = "txt"&gt; &lt;input type="button" value="打开sub.html页面" onclick="fun()"&gt; &lt;a href = "sub.html" target = "_blank"&gt;打开sub.html页面&lt;/a&gt;&lt;/body&gt; 1234567891011121314151617//子窗口sub.html&lt;script type="text/javascript"&gt; //示例： 将子窗口中的文本框中的数据传递到父窗口中的文本框中显示 function fun()&#123; //1.拿到文本框中填写的数据 var v = document.getElementById("txt").value ; //2.拿到父窗口对象 var w = window.opener ; //3.拿到父窗口中的文本框对象 var txt = w.document.getElementById("txt") ; //4.将内容赋值给父窗口中的文本框对象的value属性 txt.value = v ; &#125;&lt;/script&gt;&lt;input type="text" name="" id = "txt"&gt;&lt;input type="button" value="传递子窗口的值到父窗口中的文本框" onclick="fun()"&gt; 使用框架 12345678910111213141516//父窗口function fun()&#123;//1.拿到文本框中填写的数据var v = document.getElementById("txt").value ;//2.拿到子窗口对象var w = window.frames[0];//3.拿到子窗口中的文本框对象var txt = w.document.getElementById("txt") ;//4.将内容赋值给父窗口中的文本框对象的value属性txt.value = v ;&#125;姓名：&lt;input type="text" name="" id = "txt"&gt;&lt;input type="button" value="传递数据到子窗口中" onclick="fun()"&gt;&lt;iframe src = "sub.html"&gt;&lt;/iframe&gt; 1234567891011121314//子窗口function fun()&#123;//1.拿到文本框中填写的数据var v = document.getElementById("txt").value ;//2.拿到父窗口对象var w = window.parent;//3.拿到父窗口中的文本框对象var txt = w.document.getElementById("txt") ;//4.将内容赋值给父窗口中的文本框对象的value属性txt.value = v ;&#125;&lt;input type="text" name="" id = "txt"&gt;&lt;input type="button" value="传递数据到父窗口中" onclick="fun()"&gt; 方法 close() : 关闭页面 12345function clo()&#123; window.close() ;&#125;&lt;button onclick="clo()"&gt;点击关闭页面&lt;/button&gt; open方法，是打开一个页面. window.open(URL,name,features,replace) URL 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 name 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 和 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 features 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 replace 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值： true - URL 替换浏览历史中的当前条目。 false - URL 在浏览历史中创建新的条目。 windows Features 窗口特征 channelmode=yes\no\1\0 是否使用剧院模式显示窗口。默认为 no。 directories=yes\no\1\0 是否添加目录按钮。默认为 yes。 fullscreen=yes\no\1\0 是否使用全屏模式显示浏览器。默认是 no。处于全屏模式的窗口必须同时处于剧院模式。 height=pixels 窗口文档显示区的高度。以像素计。 left=pixels 窗口的 x 坐标。以像素计。 location=yes\no\1\0 是否显示地址字段。默认是 yes。 menubar=yes\no\1\0 是否显示菜单栏。默认是 yes。 resizable=yes\no\1\0 窗口是否可调节尺寸。默认是 yes。 scrollbars=yes\no\1\0 是否显示滚动条。默认是 yes。 status=yes\no\1\0 是否添加状态栏。默认是 yes。 titlebar=yes\no\1\0 是否显示标题栏。默认是 yes。 toolbar=yes\no\1\0 是否显示浏览器的工具栏。默认是 yes。 top=pixels 窗口的 y 坐标。 width=pixels 窗口的文档显示区的宽度。以像素计。 1234function fun()&#123; window.open("sub.html","","width=200,height=200,status=no,titlebar=no,menubar=no,toolbar=no,resizable=0") ;&#125; 模态窗体 模态类型对话框：就是指除非采取有效的关闭手段，用户鼠标点或者输入光标一直停留在其上的 对话框。 非模态类型对话框：不会强制此特性，用户可以在当前对话框以及其他敞口间进行切换。 showModalDialog() (IE 4+ 支持) showModelessDialog() (IE 5+ 支持) window.showModelessDialog()方法用来创建一个显示HTML内容的模态对话框。 history对象 对象存储了访问过的页面 方法 描述 back() 加载 history 列表中的前一个 URL orward() 加载 history 列表中的下一个 URL go() 加载 history 列表中的某个具体页面 属性 描述 length 返回浏览器历史列表中的 URL 数量 location对象 掌握： href属性 12&gt; 2. reload()方法：重新加载本页面&gt; 事件常用事件 Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。 鼠标移动事件onmousemove(event) : 鼠标移动事件 event是事件对象。名字固定 onmouseover : 鼠标悬停事件 onmouseout : 鼠标移出事件 鼠标点击事件onclick 加载与卸载事件 img, 和widows onload ,onunload 聚焦与离焦事件 onfocus, onblur focus():获得焦点 12345678910111213function fun(obj)&#123; obj.style.border = "1px solid red " ; obj.style.backgroundColor = "#ff66ff" ; obj.style.color = "green" ;&#125;function fun1(obj)&#123; if(obj.value == "")&#123; alert("内容不得为空") ; //obj.focus() ; //获得焦点 &#125;&#125;&lt;input type="text" name="" onfocus = "fun(this)" onblur = "fun1(this)"&gt; 键盘事件onkeypress,onkeyup,onkeydown 1234567function fun(obj,e)&#123; //拿到按键的asc码 obj.value = e.keyCode ; &#125; &lt;input type="text" name="" onkeypress = "fun(this,event)"&gt; 提交与重置事件 onsubmit,onreset 位置:form表单的&lt;form&gt;标签内,必须要return onsubmit = “return check(this)” onreset = “return fun(this)” 1234567891011121314151617181920212223function check(form)&#123;//拿到文本框中的内容var txt = form.username.value ; //判断内容 if(txt == "")&#123; document.getElementById("sname").innerHTML = " &lt;font color = red&gt;* 姓名必须填写&lt;/font&gt;" ; form.username.focus() ; return false; &#125; return true ;&#125; function fun(form)&#123; alert("重置事件") ; return true ;&#125;&lt;form method="post" action="01-鼠标的单击事件.html" onsubmit = "return check(this)" onreset = "return fun(this)"&gt; 姓名:&lt;input type="text" name="username"&gt;&lt;span id = "sname"&gt;&lt;/span&gt;&lt;br&gt; &lt;input type="submit" value = "提交"&gt; &lt;input type="reset" value = "重置"&gt;&lt;/form&gt; 选择与改变事件 onselect = “fun(this)” onchange = “fun1(this.value)” 文本框: 内容发生改变,失去焦点 下拉框: 下标发生改变 onchange = “fun2(this.value,this.selectedIndex)” 多行文本框 123456789101112131415161718function fun(obj)&#123; alert(obj.value) ;&#125;function fun1(v)&#123; alert(v) ;&#125;function fun2(v,index)&#123; alert(v + ":" + index) ;&#125;&lt;input type="text" name="" onselect = "fun(this)" onchange = "fun1(this.value)" &gt;&lt;select onchange = "fun2(this.value,this.selectedIndex)"&gt; &lt;option value = "china"&gt;中国&lt;/option&gt; &lt;option value = "america"&gt; 美国&lt;/option&gt; &lt;option value = "japan"&gt;日本&lt;/option&gt;&lt;/select&gt; 事件句柄 (Event Handlers) 属性 此事件发生在何时… onabort 图像的加载被中断。 onblur 元素失去焦点。 onchange 域的内容被改变。 onclick 当用户点击某个对象时调用的事件句柄。 ondblclick 当用户双击某个对象时调用的事件句柄。 onerror 在加载文档或图像时发生错误。 onfocus 元素获得焦点。 onkeydown 某个键盘按键被按下。 onkeypress 某个键盘按键被按下并松开。 onkeyup 某个键盘按键被松开。 onload 一张页面或一幅图像完成加载。 onmousedown 鼠标按钮被按下。 onmousemove 鼠标被移动。 onmouseout 鼠标从某元素移开。 onmouseover 鼠标移到某元素之上。 onmouseup 鼠标按键被松开。 onreset 重置按钮被点击。 onresize 窗口或框架被重新调整大小。 onselect 文本被选中。 onsubmit 确认按钮被点击。 onunload 用户退出页面。 鼠标 / 键盘属性 属性 描述 altKey 返回当事件被触发时，”ALT” 是否被按下。 button 返回当事件被触发时，哪个鼠标按钮被点击。 clientX 返回当事件被触发时，鼠标指针的水平坐标。 clientY 返回当事件被触发时，鼠标指针的垂直坐标。 ctrlKey 返回当事件被触发时，”CTRL” 键是否被按下。 metaKey 返回当事件被触发时，”meta” 键是否被按下。 relatedTarget 返回与事件的目标节点相关的节点。 screenX 返回当个某事件被触发时，鼠标指针的水平坐标。 screenY 返回当个某事件被触发时，鼠标指针的垂直坐标。 shiftKey 返回当事件被触发时，”SHIFT” 键是否被按下。 js修改css 对象.style css样式有- 的,需要将-去掉,大写后面的第一个 123456789function fun()&#123; //拿到p标签对象 var p = document.getElementById("p") ; //定义p的样式 //p.style.color = "red" ; //p.style.border = "5px dashed green" ; p.style.backgroundColor = "red" ;&#125; 写一个css,类选择器(推荐) 123456789101112&lt;style type="text/css"&gt; .one&#123; color:red ; border:6px solid green ; cursor:hand; &#125;&lt;/style&gt;//拿到p标签对象var p = document.getElementById("p") ;p.className = "one" ;//对象会应用选择器的样式p.className = "" / "none"; //取消样式 省市联动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;script&gt; var arr = ["中国", "美国", "日本"];arr["中国"] = ["北京", "上海", "钓鱼岛"];arr["美国"] = ["纽约", "华盛顿", "旧金山"];arr["日本"] = ["东京", "大阪", "神户"];arr["北京"] = ["海淀", "朝阳", "昌平", "丰台"];arr["上海"] = ["浦东", "金山", "崇明", "浦西"];arr["钓鱼岛"] = ["钓鱼岛东", "钓鱼岛南", "钓鱼岛西", "钓鱼岛北"];arr["纽约"] = ["纽约1", "纽约2", "纽约3", "纽约4"];arr["华盛顿"] = ["华盛顿1", "华盛顿2", "华盛顿3", "华盛顿4"];arr["旧金山"] = ["旧金山1", "旧金山2", "旧金山3", "旧金山4"];arr["东京"] = ["东京1", "东京2", "东京3", "东京4"];arr["大阪"] = ["大阪1", "大阪2", "大阪3", "大阪4"];arr["神户"] = ["神户1", "神户2", "神户3", "神户4"];function init() &#123; //填充国家 fillData(arr, "country"); //填充省市 fillData(arr[arr[0]], "province"); //填充地区 fillData(arr[arr[arr[0]][0]], "area");&#125;function fillData(arr, id) &#123; //清空select选项 document.getElementById(id).options.length = 0; //添加选项 for(var i = 0; i &lt; arr.length; i++) &#123; //创建一个option对象 //第一种 /* var option = new Option() ; option.text = arr[i] ; option.value = arr[i] ;*/ //第二种 var option = new Option(arr[i], arr[i]); //将option对象添加到select中 document.getElementById(id).options.add(option); &#125;&#125;function changePro(coun) &#123; //添加省市 fillData(arr[coun], "province"); //添加地区 fillData(arr[arr[coun][0]], "area");&#125;function changeArea(pro) &#123; //改变地区 fillData(arr[pro], "area");&#125;&lt;/script&gt;&lt;body onload="init()"&gt; 国家： &lt;select id="country" onchange="changePro(this.value)"&gt;&lt;/select&gt; 省市： &lt;select id="province" onchange="changeArea(this.value)"&gt;&lt;/select&gt; 地区： &lt;select id="area"&gt;&lt;/select&gt;&lt;/body&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript重复]]></title>
    <url>%2Fblog%2F2018%2F09%2F02%2Fjavaeeday08js%E6%9D%8E%2F</url>
    <content type="text"><![CDATA[函数1234567891011121314151617181920212223242526function 函数名称(参数列表)&#123; 函数体&#125;无参无返回值:function calc()&#123; js…&#125;调用:calc();有参有返回值function calc2(a,b)&#123; return a+b;&#125;calc2(1,2);匿名函数function()&#123; js…&#125;//匿名函数创建和调用(function(a,b)&#123; console.log(a+b);&#125;)(1,2); 内置函数 parseInt();将字符串转换为整形的数据 parseFloat():将字符串转换为浮点数 isNaN(():是否是一个非数字(字符串数值,数值,false:是数值) eval():将字符串转换为js代码 对象window 表示浏览器窗口 直接定义全局的函数都是window的函数 window对象的函数或对象可以省略window关键字 属性 document:获取文档对象 innerheight:获取显示区高度 innerwidth:获取显示区的宽度 方法 open(url,窗口名字,弹出窗口的特征(位置,大小等)):打开窗口,返回一个window对象. close():关闭窗口 alert():警告框 confirm():确认框,返回boolean prompt: 输入框 setTimeout(function,delaytime): 延时一段时间后,执行函数只执行一次,返回number类型 clearTimeout(id);清楚timeout setInterval(function,delaytime):周期性执行,返回类型 clearInterval(intervalId);清除interval 12345678910111213141516171819202122232425262728console.log(window.innerHeight);console.log(window.innerWidth);//打开新窗口var newWindow =window.open("http://www.baidu.com","baidu","width=200px,height=200px,left=200px,top=200px");//关闭窗口newWindow.close();var bool = confirm("确认删除吗?");console.log(bool);var name = prompt("请输入您的姓名","张三");console.log(name);//只执行一次var timeoutId = setTimeout(function()&#123; console.log("boom");&#125;,2000);//取消timeoutclearTimeout(timeoutId);var i = 10;var id = setInterval(function()&#123; i--; console.log(i);&#125;,1000);clearInterval(id); document Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 方法 getElementById() 返回对拥有指定 id 的第一个对象的引用。 getElementsByName() 返回带有指定名称的对象集合 getElementsByTagName() 返回带有指定标签名的对象集合 date getFullYear()：年 getMonth()：月 getDate()：日 getHours()：时 getMinutes():分 getSecinds():秒 getDay():星期:0-6 1234567891011121314var date = new Date();var year = date.getYear();var year1 = date.getFullYear(); //完整年份var mon = date.getMonth(); //月份 0-11var dayofweek = date.getDay(); //星期 0-6var day = date.getDate();var hour = date.getHours();var min = date.getMinutes();var sec = date.getSeconds();var str = year1+"-"+(mon+1)+"-"+day+" "+hour+":"+min+":"+sec;//console.log(str);document.getElementById("div1").innerHTML = str; Location:封装当前的url的信息。 dom操作获取节点12345678910//通过id值获取元素节点 var oDiv = document.getElementById("div1"); //console.log(oDiv); var aDiv = document.getElementsByTagName("div"); //console.log(aDiv[0]); //通过class值获取元素 document.getElementsByClassName(""); //通过name属性值获取 document.getElementsByName(); 获取/修改元素节点文本 innerHTML:获取修改文本内容 innerText:获取修改文本内容(只当做普通文本处理，不能设置标签) 1234567//获取文本内容var val = oDiv.innerHTML;console.log(val);//设置内容oDiv.innerHTML="哈哈"; var val2 = oDiv.innerText;console.log(val2);oDiv.innerText="aa"; 获取/修改元素节点属性 节点对象.attrName=值 Class特殊: oDiv.className=”green”; 修改元素的样式1234节点对象.style.样式=值font-size---&gt;fontSizeoDiv.style.fontSize="20px"; 事件ui事件 load事件:加载事件 window.onload:页面加载事件,窗口的所有节点绘制完毕出发事件 scroll事件:滚动事件(document.onscroll) 鼠标事件 onclick:鼠标单击 ondblclick:鼠标双击,较短的事件点击二次,会调用单击事件 mouseover:鼠标的移入事件 mouseout:鼠标的移出事件 键盘事件 特点: 生效的前提,添加的事件在哪个节点焦点在该节点的时候时生效 keyup:键抬起的时候触发 文本框写入后给从服务器,用keyup,keydown 返回的是上一个 keydown:键按下的时候触发 document.keydown=function(){ if } onkeypress: 可打印字符时候触发,shift等功能字符不触发 回车的keycode=13 123456document.getElementById("input0").onkeyup = function(ev) &#123; if(ev.keyCode == 13) &#123; console.log("enter"); &#125; console.log(ev.key);&#125; 正则表达式 str.match(regex) 为null的时候,没有匹配上 regex.test(str) true: 匹配 false:不匹配 规则 /开始 /结束 开始 ^ 结束 $ \d 代表数字:[0-9}; \w 代表数字字母下划线 [0-9a-zA-Z_] . : 除了换行符之外的任意字符 {m}:出现m次 {m,}:出现至少m次 {m,n}:m-n次 ? :0-1次 + : 1-多次 * : 0-多次 [\u4e00 - \u9fa5]:汉字 json 本质:就是字符串,轻量级数据交互的格式 xml:可扩展的标记语言, 优点:格式严格 缺点:无用标签多 json:**键值对轻量级传输** 主流平台支持json: js对象格式的字符串: **key值必须有引号** java &lt;--&gt; json:fastjson(alibaba) / gson(google) / JSONArray / JSONobject JS对象 键值对,用:冒号连接, 用逗号,分隔多个属性 属性值key可以不使用引号 12345678&lt;script&gt; var jsonObj = &#123;name:'zs' ,age:12&#125;; var person=[&#123;name:'zs' ,age:12&#125;]; console.log(jsonObj); console.log(jsonObj.name); console.log(jsonObj.age); console.log(person[0].age);&lt;/script&gt; 区别 js是一个对象 json :字符串 js对象不要引号 json的key必须用引号 js对象不能传输 json用于传输 json和js对象的转化 js对象–&gt;json JSON.stringify(jsonObj); 123var jsonObj = &#123;name:'zs' ,age:12&#125;;var json2 =JSON.stringify(jsonObj);console.log(json2); json –&gt; js对象 JSON.parse(json); eval(“(“+json2+”)”); 12345var jso=JSON.parse(json2);console.log(jso);var jso2 = eval("("+json2+")");console.log(jso2); jQuery 原生JavaScript的函数库 使得HTML文档遍历和操作，事件处理，动画和Ajax更加简单 为啥使用? 对原生js封装,操作更加简单 对浏览器兼用很好处理 丰富的插件 下载和安装 下载:http://jquery.com/download/ 生产环境:compressed, production jQuery 3.3.1 开发环境,有空格回车:uncompressed, development jQuery 3.3.1 安装 js函数库的下载到本地 生产环境:.min.js 开发环境:js 1&lt;script type="text/javascript" src="src/jquery-3.3.1.slim.min.js" &gt;&lt;/script&gt; CDN: 内容分发网络 1&lt;script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/core.js" &gt;&lt;/script&gt; 使用基本语法 $(selector).action() $: jQuery的核心(jQuery 对象) selector:选择器 action :对象 jQuery对象和dom对象的区别 dom—&gt; jQuery对象 $(dom) jQuery —&gt;dom对象 jQuery[0] jQuery.get(0) 选择器基本选择器 id选择器 $(“#id”).action() 类选择器 $(“.class”).action() 标签选择器： $(“tag”) 通配选择器 $(“*”).action 组合选择器 并集 $(“sel1,sel2”).action 交集 $(“sel1sel2”).action 后代 $(“sel1 sel2”).action 属性 $(“[属性]”) 筛选器 基本筛选器 : 关键字 获取节点的关键字 :first :last :eq = :lt:&lt; :gt:&gt; :odd:奇数行 :even:偶数行 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; console.log($("li:first")); console.log($("li:last")); console.log($("li:eq(1)")); console.log($("li:lt(3)")); console.log($("li:gt(3)")); console.log($("li:odd")); console.log($("li:even"));&lt;/script&gt; 表单选择器 :text :password :radio等 操作内容 text():获取或修改内容 html(): 获取或修改内容 属性 attr(属性名, 属性值),一个查看,二个修改 prop(属性名,属性值) value: val() 样式 css(样式的名称,样式值) 遍历 jQuery对象.eq(i) each() $(this).attr 123456var aLi = $("li");//遍历li标签,修改index属性为内容aLi.each(function()&#123; $(this).attr("index",$(this).html());&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday07]]></title>
    <url>%2Fblog%2F2018%2F08%2F31%2Fjavaeeday07%2F</url>
    <content type="text"><![CDATA[什么是CSS css : Cascading Style Sheets 层叠样式表 给html添加样式 css的引入方式css 的优先级 行间样式&gt; 非行间样式 其他的就近原则 内联样式 style属性 (在 HTML 元素内部） 优先级最高 1&lt;p style="color: red;font-size: 30px;"&gt; 这是一个段落&lt;/p&gt; 内部样式 style标签 位于 &lt;head&gt;标签内部 123456&lt;style&gt; p &#123; color: red; font-size: 30px; &#125;&lt;/style&gt; 外部样式 文档和样式分离 位于 &lt;head&gt;标签内部 &lt;link rel=&quot;stylesheet&quot; href=&quot;css文件位置&quot;&gt; 推荐使用 1234567&lt;link rel="stylesheet" href="../css/css01.css" /&gt;-----css01.css-------------P&#123; font-size: 30px; color: gold&#125; css的基本语法 声明&gt; 样式名称: 样式值; 单个单词直接书写,多个单词或者汉字使用分号引起来 颜色 单词 6位16进制数据表示颜色(二位相等时可以使3位) #000: 黑色 # fff:白色 RGB 123456&lt;style type="text/css"&gt; p&#123; color: #008000; font-family: "楷体"; &#125;&lt;/style&gt; css的选择器 标签选择器 标签{ 样式: 值 ;….} 12345&lt;style type="text/css"&gt; h1 &#123; color: #0f0; &#125;&lt;/style&gt; id选择器 不能复用 1234567&lt;p id="p1"&gt;段落&lt;/p&gt;&lt;style type="text/css"&gt; #p1 &#123; color: cyan; &#125;&lt;/style&gt; 类选择器 1234567&lt;p class="p3"&gt;段落&lt;/p&gt;&lt;style&gt; .p3 &#123; color: steelblue; &#125;&lt;/style&gt; 通配选择器 * :指页面中所有的元素 12345&lt;style&gt; * &#123; margin: 0; &#125;&lt;/style&gt; 组合选择器 并集选择器 1234567h2,.p1&#123; color: green;&#125;h2class='p1'的标签都会改变 交集选择器 12345h2.red&#123; color:red;&#125;&lt;h2 class="red"&gt;标题2&lt;/h2&gt; 后代选择器 空格分开 1234p span&#123; color: red;&#125;&lt;p&gt; 白日依山尽 ,&lt;span&gt;黄河&lt;/span&gt;入海流. &lt;/p&gt; 属性选择器 标签中只有一个有特有属性:[]属性名]{} 多个: [属性名=”值”] 12345678&lt;style&gt; [name]&#123; border:; &#125;&lt;/style&gt;&lt;input type="text" name="username" /&gt;&lt;input type="password" /&gt; 12345678[name="pwd"]&#123; border:1px solid red;&#125;&lt;input type="text" name="username" /&gt;&lt;input type="password" name="pwd" /&gt; 常见的css样式文本样式 颜色: color 文本对齐方式: text-align:(水平方向) line-height:行高 123color:gray;text-align: center;line-height: 30px; 文字样式 font-size: 字体大小; 具体像素 百分比(对比父级) font-family:字体类型(不同类型,逗号隔开) 先英文 后中文 font-weight:字体的权重 normal : 默认值。正常的字体。相当于 400 。声明此值将取消之前任何设置 bold : 粗体。相当于 700 。也相当于 b 对象的作用 bolder : 比 normal 粗 lighter : 比 normal 细 100-900 宽高样式 width: 宽 height:高 px % 使用百分比需要确定父级的宽高 背景样式 background-color:背景颜色; background-image:背景图片 background-repeat:背景重复 repeat : 默认值。背景图像在纵向和横向上平铺no-repeat : 背景图像不平铺repeat-x : 背景图像仅在横向上平铺repeat-y : 背景图像仅在纵向上平铺 background-position:背景定位 1234background-color: aliceblue;background-image: url(../img/cj0.jpg);background-repeat: no-repeat;background-position: 100px, 100px; 列表样式 list-style-type: 列表前的图形 none; 1234567ul li&#123; list-style-type: none;&#125;&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 浮动样式 给一个标签添加浮动后,会脱离标准文档流, left浮动:挨着父级容器的左边框或者已经浮动的容器的右边框停止浮动 子元素的浮动之和不能超过父级的大小 盒子模型 夏敏属性都分为上下左右四部分 可以简写: 4个:顺时针 上 右 下 左 2个: 上下 左右 1个: 上下左右 边框(border)内边距(padding) 边框和真实内容的间距 居中margin:0 auto；在不同场景下生效条件如下： **块级元素**：给定要居中的块级元素的宽度。 **行内元素**：①设置display:block；②给定要居中的行内元素的宽度。（行内元素设置成块级元素后可以对其宽高进行设置） **行内块元素**：设置display:block。（如input、button、img等元素，自带宽度可以不用设置其宽度） JavaScript 弱类型 动态类型 基于对象(原型) 的直译性变成语言 类型用var表示所有类型 函数定义1234567// 无参无返回值function func()&#123; console.log(1);//控制台输出&#125;//调用func(); 123456//带参数//1. 参数不用写类型//2. 个数可以不一致，按顺序取，多的不用function func2(a,b)&#123; console.log(a+b);&#125; 1234567891011//带返回值//returnfunction func3(a,b)&#123; return a+b;&#125;//使用var c = func3(1,20);//console.log(c); 事件调用方法 onclick();]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday06]]></title>
    <url>%2Fblog%2F2018%2F08%2F30%2Fjavaeeday06%2F</url>
    <content type="text"><![CDATA[html介绍 超文本标记语言(hyper text markup language) 展示的信息超过了文本,不仅仅是文本,还可以是音频,视频等. 超文本: 展示的内容更加丰富(文本,音频,图像,视频,链接等) 标记语言:html写的是标记 网页: html文档相当于网页 html文档: 标签和文本内容组成 写html 文档就是在写标签 1991年/1999年 4.0 版本 2009年 5.0版本 H5 audio video canvas 语义化布局标签 html的作用软件开发架构 B/S: 浏览器/服务器 http:超文本传输协议(公开协议),数据明文传输,用于html资源传输 https:加密传输协议:https=http+ssl证书 C/S: 客户端/服务器 优点: 安全性略高 本地缓存数据,效率高 缺点: 占据存储 碎片化,维护成本高 B/S开发必备条件 协议:http/https url:统一资源定位符(路径) 资源文件: html,图片,视频等 html标签及规范 标签: 一对尖括号 和 关键字组成:&lt;html&gt; 书写规范 标签一般成对存在, 开始标签 和 结束标签如:&lt;html&gt; 内容&lt;/html&gt; 标签允许正确嵌套,但是有且只有一个根标签&lt;html&gt; 123456&lt;html&gt; &lt;head&gt;&lt;/head&gt;&lt;/html&gt;标签允许嵌套&lt;html&gt;是html语言的根标签,只能有一个 开始标签内部可以写属性,属性值必须使用双引号 123&lt;html&gt; &lt;p align = "center"&gt;hello html&lt;/p&gt;&lt;/html&gt; 标签不区分大小写,但是建议使用小写 允许存在不成对的标签,比如空标签(没有属性的) 123&lt;br /&gt;&lt;hr /&gt;&lt;input /&gt;: 不是空标签 html的基本格式编写html文档 编写一个以htm/html结尾的文件 编写 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;!--注释:编码:样式,js,元数据信息等--&gt; &lt;head&gt; &lt;!-- 文档标题信息,收藏夹默认名称,--&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; html常见标签标题&lt;h*&gt; h1 ~ h6 : 黑体,加粗,换行的效果, 起强调作用 用户: 醒目 搜索引擎: 添加索引, 段落标签&lt;p&gt; 区分段落内容,默认有换行效果. 换行标签 空标签: &lt;br /&gt;换行 水平线&lt;hr /&gt; width: 可以设置餐长度; 1&lt;hr width="100px" /&gt; 1234&lt;h1&gt;悯农&lt;/h1&gt;&lt;hr width="100px" /&gt;&lt;p&gt;锄禾日当午,汗滴禾下土.&lt;/p&gt;谁知盘中餐,粒粒皆辛苦.&lt;br /&gt; 超链接&lt;a&gt; href: 代表链接资源(url): target: 调整链接目标的打开方式 _blank:新标签页打开链接的内容 _self:(默认),覆盖当前的标签页 _paraent: 父集窗口打开 _top:顶级窗口打开 网络资源 网络资源使用http协议访问 12&lt;!--网络资源http协议访问:别人服务器上的资源--&gt;&lt;a href="https://www.baidu.com/" target="_blank"&gt;百度&lt;/a&gt; 本地资源 相对路径 以当前路径为参考, 同级:直接写文件名 不同级:../ 1234&lt;a href= "a.html"&gt;本地a.html&lt;/a&gt;&lt;a href= "html/a.html"&gt;本地a.html&lt;/a&gt;&lt;a href="../index.html"&gt;&lt;/a&gt;&lt;a href="#"&gt;&lt;/a&gt; 绝对路径 锚链接 # 代表通过id寻找 id : 标签的唯一标识 12&lt;h1 id ="minnong"&gt;悯农&lt;/h1&gt;&lt;a href="#minnong"&gt;悯农&lt;/a&gt; 图片&lt;img&gt; &lt;img /&gt; 一般只设置宽高的一个 src: 设置图片的url; 本地 1234​```html&lt;img src="img/478.jpg" width="300px" alt="图片" title="图片" /&gt;​ 12345- 网络 ```html &lt;img src=&quot;http://pic19.nipic.com/20120328/5304880_152355292000_2.jpg&quot; width=&quot;150px&quot;/&gt; width:设置图片宽 height:设置图片的高 alt: 图片无法正确显示时,用于提示 title: 鼠标悬停时,用于显示 列表标签无序列表&lt;ul&gt; 菜单栏 ul:无序列表 li:列表项 123456&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 有序列表&lt;ol&gt; top榜 ol: 有序列表 li: 列表项 123456&lt;ol&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ol&gt; 自定义列表 直接显示列表项 dl:自定义列表 dt:列表项 dd:不是dt的子标签,与dt同级,对dt进行解释,有缩进效果. 123456&lt;dl&gt; &lt;dt&gt;123&lt;/dt&gt; &lt;dd&gt;456&lt;/dd&gt; &lt;dt&gt;qwe&lt;/dt&gt; &lt;dt&gt;asd&lt;/dt&gt;&lt;/dl&gt; 表格 &lt;table&gt;:表格的根标签 thead:表头,**加粗效果**`&lt;th&gt;` tbody:表体,正文信息 tfoot:表脚 ,统计信息 不声明thead,tfoot:默认放入到tbody中. border: 边框 cellspacing:单元格的距离 cellpadding:单元格的内边距(内容和边框的距离):框变大. tr: 行 bgcolor: 一行的颜色 td: 列 colspan: 合并行 rowspan:合并列 aling: 默认left/ center/ right 1234567891011121314151617181920212223&lt;tbody&gt; &lt;tr&gt; &lt;td&gt;第一列&lt;/td&gt; &lt;td colspan="2"&gt;第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;第一列&lt;/td&gt; &lt;td&gt;第二列&lt;/td&gt; &lt;td&gt;第三列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第二列&lt;/td&gt; &lt;td&gt;第三列&lt;/td&gt; &lt;/tr&gt;&lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;表脚&lt;/td&gt; &lt;td&gt;表脚&lt;/td&gt; &lt;td&gt;表脚&lt;/td&gt; &lt;/tr&gt;&lt;/tfoot&gt;&lt;/tbody&gt; 表单标签&lt;form&gt; http请求: 组成: 请求行 :请求路径 协议 请求体 :key/value(页面内容类型,编码,长度等) 请求体(可选的): 用户发送的数据 get请求:没有请求体;传输参数在url后 ?user=zs &amp; password =123 get较小数据(1k) 不能使用在上传情况下 post请求:参数在请求体中 action : 动作(服务器的url) method:提交方式 表单项&lt;input /&gt;type 控制显示的格式 text: 文本输入框 password: 密码框 button: 按钮 submit:拥有提交表单权限的按钮 radio:单选按钮 作为一组的时候:name值要一致; 默认选中:出现checked属性 checked=”checked” checked=”” checked checkbox:多选框 作为一组的时候:name值要一致; select:写key(name) option:写值(value) value不写,值为选中的文本内容 hidden:隐藏域 不会显示在页面上,但是会传输 file:文件上传 reste:重置 &lt;textarea&gt; rows:行 cols:列 value 控制值 name 相当于key 1234567891011121314151617181920212223242526272829303132&lt;!--get表单--&gt;&lt;form action="a.html" method="get"&gt; 账户名:&lt;input type="text" name="username" /&gt; &lt;br /&gt; 密 码:&lt;input type="password" name="password" /&gt;&lt;br /&gt; 性别:&lt;input type="radio" name="gender" value="men" checked="checked"/&gt; 男 &lt;input type="radio" name="gender" value="women"/&gt; 女 &lt;br /&gt; 爱好: &lt;input type="checkbox" name="hobby" value="sleep" checked="checked"/&gt; 睡觉 &lt;input type="checkbox" name="hobby" value="eat"/&gt; 吃饭 &lt;input type="checkbox" name="hobby" value="study"/&gt; 学习 &lt;br /&gt; 省份: &lt;select name="province"&gt; &lt;option value="bj"&gt;北京&lt;/option&gt; &lt;option value="sh"&gt;上海&lt;/option&gt; &lt;option value="cd"&gt;成都&lt;/option&gt; &lt;/select&gt;&lt;br /&gt; &lt;!--隐藏域--&gt; &lt;input type="hidden" name="code" value="1"/&gt;&lt;br /&gt; &lt;!--文件上传--&gt; &lt;input type="file" name="filename" /&gt;&lt;br /&gt; &lt;!--多行文本--&gt; &lt;textarea name="comment" rows="10" &gt;请在此处输入文本...&lt;/textarea&gt; &lt;br /&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt; 其他标签 div(块级标签) 默认样式:和父级容器宽度褒词一致,高度默认为0 块级元素:默认不和其他元素共享一行 div+scc用于布局页面 span(内联元素) 用于标记 内联元素:可以嵌入到其他标签中;能够和其他标签共享一行 元素:从标签的开始和内容到结束标签 实体 html中添加空格的时候,第一个有效果 超过一个都当作只有一个空格. 实体名称对大小写敏感！ 显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160; &lt; 小于号 &amp;lt; &amp;#60; &gt; 大于号 &amp;gt; &amp;#62; &amp; 和号 &amp;amp; &amp;#38; “ 引号 &amp;quot; &amp;#34; ‘ 撇号 &amp;apos; (IE不支持) &amp;#39; ￠ 分（cent） &amp;cent; &amp;#162; £ 镑（pound） &amp;pound; &amp;#163; ¥ 元（yen） &amp;yen; &amp;#165; € 欧元（euro） &amp;euro; &amp;#8364; § 小节 &amp;sect; &amp;#167; © 版权（copyright） &amp;copy; &amp;#169; ® 注册商标 &amp;reg; &amp;#174; ™ 商标 &amp;trade; &amp;#8482; × 乘号 &amp;times; &amp;#215; ÷ 除号 &amp;divide; &amp;#247;]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday05]]></title>
    <url>%2Fblog%2F2018%2F08%2F29%2Fjavaeeday05%2F</url>
    <content type="text"><![CDATA[jdbc开发开始 新建java工程 新建lib文件夹,用来放library文件; 导入jdbc的实现类(数据库的jar) 右键jar—&gt; buildPath —-&gt; add to build path 连接数据库 注册驱动,Drivermanager管理具体的驱动程序,实现对底层屏蔽,对开发人员提供统一的访问 建立连接 url : jdbc:公共协议+子协议+ip地址+数据库名字 user: 用户名 password: 密码 发送sql Statement对象:实现sql发送 Statement statement = connection.createStatement(); statement.executeQuery(sql);//查询语句,返回一个结果集 statement.executeUpdate(sql); //增删改,DDL,返回影响的行数## statement.executeBatch();//批处理,返回int[] 处理响应结果 ResultSet底层维护了一个指向结果集的游标 程序中每次读取一行,一个一个读(游标指向行的(字段)信息) next():游标向下,返回boolean类型,true有数据 getInt(String str):通过字段名称获取 1ResultSet result = statement.executeQuery(sql);// 查询语句,返回一个结果集 释放资源12345678910111213141516finally &#123; try &#123; if(connection!=null) &#123; connection.close(); &#125; if(statement!=null) &#123; statement.close(); &#125; if(result!=null) &#123; result.close(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 常见API详解DriverManager (java.sql.DriverManager) 注册驱动只有registerDriver(); 提供驱动的基础服务,对驱动实现细节进行屏蔽 注册加载驱动,用于获取连接 123456789101112public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125;&#125; 加载驱动的方式 推荐使用类加载,只注册一次 创建Driver对象,注册了二次驱动 123import com.mysql.jdbc.Driver;DriverManager.registerDriver(new Driver()); 类加载,使用静态代码块 1Class.forName("com.mysql.jdbc.Driver");// 静态代码块 Connection 代表客户端程序与数据库的连接 与数据的交互都需要依赖于此连接 方法: createStatement(): prepareStatement(sql); setAutoCommit(false); commit(); rollback(); getMetaData();获取连接的元数据信息,和连接相关的数据(元数据:解释数据的数据) getDatabaseProductName():数据库产品的名字 getDriverName():获取驱动的信息 getURL(): 获取连接的URL; 1234567891011121314151617// jdbc:公共协议+子协议+ip地址+数据库名字// ? 参数// useSSL=true SSL(Secure Sockets Layer 安全套接层),// 及其继任者传输层安全(Transport Layer Security,TLS)是为网络通信提供安全及数据完整性的一种安全协议Connection connection = null;connection = DriverManager.getConnection( "jdbc:mysql://localhost:3306/bd1807?useSSL=true", "root", "123456");DatabaseMetaData metaData = connection.getMetaData();metaData.getDatabaseProductName();//数据库产品的名字System.out.println(metaData.getDriverName());//获取驱动的metaData.getURL();// 能得到connection,说明数据库已经连接System.out.println(connection); 1234DatabaseMetaData metaData = connection.getMetaData();metaData.getDatabaseProductName();//数据库产品的名字System.out.println(metaData.getDriverName());//获取驱动的信息metaData.getURL(); statement executeQuery(sql); // 查询语句,返回一个结果集 executeUpdate(sql); //增删改,DDL,返回影响的行数 executeBatch(); //批处理,返回int[] ResultSet 代表返回结果的结果集 底层维护游标 next():移动游标获取每一行数据 getMetaData(): 获取结果集的元数据 getColumnCount():获取结果的列 getColumnName(int column):获取对应列的名字 遍历的时候,得到字段的名字,通过反射,获得属性Field,赋值封装到对象 方法 boolean next(): 向前移动游标(遍历一行) getInt(“字段名”); getString(“字段名”) 分层开发 实现解耦 dao层(data access obeject) 1. 接口 2. 实现类]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday04]]></title>
    <url>%2Fblog%2F2018%2F08%2F28%2Fjavaeeday04%2F</url>
    <content type="text"><![CDATA[视图 数据库对象,它是一个虚拟表,底层并非以键值形式保存数据,在执行过程中动态从基表中获取数据(视图以表为底层来查询) 增删改视图的时候,表的数据也会修改 视图实际上表的上层结构,表的映射. 视图的基本语法创建12345678# 创建视图create view view_nameasselect * from emp where deptno =10# 执行增删改查操作和表一致select * from view_name;update view_name set sal =2500 where empno = 7782; with check option: 保护视图数据,只能在视图范围之内进行数据的修改 修改视图会修改底层基表的数据 视图一般只执行查询,不执行增删改 12345678910# 只能在视图的范围内修改create or replace view view_nameasselect * from emp where deptno =10 with check option;# 成功update view_name set sal =2500 where empno = 7782;# 失败update view_name set deptno=20 #1369 - CHECK OPTION failed 'bd1807.view_name' 销毁 drop view view_name; 视图的优点 安全性:保密敏感数据,(视图中不给出敏感信息) 高效性:提高查询效率 定制化数据: 可以将多张表中经常展示数据放置在视图中快速查询(可以多张表联合查询放入视图) 索引 提升查询效率而创建数据结构 不填加索引,全表扫描 INNODB本身存储的就是以树的形式. 树的深度越浅,检索越好,尽量平衡 索引的分类 B-Tress索引: mysql使用B+Tree:方法来卫华索引列数据 B+树是一个多路搜索树 不同的存储引擎对索引的存储策略不一致 myisam:叶子节点中保存记录的地址 innodb:叶子节点中直接保存相应数据 位图索引 哈希索引 创建 普通索引 12345678910#根据ename 查询记录# 不适用索引explain select * from emp where ename = 'scott'type: ALL //最慢all(全表扫描),最好能达到 reg ,最好 systemrows: 14# 普通索引create index index_ename on emp(ename);type: refrows: 1 唯一索引 create unique index index_name on 表(字段) 全文索引 空间索引 复合索引: 多列作为索引字段 on 表(字段,字段) 删除1drop index 名字 on 表 索引的选择 索引需要单独的文件来保存维护 表数据发生变化需要维护索引表 适合添加索引 表 表的数据量足够大(10万条左右) 增删改操作较少(3%~%5) 字段 高基数列(不一样的数据较多的:高基数) 索引的说明 索引不适合添加过多 经常作为查询条件的列适合作为索引 有些特殊情况下,索引会失效 如: 给enamet添加索引后, ename like ‘%s%’,包含的情况,走的是全表 数据库的设计数据库设计的含义 查询和项目的(基础)基石,数据库的优化的前提就是数据库的设计. 数据库设计步骤 需求分析 概念结构设计:E-R模型图 关系模型: 将ER图转换为表,设置外模式 物理设计: 调试 运行和维护 数据库设计的范式 1NF: 所有域都原子性的,域中的数据不可分割 2NF: 非主键字段必须与组件相关(每张表只描述一列事务),而不能与主键部分相关(联合主键),降低数据的冗余 3NF:所有的非主键必须与主键直接相关,非主键字段之间不直接相关 E-R图(实体关系图) 客观世界的抽象的模型展示 实体: 矩形框 关系: 菱形框 属性: 椭圆形框 连线: 实体之间的关系 1对1: 个人信息 —- 档案 外键添加唯一约束 主键作外键 1对多(多对1): 在多的一方添加外键 多对多: 添加第三张关系表 设置联合主键和外键 将多对多的关系独立出一张表 表里面联合主键和二个表的主键作为外键 数据库的优化sql 优化: 尽量减少 的使用( 转换为列名, 然后在查询) 索引失效的情况 索引列不要使用 is not null /is null 索引列上不要使用函数 索引列上不要计算 索引列不要使用not(!= / &lt;&gt;) 索引列不要使用or(union 替换) 索引列不要使用包含(like ‘%s%’) 用exists 替代 in ,用not exists 代替not in 二者的选择: exists 先执行主查询 in先执行的子查询 先过滤后关联 备份和还原 备份 mysqldump -uroot -proot dbname &gt; d:/back.sql 还原 mysql -u root -p &lt; c:/bac.sql mysql.exe : 安装 mysqld.exe: 安装和卸载mysql服务 mysqld -remove mysql mysqld -installed JDBC 数据库连接的技术(Java Data Base Connectivity) jdbc 由一套接口组成,提供了关系型数据库统一访问 驱动则是数据库厂商对jdbc接口的具体实现,开发人员只需要学会jdbc接口的调用,导入相应驱动实现就可以实现对不同数据库的操作 实现jdbc开发: jdbc接口 + 数据库的驱动 jdbc driver manage: 对底层不同数据库的调用,对上提供统一的管理 jdbc开发步骤 Driver Manage:注册和管理驱动 建立连接(java app —-&gt; mysql serverTCP) 发送sql命令给数据库服务器 接收数据库响应处理结果集 释放资源(连接资源)]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday03]]></title>
    <url>%2Fblog%2F2018%2F08%2F27%2Fjavaeeday03%2F</url>
    <content type="text"><![CDATA[连接查询 子查询 联合查询 事务 存储过程 函数 编码问题 高级查询关联查询（连接查询） 查询员工编号为 7788 的员工姓名 和所在的部门的名称 内连接 select where inner join …on… inner join …. using(通用列（连接字段）)： 通用列的名称要一样 不会出现二次通用列（去除重复的字段） 1234567891011121314# 查询员工编号为 7788 的员工姓名 和所在的部门的名称select empno, ename,dname from emp,dept where empno=7788 and emp.deptno = dept.deptno# 内连接select * FROM emp inner join depton emp.deptno = dept.deptno# 内连接select * from empinner join deptusing(deptno) 特点 关联表中都出现的字段值最终才能出现在结果集中 内连接与连接顺序无关 内连接不分主从表 外连接 有主从表之分 依次遍历主表中的记录，与从表记录进行匹配 如果匹配，连接显示 如果不匹配，以null 填充 左外连接 ：left[outer] join …on 前面是主表，后面是从表 右外连接： right[outer] join … on 前面是从表，后面是主表 1234567891011121314151617# 左外连接: 14select * from empleft join depton emp.deptno = dept.deptno# emp 当作主表， dept当作从表# 依次遍历主表的记录# 根据条件匹配从表记录# 显示查询的结果# 左外连接: 15select * from deptleft join empon emp.deptno = dept.deptno# dept是主表 ，# 主表仍要遍历，虽然从表没有数据 等值连接自然连接natural join（都是等值连接) 不需要声明某个字段之间相等 是一种特殊的等值连接 自然连接肯定是等值连接 等值连接不一定是自然连接 12# 自然连接select * from emp natural join dept; 自连接 可以将自身表的一个镜像当作另一个表来对待，从而能够得到一些特殊的数据。 123456# 查询所有员工和他的上级领导# 自连接select e1.ename ,e2.ename from emp e1,emp e2 where e1.mgr = e2.empno# 外连接select emp.empno, emp.ename ,e1.ename from emp left join emp e1 on emp.mgr = e1.empno 子查询（嵌套查询） 将一个查询结果当作另外一个查询的条件或表达结果集 是最接近思考方式，最自然的查询 单行子查询 子查询的返回结果只有一条记录 > &lt; = &lt;&gt; 等等 12345# 查询大于scott 薪水的员工信息select * from emp left join depton emp.empno= dept.deptnowhere emp.sal&gt; (select sal from emp where ename='SCOTT') 多行子查询 子查询的返回结果有多条记录 in any = any ： 相当于 in > any : 大于最小值 &lt; any ： 小于最大值 all > all: 大于最大值 &lt;all: 小于最小值 123456789101112131415# 查询员工的工资在20号部门的工资内且不在20号部门SELECT * FROM emp WHERE sal IN ( SELECT DISTINCT sal FROM emp WHERE deptno = 20 ) AND deptno &lt;&gt; 20 # 查询20号部门除了工资最高员工 的 员工信息select * from emp where sal&lt;any( select distinct sal from emp where deptno=20)and deptno=20 # 查询大于20号部门的平均工资的20号部门的员工信息select * from emp where sal&gt; (select avg(sal) from emp where deptno =20)and deptno =20 12345678910 # 查询大于所在部门的平均工资的员工信息SELECT * FROM emp WHERE sal &gt; ( SELECT avg( sal ) FROM emp e2 GROUP BY deptno HAVING emp.deptno = e2.deptno ) ;1. 主查询遍历整个emp表2. 主查询读取某一条记录的deptno值，将该值交给子查询3. 子查询根据主查询的传来的deptno值，查询出指定部门的平均工资然后将整体结果返回给主查询4. 主查询根据子查询的结果最终执行。 123456# 查询工资&gt; 20号部门的所有员工的信息select * from emp where sal&gt;(select max(sal) from emp where deptno=20);select * from emp where sal&gt;all(select sal from emp where deptno=20); exists12345678910111213# 查询薪水&gt; 2000 的员工所在的部门信息# 关联查询 select distinct dept.* from emp,dept where emp.deptno = dept.deptno and sal&gt; 2000# 子查询 select * from dept where deptno in (select distinct deptno from emp where sal&gt; 2000);# exists# 子查询的时候，主查询条件字段和子查询的返回结果字段必须意义对应 select * from dept where exists ( select * from emp where sal&gt;2000 and dept.deptno= emp.deptno) exists 和 in的区别 in 先执行子查询，将结果返回给主查询，主查询继续执行 exists :先执行主查询，将主查询的值依次子啊子查询中进行匹配，根据是否匹配返回韬略或者false,如果是true就连接展示否则不展示， exists :实际上是主查询传值给子查询 子查询和多表 子查询–&gt; 查询条件和结果放在一张表 结果分布于多张表 关联查询: 能够处理结果放在一张表,但是占内存 联合查询(索引) 索引的时候 ,使用or会导致索引失败 联合会的结果集必须一致 union: 去重 union all 12345678910111213# 查询20号部门 以及工资&gt;2000的员工信息# union all 8条select * from emp where deptno=20 or sal&gt;2000# union all 8条select * from emp where deptno=20union select * from emp where sal&gt;2000# union all 11条select * from emp where deptno=20union allselect * from emp where sal&gt;2000 事务存储引擎 数据库底层软件组织,DBMS通过存储引擎实现对数据库的操作;MySQL的核心就是存储引擎. MySQL中可以设置多种存储引擎,不同的存储引擎在索引,存储,以及锁策略上是不同的 MySQL5.5之前,采用myisam存储引擎,支持全文搜索,不支持事务 mysql5.5之后,默认采用innidb存储引擎,支持事务以及行锁定 什么是事务 事务保证数据一致性,一组DML操作要么同时成功,要么同时失败 事务的特性12345678# 张三 ---&gt; 李四 ----&gt;100update account set money =money -100 where name='zs';update account set money =money +100 where name='ls';update account set money =money -100 where name='zs';delete form aa;## 出现错误,后面执行失败update account set money =money +100 where name='ls'; 事务的acid特性 原子性:放在同一个事务中的一组操作是不可分割的. 一致性:在事务的执行前后,总体的状态保持不变 隔离性:并发事务之间互相不能干扰 持久性:事务执行之后,将永久化到数据库 事务的语法 一组DML操作,放到同一个事务中进行处理 mysql 数据库采用自动事务提交: 每次执行一个DML操作,系统会自动创建一个事务,并且执行后,自动提交 查看MySQL的事务:自动提交 show variables like ‘autocommit’; 关闭MySQL的自动提交 set autocommit = 0; set autocommit = 1; 显式开启事务(可以不写) start transaction; begin 提交事务: commit; 回滚事务 1231. 开启事务: DML操作隐式开启事务2. 一组DML操作3. 提交/回滚事务 123456789# 显示开启事务Start transaction;update account set money =money -100 where name='zs';update account set money =money +100 where name='ls';# 手动提交commit;# 手动回滚rollback; 并发事务产生的问题 脏读:在一个事务的执行范围内读到了另一事务未提交的数据 不可重复读:一个事务在只读范围内,被另一个事务修改并提交事务,导致多次读取事务不一致的问题. 幻读(虚读):一个事务只读范围内,被另一个事务删除 或者添加数据,导致数据读取不一致. 事务的隔离级别 读未提交:不能处理任何问题 读已经提交: 只能读到一个事务提交后的数据问题,解决脏读 可重复读: 解决脏读问题和不可从重复读问题,MySQL默认 串行化:可以解决所有问题,执行效率低 参看事务的级别 存储程序 一组存储和执行的在服务器端的程序 运行于服务器端 优点: 简化开发 执行效率高(不需要校验和验证) 缺点: 程序保持在服务器端,占用服务器资源 数据迁移麻烦 调试,编写程序不方便 分类存储过程 服务器端运行的,可重复调用的sql代码块, 组成:名称,输入输出参数以及一组sql 创建 无参数: 12345678delimiter // # 设置//为结束标志,分号就不是结束标志了create procedure sel_emp()BEGINselect ename,dname from emp,dept where emp.deptno=dept.deptno;end //# 使用call sel_emp(); 传入模式(默认为 in) (模式 参数名 类型) 12345678# 根据编号查询员工delimiter //create PROCEDURE findEmpByNo(eno int)BEGINselect * from emp where deptno = eno;end;call findEmpByNo(10); 输出模式 out: 定义一个输出变量 into:将结果赋值给变量 12345678910# 根据员工编号查询员工姓名delimiter //;create PROCEDURE findNameByNO(eno int ,out v_name varchar(20))BEGINSELECT ename into v_name from emp where empno = eno;END# 使用call findNameByNO(7788,@name);select @name; 输入输出模式 1234567891011# 根据员工姓名查询员工职位delimiter //;create PROCEDURE findJob (inout name_job VARCHAR(20))BEGINselect job into name_job FROM emp where ename = name_job;end;# 使用set @name_job = 'smmith';call findJob(@name_job);select @name_job; 控制语句 if 1234567891011121314151617# 控制语句# 成绩分级delimiter //;create PROCEDURE score_lever1( score int)BEGIN declare v_level varchar(20);# 变量的声明 if score &gt; 80 then set v_level = 'A'; # 变量的赋值 elseif score&gt;=60 then set v_level = 'B'; else set v_level = 'c'; end if; select v_level;end;call score_lever1(90); # A 循环 while 条件 do… end while loop…. end loop(死循环); 判断: leave repeat until … end repeat;(死循环) 存储函数 存储在服务器端,有返回值,函数作为sql一部分使用 函数和存储过程的区别 关键字不同 存储过程三种参数模式实现数据输入输出;函数有返回值 触发器 不要添加过多出发器降效率 存储程序中不能使用事务控制 1234567891011# 创建触发器delimiter //;create trigger tri_userafter deleteon userinfo for each rowbegin# old newinsert into user_bak values(old.uid,old.uname,old.pwd);end;delete from userinfo where uid=1;]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday02]]></title>
    <url>%2Fblog%2F2018%2F08%2F24%2Fjavaeeday02%2F</url>
    <content type="text"><![CDATA[数据的完整性 实体完整性 引用完整性 dml 修改和删除 查询 单行函数 聚合函数和分组函数 加密函数 完整性约束实体完整性 保证数据记录之间是准确的(能够唯一标识一个实体) 实体: 客观存在的实物,数据库中指的是一条记录. 保证实体的完整性: 主键约束 唯一约束 主键自增约束 主键约束() 唯一 非空 主键字段的选择 必须是唯一的 不要选择业务字段(有真实含义的字段(身份证)) 一张表中只能有一个主键,但是可以有联合主键(多个字段组成) 每一张表必选要设置主键 创建表的同时添加主键123456789101112# 创建主键(非空,唯一),字段后面添加时不能添加联合主键CREATE table studetn(sid int primary key,sname VARCHAR(20) );# 创建表的时候,先给字段,后添加约束create table student(sid int,sname varchar(20),primary key(sid) # 可以设置联合主键); 表已经创建(alter) 表已经创建了,添加约束的时候,需要表中的数据合理,不能空和重复 123# 添加约束(constraint)# 约束名pk_字段alter table student add constraint pk_sid PRIMARY key(sid); 唯一约束(unique) 不能重复,可以为空(空只能有一个) 创建表的时候添加1234567891011121314# 添加唯一约束create table sun(uid int PRIMARY KEY,uname varchar(20),card VARCHAR(18) unique);create table sun(uid int PRIMARY KEY,uname varchar(20),card VARCHAR(18),unique(card)); 表存在12345678# 添加唯一约束create table sun(uid int PRIMARY KEY,uname varchar(20),card VARCHAR(18));alter table sun add constraint uq_card UNIQUE(card); 主键自增长约束(auto_increment) 从1开始,每次自身加1(oracle) 好处:不用关心主键重复问题 1234567# 主键自增长create table student(sid int primary key auto_increment,sname VARCHAR(20));alter table student MODIFY sid int auto_increment; 删除约束frm:存储数据的元数据信息(结构,约束,索引) 有主键自增长约束的时候,先删除自增长约束,后才能删除主键 123456# 自增长约束alter table student MODIFY sid int;# 主键约束alter table student drop PRIMARY KEY ;# 唯一约束drop index uq_sname on student; 域完整性 域: 字段 域的完整性: 类型约束 非空约束: 不能为空 not null 默认值: default 值 类型约束,非空,默认值123456# 非空 和 默认值create table student(sid int PRIMARY KEY auto_increment,sname varchar(20) not null,gender bit(1) default 1); 引用完整性 一张表中通用列的取值必须参考另外一张表主键字段 外键约束(foreign key) 主外键关联 add constraint 外键名 foreign key(外键关联字段) references 参考表(参考字段) 参考字段通常是参考表的主键 外键关联字段名称可以不一样,但是类型必须一致 1alter table student add constraint FK_cid foreign key(cid) references classroom(cid); 自定义完整性check约束:在mysql中不能使用1alter table student add constraint check (sage between 1 and 50) 运算符算数运算符1234567891011select 1+1; //2select 1-1; //0select 1*2; //2select 3/2; //1.5select 3 div 2; 1 ## 整除select 3/0; # null 比较运算符 > &lt; != / &lt;&gt; = >= &lt;= true 显示:1 false 显示:0 is null // is not null between … and … [ a , b ] in // not in 逻辑运算符 and or ! 123select 1=1 and 1=2; //0select 1=1 and 1=2; //1select !2=2; //0 位运算符 &amp; | ^(异或) 123select 3 &amp; 2; # 2select 3 | 2; # 3select 3 ^ 2; # 1 DML添加数据insert insert into tname[(字段名称….)] values(值…) 默认插入:给所有的字段添加值,和表中的字段顺序一致 1insert into classroom VALUES (3,'bd1807') 添加指定的字段,cid是自增长的 给定字段时,值和给定的字段顺序一致 1insert into classroom(cname) values ('bd1808'); 添加多条数据:使用逗号隔开 123insert into classroom(cname) value ('bd1809'),('bd1810'),('bd1811'); 将classroom 的值 整体复制到 classroom1 1234# 将classroom 的值 整体复制到 classroom1insert into classroom1 select * from create table classroom1 select * from classroom; 复制表的结构 1create table classroom1 select * from classroom where 0; 删除数据delete delete是逐行删除,不影响自增长.自是修改数据(自增不会重置) truncate 清空,文件级别的清空,(自增重置) 删除所有 1delete from classroom; 删除指定的记录 1delete from classroom where cid=2; 修改数据update 使用的时候不带条件是对整张表修改 update 表名 set 字段 = 值 where 字段 = 值 1update classroom set cname='1806' where cid =1; 查询数据普通查询select select 字段| 表达式 form 表|视图|结果集 select子句的作用:字段值 from子句: 从哪些表或者结果集中查询 where: 条件 1234567891011# 查询select * from emp;# 查询所有员工的姓名和工资select ename,sal from emp;# 查询工资大于2000select * from emp where sal&gt;=2000;# 查询工资1000~2000select * from emp where sal between 1000 and 2000; 集合查询(in ([值 , 值 ,…]))123select * from emp where empno=7521 or `empno`=7369 or empno = 7788;# 集合查询select * from emp wher empno in (7521,7369,7788) 取别名 (as 别名) 简化 作解释说明 (as) 别名 1234567select 1+1 count; # 将结果用count表示select ename,sal*1.5 new from emp; # 将结果用new表示select emp.ename from emp;select e.sal from emp e; 去除重复distinct 在查询前面添加 distinct 1select DISTINCT job from emp; 排序order by 默认升序:assc 降序 : desc 多个规则使用 逗号隔开 12select * from emp where deptno=10 order BY emp.sal desc;select * from emp where deptno=10 order BY emp.sal desc,emp.ename desc; 限制结果查询limit limti : 下标 , 长度 仅仅适用于MySQL. 1234# 取5条记录select * from emp limit 0,5;# 取部门为10的员工中的最大值select * from emp where deptno=10 order BY emp.sal desc limit 0,1; 模糊查询:like % 表示多个字符 _ 表示一个字符 1234567# 模糊查询select * from emp where ename like 's%';select * from emp where ename like'%s'select * from emp where ename like'%s%'# 第二个字符为L的所有员工信息select * from emp where ename like '_l%'; 函数单行函数数学函数 返回值只有一条记录 PI() :π ceil(): 向上取整 floor():向下取整 round():四舍五入 mod(): 取模 rand(): 随机数 pow():幂运算 123456789101112131415161718192021select PI(); # 3.141593select ceil(12.3);# 13select ceil(-12.3);;#12select floor(12.3); #12select floor(-12.3); #-13select round(3.5); #4select round(3.45); #3select round(3.45,1); #3.5select round(3.45,-1); #0select mod(5,2); # 1select rand();[0,1) # 随机从emp获取二条记录select * from emp ORDER BY rand() LIMIT 2;select pow(2,3); # 2^3=8 字符函数 length(): 获取字符的长度 lower(‘THIS’):字符转为小写字母 upper(‘this’): 字符转为大写字母 substr(‘this is zs’ , 1 , 6): 下标从1开始 replace(str,from_str,to_str); ;字符的替换 trim(‘str’) : 去除字符二端的空格 lpad(str, num , ‘str’): 用’str’ 左填充str, num小于length,截取 rpad(str, num , ‘str’):右填充 1234567891011121314151617181920select length('this is zs') # 10select upper('this') # THISselect lower('THIS') # thisselect substr('this is zs',1,6) #this iselect replace('this is zs','this','he'); #he is zsselect trim(' this is '); #去两端空格 this isselect LPAD('aa',10,'*'); #********aaselect LPAD('ab',1,'*'); #aselect rpad('aa',10,'*'); #aa********select rpad('ab',1,'*'); #a 日期函数 now(): 当前时间 sysdate:获取系统时间 curdate() /current_date(): 获取日期 : 年月日 curtime() / current_time(): 获取时间 : 时分秒 year(date): 获取指定时间的年份 month(date): 获取指定时间的月份 day(date): 获取指定是时间的天数 last_day(date)::获取指点时间的月份的最后一天 date_add(时间 , interval 值 ,类型):值可以为正负,类型可以是year/month/day 12345678910111213141516171819202122232425select NOW(); #当前时间 2018-08-29 21:17:54select SYSDATE(); #获取系统时间 2018-08-29 21:18:04select CURRENT_DATE(); 2018-08-29select CURDATE(); 2018-08-29select CURRENT_TIME(); 21:18:47select CURTIME(); 21:18:47select YEAR('1998-09-09'); 1998select YEAR(NOW()); 2018select MONTH(NOW()); 8select DAY(NOW()); 29#获取当前月最后一天select LAST_DAY('2018-02-01'); 2018-02-28#日期计算select DATE_ADD(NOW(),interval 2 MONTH); 2018-10-29 21:20:28 聚合函数 对数据整体进行运算,查询语句中不能出现单个字段 min():最小值 max():最大值 avg():平均值 count():总计 sum():求和 count();常用来统计表中的记录数,但是不会统计字段中为nulll的记录,所以统计表中的记录数的时候,选择不为null的更好, 分页操作:聚合函数和限制结果查询 1234567select max(sal) from emp;select min(sal) from emp;select avg(sal) from emp; select count(*) from emp; #记录数select count(1) from emp; #记录数select count(comm) from emp; #字段非空总数select sum(sal) from emp; 分组函数group by 使用分组的依据可以出现在select 查询的语句中 where 在group by 之后 where 中 不能使用聚合函数 having having 代替where ,分组之后进行检索 可以使用聚合函数 1234567#分组 group by 分组条件 having:分组之后进行检索 select deptno,avg(sal) from emp group by deptno; # 查询平均工资大于2000的部门的编号和平均工资。# 1.where在group by之后# 2.where中不能使用聚合函数 select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000; 加密函数 MD5(str):32为位 SHA(str):40位 password(str): 123select MD5('root'); #63a9f0ea7bb98050796b649e85481845select SHA('root');#dc76e9f0c0006e8f919e0c515c66dbba3982f785select password('root');#*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B # 41位]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaeeday01]]></title>
    <url>%2Fblog%2F2018%2F08%2F23%2Fjavaeeday01%2F</url>
    <content type="text"><![CDATA[mysql的使用 引入 内存中的数据: 速度快,不能持久性保存 文件中的数据,随着文件的增大,检索困难 数据库产生60年 数据 是客观事物的符号表示 符号:模拟,数字 数据量庞大 保存介质 纸张,u盘,硬盘,网盘 检索难度增加 文件上层对组织来进行封装(文档型数据库) 数据库(Database) 按照一定数据结构存储数据的仓库 数据库管理系统(DBMS) 概念: 操纵和管理数据库的软件 用户向DBMS发起请求,DBMS调用底层,得到结果后返回数据给用户 数据库分类关系型数据库管理系统(RDBMS) 采用关系模型管理数据 ,采用二维表格的形式来简化数据关系实现对数据的管理 ​ 常见关系型数据库: ​ 1. oracle数据库:oracle公司产品,大型分布式数据库管理系统.大型企业,金融,国企,产品免费,服务收费 mysql数据库:oracle公司,针对中小型系统;开源 免费(闭源风险).互联网厂商 mariaDB 数据库:mysql分支,社区维护5.5版本之前和mysql无区别. Sql Server :Microsoft 中小型企业.只能与windsows运行 DB2:IBM公司,中小型企业,外企,银行 非关系型的数据库管理系统(Nosql) not only sql 弥补关系型数据库在高io,高可用方面的局限性 非关系型数据库 redis hbase mongodb neo4j(图数据库) mysqlmysql初识 mysql是一个关系型的数据库管理系统 采用关系模型对数据进行管理,对不同的数据采用分**表**的形式管理,多张表存在的情况下,可以采用分库的形式进行管理 数据库可以存放多张表,mysql数据库DBMS可以管理多个数据库 mysql数据库管理系统中可以管理多个数据库,在一个数据库中可以存放多张表 mysql体积小,开源免费,支持GPL(开源软许可证)协议 1996年发布mysql1.0,mysql ab公司 2000年 正式开源 2008年被sun以10亿美元收购 2009年sun被oracle以74亿美元收购 mysql Server端的下载和安装 提供数据库服务:响应请求 下载: mysql下载 安装 选择produces 配置 Type and NotWorking standalone(单节点) Type and Networking Development Machine TCP/IP port,open FireWall Accounts and Roles accounts: 特定用户才能连接数据库服务 roles: 角色,控制权限,权限集合 用户: root用户 其他用户: Windows Service Service Name:MySQL start the mysql at System Satartup:开机自启 Advanced Options:日志管理 ErrorLog:mysql_err.err 文件存放目录Data dir : 存放数据文件 Data :每创建一个数据库就会创建相应的文件夹 frm 保存表的结构信息 my.ini: mysql的配置文件 跳过授权验证 skip-grant-table mysql操作客户端 发请求给客户端 WorkBench就是一个客户端;自带图形化界面(mysql安装时可选) 命令行客户端 命令行客户端操作 登录 mysql -u root -proot 回车 mysql -u root -p回车 展示所有的数据库: show databases; 选择数据库:use databaseName; 展示数据库中所有的表show databases; net satrt mysql net stop mysql mysqld –install 服务名 TCP/IP:三次握手: 客户端向服务器发送 图形化界面 表中的术语 记录:行 字段:列 SQL structure query language:结构化查询语言 在关系型数据库中进行操作标准语言,编程语言 对大小写不敏感, 以分号(;)j结尾 sql 分类DDL 数据定义语言,数据库对象的操作(结构) create alter drop DML 数据操纵语言(数据操作: 增删改查) insert update delete select DCL 数据的控制语言(授权 : 取消权限) grant : 授权 revoke: 取消授权 TCL 事务控制语言 commmit : 提交 rollback: 回滚 DDL 语言数据库12345# 创建数据库CREATE DATABASE if not EXISTS bd1807;# 销毁数据库drop database if exists bd1807; 表 创建 123456789# 创建表create table userinfo( uid int, uname varchar(20), gender bit(1), birthday date, tel VARCHAR(11) ); 查看表的结构 123desc userinfo;图形化工具:右键 --&gt; 设计表 表结构的修改 添加字段:add(追加) 12345678# 追加添加ALTER table userinfo add QQ varchar(20);# 添加字段到首位alter table userinfo add wechat varchar(20) first; -- first 添加到首位# 添加到uid之后alter table userinfo add renren varchar(20) after uid; -- after 添加字段之后 change/modify change : 旧字段名称 新名称 类型 约束; modify :字段 类型 约束(不能修改名称) 修改字段名称: 12# 修改字段名称 QQ--&gt; t_qqalter table userinfo change QQ t_qq VARCHAR(20); 类型修改 123# 修改varchar() alter table userinfo change t_qq t_qq varchar(10);alter table userinfo MODIFY t_qq VARCHAR(20); 位置 12# 修改位置alter table userinfo MODIFY t_qq varchar(20) after birthday; 销毁字段:drop 12# 删除renren字段alter table userinfo drop renren; 表名称的修改:rename to 12# 修改表的名称rename table userinfo to `user`;#``引号区分关键字 清空表(清除数据,不清楚结构) 12# 清空表的数据truncate table userinfo; mysql数据类型 在不同的数据库之间,数据类型是有区别的,oracle中数值表示为number 性别: bit(1) int 10位(21亿左右) float(m,n) 默认(10,2)精度24位 需要声明总长度,小数点位数 double (16,4),精度53位 有可能损失精度 deccimal 没有默认,必须声明长度和精度 用于金融数据保存 char(n) 定长长度字符串 不足空格填补,多出报错 varchar(n) 可变长度字符串 text 大文本 最大65535字符 date 日期 YYYY-MM-DD time 时间 HH:mm:SS datetime 日期时间 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 timestamp 时间戳 YYYYMMSSHHMMSS 1970-01 2037-12 year 年 blob 存放二进制数据 存储图片(一般只存储文件的位置) enum 枚举 set 集合类型 json json数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础day19]]></title>
    <url>%2Fblog%2F2018%2F08%2F22%2Fjava%E5%9F%BA%E7%A1%80day19%2F</url>
    <content type="text"><![CDATA[自定义注解1234@interface 注解名&#123; 类型 成员名()default 默认值; .....&#125; java 元注解: 元注解的作用就是负责注解其他注解。 @Target, @Retention, @Documented, @Inherited @Retention 用于声明我们自定义的注解的存活时间， 它的属性value有三个对应的值 RetentionPolicy.SOURCE：在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 RetentionPolicy.CLASS：默认值，编译器仅把注解保存在class文件中，在运行java程序时，JVM不会保留注释，即不能用反射（在运行期）来获取注释 RetentionPolicy.RUNTIME：编译器不仅把注解保存在class文件中，同时在运行java程序时，JVM也会保留注释，即可以通过反射来获取注释 @Target 用于指定自定义的注解能够修饰哪些元素， 其value属性指明了注解对象，有如下几个值供选择： ElementType.TYPE:修饰类、接口或枚举（enum) ElementType.FIELD:注解成员变量 ElementType.METHOD：注解方法 ElementType.PARAMETER：注解方法参数 ElementType.CONSTRUCTOR：注解构造函数 ElementType.LOCAL_VARIABLE ：注解局部变量 ElementType.ANNOTATION_TYPE 注解另一个自定义注解 ElementType.PACKAGE 注解包 3. @Documented网络编程使用的包位于java.net.* 协议 网络中计算机之间通信的规则 常用的协议: J常用的协议巨 IP:网际协议 TCP:传输控制协议 超文本传输协议(HTTP) 文件传输协议(FTP) 简单邮件传输协议(SMTP) IP地址表达方式 二进制(32位) 点分十进制 IP地址的分类 网络号+主机号 A类:0+7位主机号+24主机号 0.0.0.0~127.255.255.255(0和127不可用) B类 128.0.0.0~191.255.255.255 C类 InetAddress类常用方法 getLocalHost():获得IP地址 get DNS 域名解析 端口 用于实现程序间的通信 常用的公认端口 协议 端口 简单邮件传输协议 25 文本传输协议 21 超文本传输协议 80 URL 统一资源定位器 标识网络上的摸一个资源 格式: protocol://hostmame[:port]/path/[?query]#fragment 协议://主机地址:端口号/目录/查询字符串#片段 常用方法 getProtocol( ) getHost( ) getPort() getDefaultPort() getPath() getQuery() getRef( ) 网络通信 java支持TCP和UDP协议族 TCP/IP 较可靠的双向流协议 发送任意数量的数据 UDP 是一种不可靠的连接 速度快 通信的模式 客户端/服务器模式(C/S) 浏览器(B/S) Socket客户端 提供了二个双向流,可以互相通信 ServerSocket]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础day18]]></title>
    <url>%2Fblog%2F2018%2F08%2F21%2Fjava%E5%9F%BA%E7%A1%80day18%2F</url>
    <content type="text"><![CDATA[锁类加载反射基本注解 ReentrantLock锁12345try&#123; 加锁lock;&#125;finally&#123; 释放锁unlock&#125; 释放锁应该写在finally{}中,除非虚拟机退出,否则一定会释放,如果不写在finally中,当方法return后,锁便不能释放. 构造方法:123456// 创建锁对象ReentrantLock lock = new ReentrantLock();// 创建公平锁对象// 会将锁给等待时间长的对象ReentrantLock lock = new ReentrantLock(true); 卖票: 1234567891011121314151617181920212223242526class Ticket implements Runnable&#123; private int ticketCount = 20; //创建锁 ReentrantLock lock = new ReentrantLock(); try&#123; //上锁 lock.lock(); this.ticketCount-=1; System.out.println(Thread.currentThread().getName()+"卖了1张,剩余:"+this.ticketCount); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;fianlly&#123; //释放锁 lock.unlock(); &#125;&#125;public class TestSubThread2&#123; public static void main(String[] args)&#123; Ticket ticket = new Ticket(); Thread win1 = new Thread(ticket,"win1"); Thread win2 = new Thread(ticket,"win2"); win1.start(); win2.start(); &#125;&#125; 释放锁sleep和wait()sleep(毫秒值):放弃cpu的执行权,但是不释放锁 wait(可选毫秒值):放弃cpu和锁 notify():唤醒等待池中的一个线程 notifyAll():唤醒等待池中的所有线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class NumberDemo implements Runnable &#123; int i = 10;// synchronized public void run() &#123; for (; i &gt;= 0; i--) &#123; if (i == 5 &amp;&amp; Thread.currentThread().getName().equals("t1")) &#123; try &#123; // Thread.sleep(1000); wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (i == 0) &#123; notify(); System.out.println("醒了"); &#125; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125;&#125;public class TestSubThread5 &#123; public static void main(String[] args) &#123; NumberDemo demo = new NumberDemo(); Thread t1 = new Thread(demo, "t1"); Thread t2 = new Thread(demo, "t2"); t1.start(); t2.start(); &#125;&#125;//---wait----------------------t1:10t1:9t1:8t1:7t1:6t2:5t2:4t2:3t2:2t2:1醒了t2:0t1:-1//----sleep----------------------- t1:10t1:9t1:8t1:7t1:6(等1s)t1:5t1:4t1:3t1:2t1:1醒了t1:0 死锁问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Zhangsan&#123; public void say() &#123; System.out.println("你给我书，我就给你画"); &#125; public void get() &#123; System.out.println("张三获得了书"); &#125;&#125;class Lisi&#123; public void say() &#123; System.out.println("你给我画，我就给你书"); &#125; public void get() &#123; System.out.println("李四获得了画"); &#125;&#125;class ThreadDemo implements Runnable&#123; private static Zhangsan zhangsan = new Zhangsan(); private static Lisi lisi = new Lisi(); public boolean tag = false; public void run() &#123; if(tag) &#123; synchronized (zhangsan) &#123; zhangsan.say(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (lisi) &#123; zhangsan.get(); &#125; &#125; &#125;else &#123; synchronized (lisi) &#123; lisi.say(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (zhangsan) &#123; lisi.get(); &#125; &#125; &#125; &#125;&#125;public class TestSubThread4 &#123; public static void main(String[] args) &#123; ThreadDemo demo1 = new ThreadDemo(); demo1.tag = true; ThreadDemo demo2 = new ThreadDemo(); demo2.tag = false; Thread t1 = new Thread(demo1); Thread t2 = new Thread(demo2); t1.start(); t2.start(); &#125;&#125; 生产消费123456789101112131415161718192021222324252627282930313233class Qingfeng&#123; private int count ; boolean tag = false; //产包子 synchronized public void put(int count) &#123; if(tag) &#123;//if(true) try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //false this.count = count; System.out.println("生产了：" + this.count); tag = true;//有 notify();//唤醒销售人员 &#125; //卖包子 synchronized public void get() &#123; if(tag == false) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //true System.out.println("卖了 ：" + this.count); tag = false;//卖，没了 notify();//唤醒厨师 &#125;&#125; 123456789101112//生产class Producer implements Runnable&#123; Qingfeng qingfeng; Producer(Qingfeng qingfeng)&#123; this.qingfeng = qingfeng; &#125; public void run() &#123; for(int i = 1; i &lt;= 5; i++) &#123; qingfeng.put(i); &#125; &#125;&#125; 123456789101112//销售class Cosumer implements Runnable&#123; Qingfeng qingfeng; Cosumer(Qingfeng qingfeng)&#123; this.qingfeng = qingfeng; &#125; public void run() &#123; for(int i = 1; i &lt;= 5; i++) &#123; qingfeng.get(); &#125; &#125;&#125; java应用程序一个java程序只有一个main方法,下面中的TestA1和TestA2有二个main方法,实际上互相不干扰.结果都是6. 12345package day18.loader;public class A &#123; public static int a = 5;&#125; 123456789package day18.loader;public class TestA1 &#123; public static void main(String[] args) &#123; A.a ++; System.out.println(A.a);//6 &#125;&#125; 123456789package day18.loader;public class TestA2 &#123; public static void main(String[] args) &#123; A.a ++; System.out.println(A.a);//6 &#125;&#125; 类的生命周期 加载: 把字节码文件.class 加载到方法区的内存中,创建一个对应的对象,堆中(Class),通过Class对象可以获得字节码中的所有信息 连接 验证:对字节码文件.class进行验证,保证虚拟机的安全 准备: 为静态变量分配空间,进行默认初始化 解析:把符号引用替换为直接引用(如把方法用指针替换) 初始化:对静态变量声明处或静态块初始化 使用: 卸载 类的初始化当一个类被主动使用时： 当创建某个类的新实例时 当调用某个类的静态成员； 当初始化某个子类时，该子类的所有父类都会被初始化。 当使用反射方法强制创建某个类或接口的对象时 当虚拟机java命令运行启动类 注意：static final类型的不能导致初始化的情况 ​ 静态常量在编译期就能确定值的情况不会引起初始化 下面程序中, ​ 访问n的时候,会引起类的初始化 ​ 访问num,不会引起类的初始化,在编译期期间就能确定了值是33. ​ 访问sn2,也不会引起类的初始化,值为88. ​ 访问sn的时候,虽然是final static修饰,但是值不能确定,会引起类的初始化 12345678910111213141516171819202122232425262728293031package day18.loader;class Demo&#123; static int n = 55; final static int num=33; final static int sn = 33 + n; final static int sn2 =33+55; static &#123; System.out.println("static 初始化"); &#125;&#125;class SubDemo extends Demo&#123;&#125;public class TestDemo1 &#123; /*static int sn = 45; static&#123; sn = 55; &#125; static &#123; System.out.println("static !"); &#125;*/ public static void main(String[] args) throws ClassNotFoundException &#123; // Demo demo = new Demo(); System.out.println(Demo.sn); // SubDemo demo = new SubDemo(); // Class.forName("day18.loader.Demo"); &#125;&#125; 类加载器 根类加载器:加载\jre\lib下的核心类库 Bootstrap ClassLoader 扩展类加载器:加载路径\jre\lib\ext的文件 Extension ClassLoader 系统(应用)类加载器: 加载classPath路径下的文件(默认当前路径) App ClassLoader System ClassLoader 自定义类加载器 加载自定义位置的文件 123456st=&gt;start: 用户自定义类加载器op=&gt;operation: 系统类加载器op2=&gt;operation: 扩展类加载器op3=&gt;operation: 根类加载器op4=&gt;input: aaast-&gt;op-&gt;op2-&gt;op3 加载器的顺序系统类加载器-&gt;扩展类加载器-&gt;根类加载器-&gt; 如果根类加载器不能加载,看扩展类加载器,不能给系统类加载器,给用户自定义类加载器 双亲委派模型 工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。 好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。 例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。 123456789101112131415161718public class TestDemo2 &#123; public static void main(String[] args) &#123; //系统类（应用类）加载器 ClassLoader loader = TestDemo2.class.getClassLoader(); System.out.println(loader); //父扩展 System.out.println(loader.getParent()); //父根 System.out.println(loader.getParent().getParent()); &#125;&#125;//结果---------sun.misc.Launcher$AppClassLoader@73d16e93sun.misc.Launcher$ExtClassLoader@15db9742null(根类加载器是由C语言写的) 加载类12345678public static void main(String[] args) throws ClassNotFoundException &#123; //加载类 完全限定命名 ClassLoader.getSystemClassLoader().loadClass("day18.Demo1"); //加载类 ，并初始化,Class.forNmae(加载类,初始化 true,系统类加载器 ) Class.forName("day18.Demo1",true,ClassLoader.getSystemClassLoader()); //简写 Class.forName("day18.Demo1");&#125; 自定义类加载器 由于是双清委派,在项目外建立一个类C.java,编译得到C.Class 123456789101112131415161718192021222324252627282930313233343536373839//自定义类加载器class MyLoader extends ClassLoader&#123; String path; MyLoader(String path)&#123; this.path = path; &#125; // 包名.类名 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; c = null; // "d:/data/" + "C" + ".class" -&gt;"d:/data/C.class" //带包情况下,用.替换 // path = path + name.replace(".", "/").concat(".class"); path = path + name.concat(".class"); FileInputStream fin = null; try &#123; fin = new FileInputStream(path); byte [] b = new byte[fin.available()]; int len = fin.read(b); c = this.defineClass(name, b, 0, len); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fin != null) &#123; try &#123; fin.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; return c; &#125;&#125; 1234567891011public class TestDemo4 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 自定义类加载器 加载类 C .class MyLoader my = new MyLoader("d:/data/"); Class c = Class.forName("C",true,my); System.out.println(c.getClassLoader()); c = null; &#125;&#125; 安全管理器SecurityManager 在Java应用中，安全管理器是由System类中的方法setSecurityManager设置的。要获得当前的安全管理器，可以使用方法getSecurityManager。 自定义安全管理器12345678910111213141516171819202122232425//自定义的安全管理器class MySecurityManager extends SecurityManager&#123; @Override public void checkRead(String file) &#123; if(file.endsWith(".txt")) &#123; throw new SecurityException("不能读取 txt文件"); &#125; &#125; &#125;public class TestDemo5 &#123; public static void main(String[] args) throws IOException &#123;// System.setSecurityManager(new MySecurityManager()); File f = new File("d:/data/a.txt"); FileInputStream fin = new FileInputStream(f); System.out.println(fin.read()); fin.close(); Object obj = new String(); &#125;&#125; 反射获得运行时类的信息的一种技术. JAVA反射机制是在运行状态中， 对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 反射就是把java类中的各种成分映射成一个个的Java对象 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码 从字节码文件中获得信息 123// 获取对象的类型Object s = new String();System.out.println(s.getClass().getName());// java.lang.String 获得字节码文件对象 Class&lt;Person&gt; c = Person.class; Class&lt;? extends Person&gt; c = new Person().getClass(); Class&lt;?&gt; c = Class.forNmae(&quot;完全命名包名.类名&quot;) 方法 getDeclaredFileds();获得所有的属性(包含私有的) getDeclaredMethods(）获得所有方法 getDeclaredConstructors(); 获得所有构造方法 newInstance():获得一个实例 123456789101112131415161718class Person&#123; private int no; public String name; Person()&#123; System.out.println("无参构造"); &#125; Person(int no,String name)&#123; this.no= no ; this.name = name; System.out.println("带参数的构造："+ this.no + ":" + this.name); &#125; public void f() &#123; System.out.println("无参 f"); &#125; public String sf(String str , int num) &#123; return "字符串:" + str + num; &#125;&#125; 12345678910public static void main(String[] args) throws Exception &#123; //从 Person.class中获得信息： 反射 //获得 字节码文件 对应的对象 //1. // Class&lt;Person&gt; c = Person.class; //2. // Class&lt;? extends Person&gt; c = new Person().getClass(); //3 获得 字节码文件 对应的对象 Class&lt;?&gt; c = Class.forName("day18.loader.Person");&#125; 获得字节码文件的属性(Field) getDeclaredFileds();获得所有的属性(包含私有的) 常用方法: getName(): 名字 getType(): 类型 getModifiers(): 访问权限 属性.get(实例),—–实例.属性 1234567891011121314//----------获得所有的属性-------------------// Field [] fs = c.getFields();//公共的 Field [] fs = c.getDeclaredFields(); for(Field f :fs) &#123; System.out.println(f.getName());//名 System.out.println(f.getType());//数据类型 System.out.println(Modifier.toString(f.getModifiers()));// 访问权限 &#125; Field f = c.getDeclaredField("no");// System.setSecurityManager(new SecurityManager()); f.setAccessible(true);// Object obj = c.newInstance();//获得一个实例对象 f.set(obj, 22); System.out.println(f.get(obj)); 获得方法(Method) getDeclaredMethods(); 获取所有方法 常用方法 getReturnType(): 获取返回值得类型 getParameterTyoes(): 获得参数列表,数组[] 方法.invoke(实例,[参数])——–实例.方法() 1234567891011121314151617//---------------方法------------------Method [] ms = c.getDeclaredMethods();for(Method m : ms) &#123; System.out.println(m.getName()); System.out.println(Modifier.toString(m.getModifiers())); System.out.println(m.getReturnType());//返回值类型 System.out.println(Arrays.toString(m.getParameterTypes()));//获得 参数列表&#125;//访问单个方法Method m1 = c.getDeclaredMethod("f" );Object obj = c.newInstance();//创建一个实例m1.invoke(obj);//调用方法//Method m2 = c.getDeclaredMethod("sf", String.class,int.class);String s = (String)m2.invoke(obj, "hello",345);System.out.println(s); 获得构造方法 getDeclaredConstructors(); 获得所有构造方法 方法 getParameterTypes();获取参数类型 newInstance([参数…]):调用构造 1234567891011//---------构造---------------Constructor [] crs = c.getDeclaredConstructors();for(Constructor cr : crs ) &#123; System.out.println(Arrays.toString(cr.getParameterTypes()));&#125;//单个构造Constructor cr1 = c.getDeclaredConstructor();cr1.newInstance();Constructor cr2 = c.getDeclaredConstructor(int.class,String.class);cr2.newInstance(111,"abc"); 基本注解 @override @Depercated:说此方法已过时 @SupperessWarnings:镇压警告:不出现黄色警告线,遇到错误照样报错 all:所有的 unused:变量声明没有使用 rawtypes:原生类型 unchecked: 类型检查 serial: 版本号(序列化的类最好添加版本号) @FunctionalInterface:函数式接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 版本号//@SuppressWarnings("serial")// 所有的@SuppressWarnings("all")class DemoNew implements Serializable&#123;&#125;class Base&#123; public void af() &#123;&#125; //已过时 @Deprecated public void f() &#123;&#125; // 类型检查 @SuppressWarnings("unchecked") public void sf() &#123; //镇压警告 // 变量声明了 没有使用 @SuppressWarnings("unused") int n ; // 原生类型 @SuppressWarnings(&#123; "rawtypes", "unused" &#125;) List list = new ArrayList(); list.add("abc"); list.add(111); &#125;&#125;class Sub extends Base&#123; @Override public void af() &#123;&#125;&#125;@FunctionalInterfaceinterface Info&#123; void af();&#125;public class TestDemo7 &#123; public static void main(String[] args) &#123; Base base = new Base(); base.f(); &#125;&#125;]]></content>
      <tags>
        <tag>锁</tag>
        <tag>类的生命周期</tag>
        <tag>类加载器</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdbc基础]]></title>
    <url>%2Fblog%2F2018%2F08%2F20%2Fjdbc%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JDBC简介数据库的驱动 SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范，称之为JDBC。 JDBC全称为：Java Data Base Connectivity（java数据库连接），它主要由接口组成。 组成JDBC的２个包： java.sql,javax.sql 以上2个包已经包含在J2SE中，所以不用导入， 开发这只需要导入JDBC的实现类即数据库驱动包。开发JDBC应用需要以上2个包的支持外，还需要导入相应JDBC的数据库实现(即数据库驱动)。 JDBC可以操作数据库吗？ 不能直接操作，需要加载驱动程序 JDBC之前的使用步骤1. 通过mysql的客户端工具，登录数据库服务器 （mysql -u root -p 密码） 2. 编写sql语句 3. 发送sql语句到数据库服务器执行 使用前提 登录数据库服务器,url:jdbc协议:数据库子协议:主机:端口/连接的数据库 数据库的IP地址 端口 数据库用户名 密码 第一个JDBC程序JDBC接口核心的API java.sql. 和 javax.sql. Driver接口 表示java驱动程序接口。所有的具体的数据库厂商要来实现此接口。 connect(url,properties):连接数据库的方法 url: 连接数据库的URL URL语法： jdbc协议:数据库子协议://主机:端口/数据库 user： 数据库的用户名 password： 数据库用户密码 1234567891011121314151617181920212223242526//使用之前需要导入jdbc的实现驱动包.String url = "jdbc:mysql//lcoalhost:3307/day01";private String user = "root";private String password = "123456";public void test1() &#123; // 1.创建驱动程序类对象 Driver driver = null; try &#123; driver = new com.mysql.jdbc.Driver(); &#125; catch (SQLException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; // 2.连接数据库,得到的Connection //"user","password" Properties properties = new Properties(); properties.setProperty("user", user); properties.setProperty("password", password); try &#123; Connection connect = driver.connect(url, properties); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; DriverManager类 驱动管理器类，用于管理所有注册的驱动程序 registerDriver(driver) : 注册驱动类对象 new driver的时候,就注册了自身,所以注册了二次,不没必要 Connection getConnection(url,user,password); 获取连接对象 Connection接口 表示java程序和数据库的连接对象。 Statement createStatement() ： 创建Statement对象 PreparedStatement prepareStatement(String sql) 创建PreparedStatement对象 CallableStatement prepareCall(String sql) 创建CallableStatement对象]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础day17]]></title>
    <url>%2Fblog%2F2018%2F08%2F20%2Fjava%E5%9F%BA%E7%A1%80day17%2F</url>
    <content type="text"><![CDATA[字节流 读InputStream 写OutputStream 节点流:FileInputStream 缓冲流:BufferedInputStream 序列化(读)ObjectInputStream 反序列化(写):ObjectOutputStream 打印输出字节流PrintStream 使用步骤 创建流对象 读/写 关闭流 构造方法 FileInputStream(): 默认构造,覆盖 FileInputStream(File,boolean):true:追加,默认false 节点流小案例 复制图片: 使用字节流,不能使用字符流 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; File file = new File("C:\\Users\\sun\\Desktop\\day17", "壁纸4.jpg"); File newFile = new File("C:\\Users\\sun\\Desktop\\day17", "copy.jpg"); if (file.exists()) &#123; try &#123; // 1.创建流对象 FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(newFile); // 2. 读取图片到byte[] byte[] bs = new byte[fis.available()]; fis.read(bs); //3. 写文件 fos.write(bs); if(newFile.exists()&amp;&amp;file.length()==newFile.length())&#123; System.out.println("复制成功!!!"); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; else &#123; System.out.println("文件不存在,复制失败!!!"); &#125;&#125; 缓冲流 默认8192字节. BufferedInputStream();包装流,处理流 BufferedOutputStreaam:输出缓冲流 1234567891011121314151617181920212223//将控制台的输入写入到文件中public static void main(String[] args) throws Exception &#123; // 创建输出流 File file = new File("C:\\Users\\sun\\Desktop\\day17", "name.txt"); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(file)); // 录入信心 boolean flag = true; Scanner sc = new Scanner(System.in); while (flag) &#123; System.out.println("请输入学员信息:"); String name = sc.nextLine(); if ("q".equals(name)) &#123; flag = false; System.out.println("输入结束!!!"); &#125; else &#123; bos.write(name.getBytes()); bos.write("\r\n".getBytes()); &#125; &#125; bos.close(); System.out.println("文件保存路径:" + file.getAbsolutePath()); &#125; Scanner类Scanner sc = new Scanner(System.in) System类: public final static InputStream in = null; 常用方法 next(): 读取数据 next:不会获取空格 nextLine():获取空格 hasNext():判读数据类型,通过next()可以读取数据. nextXxx()、hasNextXxx()等等 12345678910111213public static void main(String[] args) throws Exception &#123; File file = new File("C:\\Users\\sun\\Desktop\\day17", "name.txt"); FileInputStream fis = new FileInputStream(file); Scanner sc = new Scanner(fis); String str = sc.next(); System.out.println(str); Scanner sc2 = new Scanner("aa bb cc"); String str2 = sc2.next(); System.out.println(str2);//aa System.out.println(sc2.nextLine());// bb cc&#125; 数据流数据输入输出流：DataInputStream(FileInputStream)数据输入流 数据输出流——用于读写基本数据类型： 规则：先进先出【先存进去先读出来，读出类型与写入类型一致】 12345678910111213141516171819202122232425262728public static void main(String[] args) throws Exception &#123; File file = new File("C:\\Users\\sun\\Desktop\\day17", "name.txt"); FileInputStream fis = new FileInputStream(file); DataInputStream dataInputStream = new DataInputStream(fis); FileOutputStream fos = new FileOutputStream(file); DataOutputStream dataOutputStream = new DataOutputStream(fos); // 写writeInt,wrriteByte....writeUTF() int[] no = new int[] &#123; 11, 22, 33 &#125;; String[] name = new String[] &#123; "I", "love", "you" &#125;; for (int i = 0; i &lt; no.length; i++) &#123; dataOutputStream.writeInt(no[i]); dataOutputStream.writeUTF(name[i]); &#125; //读,按照写入的顺序读 int i; for (i = 0; i &lt; no.length; i++) &#123; System.out.print(dataInputStream.readInt() + " "); System.out.print(dataInputStream.readUTF() + " "); &#125; //关闭流 dataInputStream.close(); dataOutputStream.close();&#125; 对象流对象流: 序列化(读)ObjectInputStream 反序列化(写):ObjectOutputStream 序列化前提对象要序列化前提: 类要实现 Serializable接口 序列化把对象转换成字节序列(把对象存到磁盘文件中) 反序列化读,把文件的内容读出来(把字符序列还原成对象) 注意: 版本号:当反序列化的时候,原来的类可能会有修改,这时候版本号随机不一致,反序列化会失败 解决方法: 手动给定序列化 private static final long serialVersionUID = 1L; 123456789101112131415161718192021222324252627282930313233343536373839public class Student implements Serializable &#123; private static final long serialVersionUID = 1L; private String name; private int age; private int id; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125;&#125; 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; // 1.创建对象流的对象 File file = new File("C:\\Users\\sun\\Desktop\\day17", "object.txt"); FileOutputStream fos = new FileOutputStream(file); ObjectOutputStream outputStream = new ObjectOutputStream(fos); //2. 创建对象 Student stu1 = new Student("刘备", 33); // 3.将对象序列化,写 outputStream.writeObject(stu1); // 4. 反序列化,读 FileInputStream fis = new FileInputStream(file); ObjectInputStream inputStream = new ObjectInputStream(fis); Object readObject = inputStream.readObject(); Student student = (Student) readObject; System.out.println(student);&#125; 打印流123456789101112131415161718192021public static void main(String[] args) throws Exception &#123; File file = new File("C:\\Users\\sun\\Desktop\\day17", "print.txt"); if(!file.exists())&#123; file.createNewFile(); &#125; //读 FileInputStream fis = new FileInputStream(file); byte[] bs = new byte[fis.available()]; fis.read(bs); fis.close(); //打印到控制台 PrintStream printStream = new PrintStream(System.out); printStream.println(new String(bs ,0 ,bs.length,"UTF-8")); printStream.close(); //打印到文件中 PrintStream printStream2 = new PrintStream("C:\\Users\\sun\\Desktop\\day17\\print2.txt"); printStream2.print(new String(bs ,0 ,bs.length,"UTF-8")); printStream2.close();&#125; 字符流字符流只针对文本 Reader BufferedReader Reader InputStreamReader FileReader Writer BufferedWriter Writer OutputStreamWriter FileWriter Writer PrintWriter 文件字符流FileReader FileWriter 对同一个文件操作的时候,不能同时写FileReader,FileWriter,用的时候使用对应的流 1234567891011121314151617181920212223242526272829303132//将xie.txt中的文件内容逆序写入到一个文本中public static void main(String[] args) throws Exception &#123; File file = new File("C:\\Users\\sun\\Desktop\\day17", "xie.txt"); File destFile = new File("C:\\Users\\sun\\Desktop\\day17", "xiecopy.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; // 1.读/写 FileReader fileReader = new FileReader(file); FileWriter fileWriter = new FileWriter(destFile); // 写 // fileWriter.write("abc".toCharArray()); fileWriter.write("ABCD1234"); // 读 StringBuffer sf = new StringBuffer(); int temp; while ((temp = fileReader.read()) != -1) &#123; sf.append((char)temp); System.out.println(sf); &#125; //逆序后写入新的文件 fileWriter.write(sf.reverse().toString()); // 关闭流 fileReader.close(); fileWriter.close();&#125; 缓冲流BufferedRead ,BufferedWriter 可以一次处理一行 readLine() 如果读完: 返回null 12345678910111213public static void main(String[] args) throws IOException &#123; //1 FileReader fr = new FileReader("d:/data/a.txt"); BufferedReader bfr = new BufferedReader(fr); //2 String s ; while((s = bfr.readLine()) != null) &#123; System.out.println(s); &#125; //3 fr.close();&#125; 打印输出字符流相当于是System.out.print(&quot;&quot;),打印输出到文件中. 1234567891011public static void main(String[] args) throws FileNotFoundException &#123; //1. PrintWriter pw = new PrintWriter("d:/data/number.txt"); //2 for(int i = 1; i &lt;= 5; i++) &#123; pw.println("第" + i + "个数字"); // System.out.println("第" + i + "个数字"); &#125; //3. pw.close();&#125; BufferedReader 和PrintWriter一起使用 123456789101112131415BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));PrintWriter pw = new PrintWriter("d:/data/name.txt");//2String s ;System.out.println("--input name:");while(true) &#123; s = bfr.readLine(); if(s.equals("q")) &#123; break; &#125; pw.println(s);&#125;//3bfr.close();pw.close(); 自动释放资源不用close,系统指定释放资源 前提:流要继承AutoCloseable; 1234567try（声明需要释放的资源）&#123; 可能产生异常的语句。&#125;catch(异常)&#123;&#125; 12345678910111213141516try(BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in)); PrintWriter pw = new PrintWriter("d:/data/name.txt");)&#123; //2 String s ; System.out.println("--input name:"); while(true) &#123; s = bfr.readLine(); if(s.equals("q")) &#123; break; &#125; pw.println(s); &#125;&#125;catch(IOException e) &#123; e.printStackTrace();&#125; 多线程编程 进程: 内存中,正在运行的一个应用程序. 线程:进程中的一个执行流程 多线程:进程中有二个或二个以上的执行流程 其实是轮训切换,速度非常快 java程序 启动一个java程序,至少会启动几个线程 1. 主线程 2. 垃圾回收线程 线程的状态 New(新建） ​ 新建一个线程对象 ​ Thread t = new Thread(); Runnable(就绪） ​ 等待cpu调用执行 Running(运行） ​ 就绪状态的线程被cpu调用 Blocked(阻塞） ​ sleep(毫秒) ​ 先回到就绪装填 ​ join() ​ 让其他线程先执行 ​ 同步阻塞: ​ 相当于排队 ​ wait()阻塞 ​ notify()/notifyAll()唤醒,锁定池等待: ​ 出现了某种原因,暂停了cpu的调用执行 Dead(死） ​ 线程运行结束 主线程java 程序启动时,一个线程立刻运行,该线程常叫做程序的主线程(Main thread) 程序开始时,就执行 主线程是参数子线程的线程 默认名字:main,优先级为5 子类名字:Thread-0,依次递增 线程只能启动一次: 一个线程多次调用:IllegalThreadStateException 1234567public static void main(String[] args) &#123; // 显示当前方法里的线程 System.out.println(Thread.currentThread());// Thread[main,5,main] // 修改线程的名字 Thread.currentThread().setName("abc"); System.out.println(Thread.currentThread());//Thread[abc,5,main] 创建线程方式 继承Thread类 实现Runable接口 Thread类方法 CurrentThread():获取当前方法中的线程 Thread.currentThread().setName(“”):设置线程的名字 interrupt():线程中断 sleep() join() 只有上面二个方法才会产生中断异常 yield():线程让步 Thread.yield() 多线程例子 主线程结束后，程序结束 主线程等待的时间足够长sleep() isLuver():当前线程是否处于运行状态，是true 让其他线程先执行join() sleep(毫秘）等待，睡眠， 线程A处于sleep（）那么，线程A就处于阻塞状态， 当参数的时间超时了，那么会回到就绪状态等待CPU调用执行。 当在主线程中调用了子线程的join（） 那么主线程处于阻塞状态，等待子线程执行完成后，进入就绪状态，再恢复执行 线程修改名字 继承Thread类 重写该类的构造方法,传入一个name 12345678910111213141516171819202122232425262728293031323334class MyThread extends Thread &#123; public MyThread() &#123; super(); &#125; public MyThread(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + ":hello"); &#125;&#125;public class Thread2 &#123; public static void main(String[] args) &#123; // 新建一个线程 MyThread thread1 = new MyThread("A"); MyThread thread2 = new MyThread("B"); // 启动线程,进入就绪状态 // start()的目的是调用run()方法; // 直接调用run()方法是主线程调用,与子线程无关 thread1.start(); thread2.start(); &#125;&#125;//---------A:helloB:hello 实现runable接口 在传给Thread对象的后面添加name Thread t1 = new Thread(myThreadClass,name&quot;); 123456789101112131415161718192021222324// 这里不是一个线程类class MyThread2 implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+":hello"); &#125;&#125;public class ThreadRunableDemo &#123; public static void main(String[] args) &#123; // 1. 新建实现接口的对象 // 这不是一个线程对象 MyThread2 my = new MyThread2(); // 2. 需要将实行了接口的对象传到Thread对象 Thread t1 = new Thread(my,"C"); t1.start(); &#125;&#125;//-----------C:hello 线程的优先级 java 中的优先级1-10,1最低, 10 最高 优先级高,cpu调用的次数多 并不是绝对,优先级需要看系统等 1234567891011121314151617public static void main(String[] args) &#123; ThreadDemo1 demo = new ThreadDemo1(); Thread t1 = new Thread(demo,"t1"); Thread t2 = new Thread(demo,"t2"); //设置优先级 // t1.setPriority(10); // t2.setPriority(1); //推荐下面几种 t1.setPriority(Thread.MAX_PRIORITY); t2.setPriority(Thread.MIN_PRIORITY); // t1.setPriority(Thread.NORM_PRIORITY); t1.start(); t2.start();&#125; 线程中断当线程A调用了线程B的线程中断方法，那么 线程B暂停cpu的调用执行进入异常处理， 然后继续执行。 前提:线程b处于sleep()或join() 12345678910111213141516171819202122232425262728class ThreadDemo2 implements Runnable&#123; @Override public void run() &#123; for(int i = 1; i &lt;= 10; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); if(i == 5) &#123; try &#123; // Thread.sleep(1000); Thread.currentThread().join(); &#125; catch (InterruptedException e) &#123; System.out.println("进入异常处理"); &#125; &#125; &#125; &#125;&#125;public class TestIerrupt &#123; public static void main(String[] args) &#123; ThreadDemo2 demo = new ThreadDemo2(); Thread t1 = new Thread(demo,"t1"); Thread t2 = new Thread(demo,"t2"); t1.start(); t2.start(); t1.interrupt();//中断t1,调用中断异常处理,没有join()和sleep();没有效果 &#125;&#125; 线程让步理论上: ​ 线程A让步给 同等优先级的线程B或级别比它高的线程B 实际上:让步后成为就绪状态,等待cpu的调用执行,(并不是真正的让步) 12345678910111213141516171819202122232425class ThreadDemo3 implements Runnable&#123; @Override public void run() &#123; for(int i = 1; i &lt;= 10; i++) &#123; System.out.println(Thread.currentThread().getName() + ":" + i); if(i == 5 &amp;&amp; Thread.currentThread().getName().equals("t1")) &#123; Thread.yield();//让步 &#125; &#125; &#125;&#125;public class TestYield &#123; public static void main(String[] args) &#123; //让步 ThreadDemo3 demo = new ThreadDemo3(); Thread t1 = new Thread(demo,"t1"); Thread t2 = new Thread(demo,"t2"); t1.start(); t2.start(); &#125;&#125; 同步 使用同步代码块,可以指定锁的对象 ​ synchronized (this) { //调用的功能 } 使用同步方法,锁的是this ​ synchronized 方法() 锁的都是对象,其他对象在锁定池中等着,出来后处于就绪状态 123456789101112131415161718class Bank implements Runnable &#123; private int money; // synchronized public void setmoney()&#123; public void setmoney() &#123; this.money += 100; System.out.println("剩余:" + Thread.currentThread().getName() + ":" + money); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; synchronized (this) &#123; setmoney(); &#125; &#125; &#125;&#125; 加锁当线程A 执行到了同步代码块或同步方法的代码的时候,要获得此对象的同步锁,获得成功,那么,其他线程B进入到锁定池中处于锁定状态 释放锁 当线程A 正常执行完同步代码块或同步方法中的代码时. 当代码块 或 方法中出现没有解决的Error或Exception时 当代码块或方法中return,break时 wait(). 创建子线程两种方式 的区别： 1.继承Thread可以 继承到 Thread的所有的方法； 2.实现接口 只有一个run（）方法； 更有利于资源共享。]]></content>
      <tags>
        <tag>缓冲流</tag>
        <tag>字符流</tag>
        <tag>多线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day16]]></title>
    <url>%2Fblog%2F2018%2F08%2F17%2Fjava%E5%9F%BA%E7%A1%80day16%2F</url>
    <content type="text"><![CDATA[FileFile类主要用来获取文件（或目录）本身的一些信息，如文件的名字，不涉及文件的读写操作。文件操作的宝都在java.io.*包下文件目录的分隔:\\或反斜杠(/) file方法 exists（) createNewFile() getName() getPath() getAbsolutePath() getParent() canRead() canWrite() isFile() long lastModified() long length() boolean delete() 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) throws Exception &#123; // 构造方法 //默认为当前项目 File file = new File("a.txt"); File file2 = new File("d:/a/a.txt"); File file3 = new File("d:/a", "a.txt"); // 判断文件是否存在 System.out.println(file.exists()); // 新建文件 file.createNewFile(); System.out.println("---------"+file.exists()); // 获得文件的名称 System.out.println(file.getName()); // 获得文件路径路径 // 路径，如果是绝对路径显示绝对，如果是相对路径显示相对 System.out.println(file.getPath()); // 绝对路径 System.out.println(file.getAbsolutePath()); //获取父目录 System.out.println(file.getParent()); //是否可读,可写 System.out.println(file.canRead()); System.out.println(file.canWrite()); //是不是文件 System.out.println(file.isFile()); //上一次修改时间 System.out.println(new Date(file.lastModified())); //文件大小 System.out.println(file.length()); //0 //删除文件 System.out.println(file.delete());&#125; 目录目录是一个包含其他文件和路径列表的File类对象 目录方法 判断方法： boolean isDirectory():判断file是不是目录 boolean exists()： 判断目录是否存在 获得方法： String[] list()： 获取目录下的子目录和文件的字符串形式 File[] listFiles(): 获取目录下的子目录和文件的file形式 String[] list(FilenameFilter): 对文件名的过滤 File[] listFiles(FileFilter):对File 对象进行过滤 创建目录 mkdir(): 不会创建父目录 mkdirs(): 不目录不存在,会创建父目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849File file = new File("C:\\Users\\sun\\Desktop\\day15");System.out.println(file.getAbsolutePath());// 判断是否是文件夹System.out.println(file.isDirectory());// 判断文件夹存在System.out.println(file.exists());// 获得目录下的子目录 和 文件的字符串形式file.list(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(".java"); &#125;&#125;);// lambda表达式String[] fileList = file.list((d, name) -&gt; name.endsWith("java"));//遍历输出for (String str : fileList) &#123; System.out.println(str);&#125;// 获得目录下的子目录 和 文件的File形式File[] listFiles = file.listFiles();listFiles = file.listFiles(new FileFilter() &#123; @Override public boolean accept(File path) &#123; return path.getName().endsWith("java"); &#125;&#125;);// 表达式listFiles = file.listFiles(f -&gt; f.getName().endsWith("java"));// 查看for (File ff : listFiles) &#123; if (ff.isDirectory()) &#123; System.out.println(ff.getPath()); &#125; else &#123; System.out.println("文件:" + ff.getName()); &#125;&#125; 递归遍历文件夹123456789101112131415161718192021public static void main(String[] args) &#123; File file = new File("C:\\Users\\sun\\Desktop\\day15"); // 递归遍历文件 while (true) &#123; File[] listFiles = file.listFiles(); if (listFiles == null) &#123; return; &#125; for (File file1 : listFiles) &#123; if (file1.isDirectory()) &#123; System.out.println(file1.getPath()); &#125; else &#123; System.out.println(file1.getAbsolutePath()); &#125; file = file1; &#125; &#125;&#125; 流 Java在java.io包定义多个流类型来实现输入和输出 java中,文件的输入输出功能通过流实现 流:可以理解成为一组有顺序的、有起点、有终点的动态数据集合 流的分类 按照流的数据类型：分为字节流和字符流 ​ 英文: 1字节 中文: 2字节 按照方向：输入和输出 ​ 输入: 硬盘 —-&gt; 内存 ​ 输出: 内存 —-&gt; 硬盘 按照功能：节点流和处理流(过滤流,包装流) ​ 节点流: 直接对数据源 进行 读写 处理流: 在节点流的基础上套接一个流 功能更多 效率更高 字节流(Stream)InputStream 所有字节输入流 的父类 InputStream FileInputStream FilterInputStream DataInputStream BufferedInputStream ObjectInputStream OutputStream FileOutputStream FilterOutPutStream DataOutputStream BufferedOutputSteam PrintStream ObjectOutputStream 方法 读时，路径一定要存在写的时候文件可以自动创建文件。 InputStream read() OutputStream write() close(): 关闭流对象 使用 步骤： 创建流对象 该读写就读写 关闭流 文件流FileInputStream123456789101112131415161718192021222324252627public static void main(String[] args) throws Exception &#123; File file = new File("C:\\Users\\sun\\Desktop\\day16\\a.txt"); if (!file.exists()) &#123; file.createNewFile(); &#125; // 1. 创建流对象 // 读取文件Inputstream,可能出现“文件找不到异常” FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(file); // 2. 读/写 // 写 String str = "Hello."; byte[] bytes = str.getBytes(); fos.write(bytes); //读 int i; while ((i = fis.read()) != -1) &#123; System.out.print((char) i); &#125; // 3. 关闭流对象 fos.close(); fis.close();&#125; 读取中文乱码问题解决办法： 字符流读取read() 1234567891011// 创建读/写的字节流对象FileInputStream fis = new FileInputStream(file);FileOutputStream fos = new FileOutputStream(file);// 包装流:字节---&gt;字符流InputStreamReader reader = new InputStreamReader(fis);// 字符流读取int temp;while ((temp = reader.read()) != -1) &#123; System.out.println((char) temp);&#125; 字节流读取到数组,再显示read(byte[]): 将流中的数据读取到byte数组中，返回长度，在内存中读到数组中，效率高 12345678910111213141516// 拿一个袋子（byte[]）// 文件的长度作为数组的长度// byte[] cbuf = new byte[(int) file.length()];// 流读取的长度作为数组的长度byte[] cbuf = new byte[fis.available()];// 将流中的数据读取到字节数组中System.out.println(fis.read(cbuf));// read(字节数组,字节数组的起始位置,存几个)fis.read(cbuf,4,2);// 从袋子里拿出来(转为字符)// System.out.println(new String(cbuf,"UTF-8"));System.out.println(new String(cbuf,"GBK")); 字节流read(数组，数组起始位置，存的个数) 字节流write(数组，数组起始位置，存的个数) 起始位置 + 存的个数之和 要小于数组的长度，否者出现数组下标越界的异常 文件的复制 FileOutputStream fos = new FileOutputStream(destFile,false);//默认覆盖 FileOutputStream fos2 = new FileOutputStream(destFile,true);//追加 12345678910111213141516171819202122232425262728public static void main(String[] args) throws Exception &#123; File file = new File("C:\\Users\\sun\\Desktop\\day16\\b.txt"); File destFile = new File("C:\\Users\\sun\\Desktop\\day16\\c.txt"); // 1. 创建流对象 // 读取文件Inputstream,文件找不到异常 FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(destFile,false);//默认覆盖 // 包装流:字节---&gt;字符流 InputStreamReader reader = new InputStreamReader(fis); // 2. 读/写 //将b.txt 复制到c.txt byte[] b = new byte[fis.available()]; fis.read(b); //写 System.out.println("1233:"+b.length); fos.write(b, 0, b.length); // fos.write(b); System.out.println("success"); // 3. 关闭流对象 fos.close(); fis.close();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础day15]]></title>
    <url>%2Fblog%2F2018%2F08%2F16%2Fjava%E5%9F%BA%E7%A1%80day15%2F</url>
    <content type="text"><![CDATA[Collections类针对集合操作的工具类 方法： 都是静态方法 sort(list) 自然升序排序 sort(集合，比较器) 自定义排序方法 binarySearch(list,e) 查找参数元素e在集合list出现的索引,前提升序 max(list) 集合中的最大元素 min(list) 集合中的最小元素 reverse(list) 对集合元素进行反转 frequency(list,e) 查找参数元素e在集合元素中出现的次数,不存在为0 . fill (list,e) 用元素e填充list shuffle(list) 集合元素的洗牌 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // Collections.addAll(list, &quot;aa&quot;,&quot;cc&quot;,&quot;bb&quot;); System.out.println(list); //自然 升序 Collections.sort(list); System.out.println(list); //指定比较器// Collections.sort(list, (s1,s2)-&gt;s2.compareTo(s1)); System.out.println(list); //查找参数 元素 在集合中 出现的索引 ， 前提 升序 排序// System.out.println(Collections.binarySearch(list, &quot;aaa&quot;)); //集合 中 最小 的 和 最大 System.out.println(Collections.min(list)); System.out.println(Collections.max(list)); // list.add(&quot;aa&quot;); System.out.println(list); //查找 参数 元素 在集合 中 出现的 次数 ，不存在 0 System.out.println(Collections.frequency(list, &quot;aa&quot;));//2 //对集合元素进行反转 Collections.reverse(list); System.out.println(list); //集合元素的洗牌 Collections.shuffle(list); System.out.println(list); //集合的填充 ，用 参数 来替换 集合 中的每个元素。 Collections.fill(list, &quot;xxx&quot;); System.out.println(list); &#125; Queue接口 队列: 是访问受限的线性表 先进先出的数据结构 添加元素从队尾添加 删除元素从队头删除 方法 添加 删除 获取列表头元素 操作失败时 add remove element 会产生异常 offer poll peek 不会产生异常，而是返回特定的值。 实现类LinkedList类 队列不允许添加null,但是linkedList可以添加 add(e)向集合添加元素:(向后添加) 成功： 返回true; 失败： 返回异常 offer(e)向集合添加元素:(向后添加) 成功： 返回true; 失败： 返回false remove()向集合删除元素:(第一个) 成功： 返回true; 失败： 返回异常 poll()向集合删除元素:(第一个) 成功： 返回true; 失败： 返回null element()//不删除查看元素 123456789101112131415Queue&lt;String&gt; q = new LinkedList&lt;&gt;();q.add(&quot;aa&quot;);q.add(&quot;bb&quot;);q.offer(&quot;cc&quot;);q.forEach(System.out::println);//出队---------------------------System.out.println(q.remove());System.out.println(q.poll());//循环出队 -----------------------------------while(q.size() &gt; 0) &#123; System.out.println(q.poll());//移除,查看第一个 System.out.println(q.peek());//第一个没有走,死循环&#125; PriorityQueue类 优先队列 违背了队列先进先出的规则 使用该类不要使用集合的forEach遍历,看不到效果 默认构造使用自然升序优先级（comparable）带参(comparator)**不能使用list的forEach（）； 12345678910111213141516171819public static void main(String[] args) &#123; // 优先队列 Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((n1, n2) -&gt; n2 - n1); q.add(22); q.add(55); q.add(11); // 没有效果 // q.forEach(System.out::println); // 遍历 while (q.size() &gt; 0) &#123; System.out.println(q.poll()); &#125;&#125;逆序输出:552211 Deque 接口 双端队列 模拟栈（后进先出）: addFirst—getFirst(); addLast—-getLast() 是Queue的子类 方法 添加 删除 获取列表头元素 操作失败时 addFirst removeFirst getFirst 会产生异常 addLast removeLast getLast 会产生异常 offerFirst pollFist peekFirst 不会产生异常，而是返回特定的值。 offerLaset pollLast peekLast 不会产生异常，而是返回特定的值。 栈的方法： push 入栈：添加pop 弹栈：删除 实现类ArrayDeque();队列(队尾进,队头出)12345入队 出队add() remove()offer() poll()addLast() removeFirst()offerLast() pollFirst() 123456789101112//模拟 队列 Deque&lt;String&gt; d = new ArrayDeque&lt;&gt;(); d.add(&quot;aa&quot;); d.addLast(&quot;bb&quot;); d.offer(&quot;cc&quot;); d.offerLast(&quot;dd&quot;); System.out.println(d); //出队 while(d.size() &gt; 0) &#123; // System.out.println(d.poll()); System.out.println(d.pollFirst()); &#125; 栈(从上入栈,从上出栈)123入栈 出栈addFirst() pollFirst()push() pop() 1234567891011Deque&lt;String&gt; d = new ArrayDeque&lt;&gt;(); //入栈 d.addFirst(&quot;aa&quot;); d.offerFirst(&quot;bb&quot;); d.addFirst(&quot;cc&quot;); d.push(&quot;dd&quot;); //出栈 while(d.size() &gt; 0) &#123; // System.out.println(d.pollFirst()); System.out.println(d.pop()); &#125; Map接口双列存储, 键值对键是唯一的 实现类HashMap HashMap支持 存储入 null键 和 null值。键是唯一 的，覆盖了之前的重复的 方法 size() isEmpty() containsKey() containsValue() remove() keySet() values() clear() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void main(String[] args) &#123; // TODO Auto-generated method stub Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); //存信息,添加 map.put(1, &quot;张三&quot;); map.put(2, &quot;李四&quot;); map.put(3, &quot;王五&quot;); System.out.println(map); //获得 键值对 的数量 System.out.println(map.size());//3 //键值对的数目 为0 true System.out.println(map.isEmpty());//false //查看 指定 的键 在 集合 中 是否 存在; System.out.println(map.containsKey(2)); //查看 指定 的值在 集合 中 是否 存在; System.out.println(map.containsValue(&quot;李四&quot;)); //根据 指定的键去删除 map.remove(2); System.out.println(map); //获得 键的集合 Set Set&lt;Integer&gt; set = map.keySet(); System.out.println(set); //值的集合 Collection&lt;String&gt; c = map.values(); System.out.println(c); // // map.clear(); // System.out.println(map.isEmpty()); //--------------------------------------- System.out.println(map); //HashMap支持 存储入 null键 和 null值。 map.put(null, null); //null = null System.out.println(map); //键是唯一 的，覆盖了之前的重复的 map.put(1, &quot;赵六&quot;); System.out.println(map);&#125; 遍历 foreach 12345678map.forEach(new BiConsumer&lt;Integer, String&gt;() &#123; @Override public void accept(Integer t, String u) &#123; System.out.println(t + "," + u); &#125;&#125;);map.forEach((k,v)-&gt; System.out.println(k+":"+v)); 键值的迭代器遍历 123map.keySet().iterator().forEachRemaining(System.out::println);map.values().iterator().forEachRemaining(System.out::println); 键值对的集合entrySet() 123456Set&lt;Entry&lt;Integer,String&gt;&gt; set = map.entrySet();//输出键值对set.forEach(e-&gt;System.out.println(e)); //键值对对象set.forEach(e-&gt;System.out.println(e.getKey()+&quot;,&quot;+e.getValue())); //获取键和值//键值对的迭代器 键值对的迭代器遍历 1234Set&lt;Entry&lt;Integer,String&gt;&gt; set1 = map.entrySet();//键值对的迭代器Iterator&lt;Entry&lt;Integer,String&gt;&gt; i = set1.iterator();i.forEachRemaining(System.out::println); Stream 流操作 java.util.* 包下,1.8出现 对流中的数据进行聚集运算。 一次性的运算 速度快 使用: IntStream LongStream DoubleStream 聚集方法 max():获取流中的最大值 min() sum() average() count() allMatch()是否所有元素符合条件 anyMatch()是否至少包含一个元素 filter: 过滤器,中间方法,返回的是一个新的流,可以继续调用方法 以上的方法使用一次后(比如求玩最大值后,流对象就不能继续使用) 解决办法: ​ 使用一次后重新创建一次流 实现类IntStream末端方法:​ 得到结果后 就释放了 IntStream is = IntStream.build(); ​ IntStream is = IntStream.builder().add(11).build(); 123456789101112131415161718192021222324public static void main(String[] args) &#123; IntStream is = IntStream.builder().add(11).add(22).add(33).add(55).build(); // 末端方法------------------------------------------- // System.out.println(is.max().getAsInt()); //55 // System.out.println(is.min().getAsInt()); //11 // System.out.println(is.sum()); //121 // System.out.println(is.average().getAsDouble()); //30.25 // System.out.println(is.count()); // 带条件的流统计 // all 所有 的 数据 都满足条件 返回 true // allMatch(): 是否所有元素符合条件 is.allMatch(new IntPredicate() &#123; @Override public boolean test(int value) &#123; return value&gt;20; &#125; &#125;); System.out.println(is.allMatch(v-&gt;v &gt; 10)); //true:流中的所有元素大于10 //any 流中只要有一个元素满足条件 就返回true System.out.println(is.anyMatch(v-&gt; v &gt; 50)); //true 中间方法:​ 得到一个新的流,可以进行新的操作 123IntStream is = IntStream.builder().add(11).add(22).add(33).add(55).build(); is.filter(v-&gt; v&gt;20).forEach(System.out::println);//中间方法 集合使用流集合转换为流 stream():将集合的元素转换为流 123456789public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list, 11, 454, 44, 6878, 23); list.stream().filter(v -&gt; v &lt; 55).forEach(System.out::println); System.out.println(list.stream().filter(v -&gt; v &lt; 55).count()); // list.stream().forEach(System.out::println);&#125; Predicate 接口 过滤器的接口 使用的位置: ;流中的filter ()方法 集合中的removeIf()方法 例子” 过滤学生年龄在30岁以上并且名字中包含”g”的学生 1234567891011121314151617181920212223242526272829303132333435363738// 学生类class Student &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; @Override public String toString() &#123; return "Student [name=" + name + ", age=" + age + "]"; &#125;&#125; 1234567891011121314151617181920// 测试过滤器public class TestPredicate1 &#123; public void showStu(List&lt;Student&gt; stus, Predicate&lt;Student&gt; p) &#123; for (Student stu : stus) &#123; if (p.test(stu)) &#123; System.out.println(stu); &#125; &#125; &#125; public static void main(String[] args) &#123; List&lt;Student&gt; stus = new ArrayList&lt;&gt;(); stus.add(new Student("zhangsan", 44)); stus.add(new Student("lisi", 55)); stus.add(new Student("wangwu", 22)); new TestPredicate1().showStu(stus, t -&gt; t.getAge() &gt; 30 &amp;&amp; t.getName().contains("g")); &#125;&#125;]]></content>
      <tags>
        <tag>Map</tag>
        <tag>Queue</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day14]]></title>
    <url>%2Fblog%2F2018%2F08%2F15%2Fjava%E5%9F%BA%E7%A1%80day14%2F</url>
    <content type="text"><![CDATA[集合 存储可变的数据时,数组不能很好的处理集合是一个容器 二者的区别: 长度 数组长度固定 集合长度不固定 内容不同 数组存储基本类型和引用类型 集合只能存储引用类型 性能上 数组更好 集合底层数据结构复杂 集合树 Collection依赖Iterator list: 重复,有序,依赖 ListIterator ArrayList LinkedList Vector –&gt; 子类stack set: 不能重复,map(值,null) HashSet LinkedHashSet Treeset Map依赖collection HashMap: 存储一对信息 TreeMap comparable 和 comparator 排序器 Collection接口 存储数据,单列数据可以重复,无序 常用的方法 isEmpty() 查看集合是否为空 size() 查看集合的长度 add() 往集合中添加元素 addAll(集合） 将集合中的所有元素添加到当前集合中,只要当前集合发生改变true remove() 将元素添从当前集合中删除,只要当前集合发生改变true removeAll(集合） 将集合中的所有元素添加到当前集合中,只要当前集合发生改变true removeIf() 带条件删除,重写Predicate接口的test方法 contains() 查看元素是否在集合中,有一个就是true containsAll(集合) 判断集合元素是否全部在当前集合中,全部在为true toArray() 将集合变为数组 clear清除集合中的所有元素 Arrays.asList(String[] str)是Arrays的静态内部类数组转集合,不能进行集合长度改变的操作(增加,删除),UnsupportedOperationException1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//演示collection的功能()public static void main(String[] args) &#123; Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); System.out.println(&quot;isEmpty:&quot; + c.isEmpty()); // 添加数据 c.add(&quot;aa&quot;); c.add(&quot;bb&quot;); c.add(&quot;cc&quot;); // 查看集合的长度 System.out.println(&quot;size:&quot; + c.size()); // size:3 // 遍历 for (String s : c) &#123; System.out.print(s + &quot; &quot;); // aa bb cc &#125; System.out.println(); // 添加集合addAll(集合) c.addAll(c); System.out.println(&quot;addAll:&quot; + c);// addAll:[aa, bb, cc, aa, bb, cc] // 移除remove(object) c.remove(&quot;aa&quot;); System.out.println(&quot;remove:&quot; + c);// remove:[bb, cc, aa, bb, cc] // 移除集合 Collection&lt;String&gt; d = new ArrayList&lt;&gt;(); d.add(&quot;aa&quot;); d.add(&quot;bb&quot;); c.removeAll(d); System.out.println(&quot;removeAll:&quot; + c); // removeAll:[cc, cc] // 带条件删除removeIf c.add(&quot;abc&quot;); // c.removeIf(new Predicate&lt;String&gt;() &#123; // // @Override // public boolean test(String t) &#123; // return t.length()&lt;=2; // &#125; // &#125;); // lambda 表达式 c.removeIf((t) -&gt; t.length() &lt;= 2); System.out.println(&quot;removeIf:&quot; + c); // removeIf:[abc] // 是否存在参数指定的元素,存在true System.out.println(&quot;contains:&quot; + c.contains(&quot;abc&quot;)); // contains:true // 是否存在集合参数中的全部元素,全部存在为true c.add(&quot;aa&quot;); System.out.println(&quot;containsAll:&quot; + c.containsAll(d));// containsAll:false,只有aa包含 // 数组转换成集合,Arrays.asList是Arrays的静态内部类 // 不能添加,移除(改变长度) List&lt;String&gt; list = Arrays.asList(new String[] &#123; &quot;aa&quot;, &quot;bb&quot; &#125;); // list.add(&quot;cc&quot;); //UnsupportedOperationException // list.remove(&quot;aa&quot;); // UnsupportedOperationException System.out.println(&quot;get:&quot; + list.get(1)); // get:bb // 集合转数组toArray Object[] array = d.toArray(new Object[2]); // Object[] array = d.toArray(); String[] array2 = d.toArray(new String[3]); // 遍历 System.out.println(&quot;toArray:&quot; + Arrays.toString(array));// toArray:[aa, bb, null] //移除所有元素 c.clear(); System.out.println(&quot;clear:&quot; + c);//clear:[]&#125; List 接口 存储数据 可以重复 有序,按照元素add的顺序 方法 add 添加元素 add(index,element) 向参数索引处添加一个元素 get(index) 获取索引处多的元素 set(index,element) 用第二个参数元素替换第一个参数索引处的元素 indexOf(element) 参数元素第一次在集合中出现的索引位置 lastindexOf(element) 查找 参数元素最后一次在集合中出现的索引位置 subList(start,end)子集合 remove(index) 删除指定位置的元素 sort(Comparator) 排序Comparator 使用sort(null):自然 升序 排序 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 添加元素 list.add(&quot;aa&quot;); list.add(&quot;bb&quot;); list.add(&quot;cc&quot;); System.out.println(&quot;add:&quot; + list);// add:[aa, bb, cc] // 向参数索引处添加一个元素 list.add(1, &quot;dd&quot;); System.out.println(&quot;Index add:&quot; + list);// Index add:[aa, dd, bb, cc] // 用第二个参数元素替换第一个参数索引处的元素 list.set(1, &quot;hello&quot;); System.out.println(&quot;set:&quot; + list);// set:[aa, hello, bb, cc] // 查找 参数元素第一次在集合中出现的索引位置 System.out.println(&quot;indexOf:&quot; + list.indexOf(&quot;hello&quot;));// indexOf:1 // 查找 参数元素最后一次在集合中出现的索引位置 System.out.println(&quot;lastIndexOf:&quot; + list.lastIndexOf(&quot;hello&quot;));// lastIndexOf:1 // 子集合 list.subList(0, 2); System.out.println(&quot;subList:&quot; + list.subList(0, 2));//subList:[aa, hello] // 排序Comparator System.out.println(&quot;set:&quot; + list);//set:[aa, hello, bb, cc] //按照 自然 升序 排序 list.sort(null); System.out.println(&quot;sort:&quot;+list);//sort:[aa, bb, cc, hello] //删除 list.remove(1); System.out.println(&quot;remove:&quot;+list);//remove:[aa, cc, hello]&#125; 集合的遍历基本for 只能是List1234//1.基本for 只能 List-------------------------for(int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i));&#125; 增强for 集合都能用1234//2.增强for ---------------------------------for(String s : list) &#123; System.out.println(s);&#125; 集合的forEach方法 list.forEach(Consumer接口)list.forEach(System.out::println):方法的引用 1234567891011list.forEach(new Consumer&lt;String&gt;() &#123; //t 集合元素 @Override public void accept(String t) &#123; System.out.println(t); &#125;&#125;);list.forEach(t-&gt;System.out.println(t));//lambdalist.forEach(System.out::println);//方法的引用 集合的流遍历list.stream().forEach(System.out::println); 迭代器Iterator迭代器的方法 hasNext() next forEachRemaining(Consumer接口); 遍历的时候不能操作,并发修改异常使用ListIterator可以操作 remove(): 删除最近一次next()的元素 1234Iterator&lt;String&gt; i = list.iterator();while(i.hasnext())&#123; System.out.println(i.next());&#125; 迭代器的forEachRemaining12Iterator&lt;String&gt; i = list.iterator();i.forEachRemaining(System.out::println); ListIterator void add():将指定的元素插入到列表中（可选操作）。 void remove():从列表中删除最后一个元素是由 next()或 previous()返回（可选操作）。 void set():取代过去的元素返回 next()或 previous()与指定的元素 hasNext() next() hasPrevious() previous() 123456789101112131415//next 遍历后可以向上遍历ListIterator&lt;String &gt; i = list.listIterator();while(i.hasPrevious())&#123; System.out.println(i.previous());&#125;//修改,添加,删除.没有并发异常while(iterator.hasNext())&#123; String next = iterator.next(); if(&quot;aa&quot;.equals(next))&#123; iterator.set(&quot;123&quot;); iterator.remove(); iterator.add(&quot;456&quot;); &#125;&#125; 实现类 ArrayList 底层数据结构是 数组(查找快) 按照50% 扩容 遍历 和随机访问效率高 Vector(jdk1.0出现,性能低) Stack,可以模拟栈的操作 按照100%扩容 线程安全 使用工具类包装arraylist代替掉 LinkedList 底层数据结构 是链表(增删快) 链表的数据用节点表示: 构成 值域数据 链域地址 单向链表:值域+ 链域 双向链表: 前驱 + 值域 + 后继 数组和链表的区别 数组的地址是连续的 链表的地址不连续 数组:遍历 和随机访问效率高 链表:添加元素和删除元素效率高 set接口 集合特点:无序且唯一 123456789101112131415//获取7个不重复的随机数public static void main(String[] args) &#123; // Set Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); int r; while(true) &#123; r = (int)(Math.random()*(30-1+1)+1); set.add(r);// int -&gt;Integer if(set.size() == 7) &#123; break; &#125; &#125; set.forEach(System.out::println); &#125; HashSet类 底层数据结构是哈希表 hash唯一存储原理首先,调用 hashCode()算出一个hash地址,把元素存进去,如果hash值冲突hashCode()的值一样,这时候才会调用equals()判断二个对象是否相同,相同不存储,不同可以存储需要重写hashCode()和equals方法. 12345678910111213@Overridepublic int hashCode() &#123; // 哈希地址 return name.hashCode() + no;&#125;@Overridepublic boolean equals(Object obj) &#123; // this ,obj // obj _ &gt; Employee Employee e = (Employee)obj; return this.no == e.no &amp;&amp; this.name.equals(e.name);&#125; LinkedHashSet 有序,唯一链表,根据插入的顺序 SortedSet接口 是Set的子接口,实现类TreeSet;底层数据结构是 二叉树 first() 获得第一个元素 . last() 获得最后一个元素 . subSet(start, end) 得到子集,[起始元素,终止元素) 12345678910111213141516public static void main(String[] args) &#123; SortedSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); set.add(111); set.add(25); set.add(153); System.out.println(set);// [25, 111, 153] // 获得第一个元素 System.out.println(set.first());// 25 // 获得最后一个元素 System.out.println(set.last());// 153 // 子集,[起始元素,终止元素) System.out.println(set.subSet(25, 111));// [25]&#125; 数:表示层次结构的 树：是由节点集及连接每对节点的有向边集组成。二叉树：树形结构任意节点不能超过两个孩子。 根节点 枝节点 叶节点 中序遍历: 左中右 要管理树(维持持续),效率不如hashSet NavigableSet接口 是sortedSet的子类接口提供了接近匹配原则的检索元素的方法 floor(e):小于 等于 指定参数 的最大元素 ceiling:大于等于 指定参宿的 最小元素 descendingSet():集合元素降序排序 descendingIterator():降序的迭代器 pollFirst():移除第一个元素 pollLast(): 移除最后一个元素 12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) &#123; // NavigableSet NavigableSet&lt;Double&gt; set = new TreeSet&lt;&gt;(); set.add(11.1); set.add(55.5); set.add(22.2); set.add(99.9); System.out.println(set); //[11.1, 22.2, 55.5, 99.9] //小于 等于 指定参数 的最大元素 System.out.println(set.floor(20.0)); //11.1 //大于等于 指定参宿的 最小元素 System.out.println(set.ceiling(20.0)); //22.2 //降序的集合 set.descendingSet().forEach(System.out::println); //降序的迭代器 set.descendingIterator().forEachRemaining(System.out::println); 结果降序: /* 99.9 55.5 22.2 11.1 */ //移除第一个元素 set.pollFirst(); System.out.println(set); //[22.2, 55.5, 99.9] //移除最后一个元素 set.pollLast(); System.out.println(set); //[22.2, 55.5]&#125; TreeSet 真正的比较是依赖于元素的compareTo()方法，而这个方法是定义在 Comparable里面的。所以，你要想重写该方法，就必须是先 Comparable接口。这个接口表示的就是自然排序。二叉树不需要重写hashCode()和equals() 123456compareTo()方法中:return 0: 不添加到集合return正数: 作为右孩子return 负数: 作为左孩子通过中序遍历可以得到有序 List集合的排序 sort(null): 自然排序,需要排序的类中实现Comparable接口 sort(comparator): 推荐使用lambda表达式 1234567class Dog implements Comparable&lt;Dog&gt;&#123; @Override public int compareTo(Dog o) &#123; return this.age - o.age ; &#125; &#125; 12345678910111213141516171819202122232425public static void main(String[] args) &#123; List&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;(); Dog wangwang = new Dog(&quot;旺旺&quot;,&quot;金毛&quot;,2); Dog meimei = new Dog(&quot;美美&quot;,&quot;吉娃娃&quot;,3); Dog wangcai = new Dog(&quot;旺财&quot;,&quot;松狮&quot;,1); dogs.add(wangwang); dogs.add(meimei); dogs.add(wangcai); //遍历 dogs.forEach(System.out::println); //2.实现自然排序 dogs.sort(null); //实现comparator年龄降序 dogs.sort((dog1,dog2)-&gt;dog2.getAge() - dog1.getAge()); //删除美美 dogs.remove(meimei); // System.out.println(dogs.size()); //2&#125; 使用选择 数据情况 (Set)唯一: 无序:HashSet 有序: 添加顺序: LinkedList 自定义顺序: TreeSet (List)重复: 查询多: ArrayList 增删多: linkedList 参考 集合 List接口 List集合练习 Set接口]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day13]]></title>
    <url>%2Fblog%2F2018%2F08%2F14%2Fjava%E5%9F%BA%E7%A1%80day13%2F</url>
    <content type="text"><![CDATA[泛型 泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 参考:泛型使用 泛型使用 class Point&lt;T&gt;{}:这是一个泛型类 123456789101112131415161718192021222324252627282930313233343536371. &lt;T&gt;: 形式类型参数: 参数可以是任意类型2. Point&lt;具体的类型参数&gt;:参数化类型 应用时,一个类型后边指定一定具体的类型参数 Point&lt;Integer&gt;3. 类型推断 菱形语法 Point&lt;Integer&gt; point = new Point&lt;&gt;();4. 原生类型: 使用的时候,类型后面没有指定具体类型 Point point = new Point();5. 类型参数: 可以定义多个类型参数,用逗号分隔 Point&lt;K , V&gt;6. W规范: 1. 使用一个大写字母 1. Type T 2. Element E 3. Key K 4. Value v7. 泛型的好处 1. 编译期进行类型检查 2. 类型不确定时也能使用8. 格式 class 类名&lt;泛型类型标识&gt;&#123; 访问修饰符 &lt;泛型类型&gt; 属性; 访问修饰符 &lt;泛型类型&gt; 方法()&#123;&#125; 访问修饰符 &lt;泛型类型&gt; 方法(泛型类型 参数)&#123;&#125; &#125;应用： 1. 类名&lt;具体类型&gt; 对象名 ＝ new 类名&lt;具体类&gt; (); 2. 菱形语法 泛型通配符及上限、下限 通配符 ? 可以匹配任意的引用类型 泛型通配符上限 ? extends E:接收E或者E的子类型 泛型通配符下限 ? super E:接收E或者E的父类型 类型参数 与通配符的区别 类型参数 可以表示一种类型 通配符 不能表示一种类型 类型参数只能指定上限 通配符可以指定上限,也可以指定下限 类型参数可以指定多个上限,用&amp;连接 通配符只能指定一个上限 123456789101112131415interface Info1 &#123;&#125;interface Info2 &#123;&#125;class Base &#123;&#125;class Sub extends Base implements Info1, Info2 &#123;&#125;//===类型参数===========class Point&lt;T extends Base &amp; Info1 &amp; Info2&gt; &#123;&#125;//===通配符参数===========class Point&lt;T extends Number&gt; &#123;&#125;class Point&lt;T super Integer&gt; &#123;&#125; 多个参数化类型,生成的字节码文件是同一个在生成字节码的时候,会擦除掉形式类型参数String 是 Object 的子类Object类型 = String类型 (可行) Point&lt;String&gt; 不是 Point&lt;Object&gt;的子类,泛型只是检查类型 泛型类举例 一个属性 123456789101112131415161718192021class Apple&lt;T&gt; &#123; private T size; public Apple(T size) &#123; this.size = size;&#125; public T getSize() &#123; return size;&#125; public void setSize(T size) &#123; this.size = size;&#125;&#125;public class Demo2 &#123; public static void main(String[] args) &#123; Apple&lt;Integer&gt; apple = new Apple(10); apple.setSize(100); Apple&lt;? super Integer&gt; apple2 = new Apple(1.0);// Integer --Number --子类 apple2.getSize(); Apple&lt;? extends String&gt; apple3 = new Apple(&quot;123&quot;);// Integer --Number apple2.getSize(); &#125;&#125; 二个属性 12345678910111213141516171819202122232425class Contacts&lt;K, V&gt; &#123; private K id; private V Tel; public Contacts(K id, V tel) &#123; this.id = id; Tel = tel; &#125; public K getId() &#123; return id;&#125; public void setId(K id) &#123; this.id = id;&#125; public V getTel() &#123; return Tel; &#125; public void setTel(V tel) &#123; Tel = tel;&#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; Contacts&lt;?,String&gt; contacts = new Contacts(1, &quot;123456&quot;); System.out.println(contacts.getId()+&quot;---&quot;+contacts.getTel()); &#125;&#125; 泛型类使用总结: 根据类的属性设置类型参数 参数只能指定上限(extend),不能下限 参数类型可以指定多个上限 使用泛型类的时候 使用通配符控制属性类型的范围 泛型构造器 使用泛型构造器的时候,不要使用菱形语法 定义:123&lt;E&gt; 类名(E e)&#123; //代码块&#125; 使用: 参数化类型 引用名 = new 泛型类名&lt;&gt;(); 参数化类型 引用名 = new &lt;E&gt;泛型类名&lt;&gt;(); //会报错 参数化类型 引用名 = new &lt;E&gt;泛型类名&lt;具体类型&gt;(); 例子12345678910111213141516//定义泛型构造器public &lt;E&gt; Demo(E e)&#123; System.out.println(e);&#125;// 类型推断,根据参数推断Demo&lt;String&gt; demo = new Demo&lt;&gt;(123); 由123 得到&lt;E&gt; 是 IntegerDemo&lt;String&gt; demo2 = new &lt;Integer&gt; Demo&lt;&gt;(12); //报错,不使用菱形语法Demo&lt;String&gt; demo2 = new &lt;Integer&gt; Demo&lt;String&gt;(&quot;12&quot;); //报错 给定了&lt;E&gt;是Integer ,传入字符串&quot;12&quot;会报错Demo&lt;String&gt; demo2 = new &lt;Integer&gt; Demo&lt;String&gt;(12); //编译通过Demo&lt;String&gt; demo3 = new &lt;String &gt; Demo&lt;String&gt;(&quot;12&quot;); //编译通过 泛型方法1234567891011121314151617181920212223242526272829class Demo&#123; //泛型方法定义 public &lt;T&gt; void f(T t) &#123; System.out.println(t); &#125; public &lt;T extends Object&gt; T ff(T t) &#123; //调用了泛型方法 //类型推断 f(&quot;hello&quot;); //显示指定具体的类型时 必须 用对象调用 this.&lt;String&gt;f(&quot;hellotom&quot;); this.&lt;Integer&gt;f(123); return t; &#125;&#125;public class TestPoint3 &#123; public static void main(String[] args) &#123; Demo d = new Demo(); //类型推断，根据参数推断 d.f(&quot;hello&quot;); d.f(22); // d.&lt;String&gt;f(&quot;hellotom&quot;); d.&lt;Double&gt;f(22.2); &#125;&#125; 泛型的擦除 泛型是编译的检查生成的字节码的时候会擦除 擦除原则： 对于参数化类型:Point&lt;String&gt; 擦除后 为 原生类型:Point 对于类型参数: 无界类型参数,擦除后为object private T a; -----&gt; private Object a; &lt;T&gt; void f(T t) -----&gt; void f( Object a); 有界:public 有一个上限 用上限替换 有多个上限 用第一个上限来替换 &lt;T extends Number&gt; void f(T t) -----&gt; void f( Number a); &lt;T extends Base &amp; Info1&gt; void f(T t) -----&gt; void f( Base a); &lt;T extends Info2 &amp; Info1&gt; void f(T t) -----&gt; void f( Info2 a); 泛型的重载 重载:参数名相同,参数列表不同 12345678910111213141516class Point1&lt;T&gt; &#123;&#125;class Demo5 &#123; public void f(Point1&lt;String&gt; p) &#123;&#125; //Point t public void f(Point1&lt;Integer&gt; p) &#123;&#125; //Point t-----擦除后一样,不能重载------------------------------ &lt;T&gt; void f(T t) &#123;&#125;// Object t &lt;T extends Number&gt; void f(T t) &#123;&#125;// Number t-----擦除后不一样,能重载------------------------------ &lt;T extends Base &amp; Info1&gt; void f(T t) &#123;&#125;// Base t &lt;T extends Info1 &amp; Info2&gt; void f(T t) &#123;&#125;// Info1 t-----擦除后不一样,能重载------------------------------&#125; 重写: 父类擦除后与子类参数相同 12345678910111213class Parent &#123; // 父类擦除后与子类参数相同 public void f(Point&lt;String&gt; p) &#123;&#125;// Point p class Child extends Parent &#123; @Override public void f(Point p) &#123; &#125; &#125;&#125; 泛型接口实现泛型接口 1. 知道类型的实现:(创建原生类) - `class 类名 implements 接口名&lt;类型&gt;` 2. 不知道类型的实现:(创建泛型类) - `class 类名&lt;T&gt; implements 接口名&lt;T&gt;` 123456789101112131415161718192021222324252627//定义泛型接口interface IA&lt;T&gt;&#123; void af(T t);&#125;// 1. 能确定类型class IAImpl1 implements IA&lt;String&gt;&#123; @override public void af(String t)&#123; System.out.println(t); &#125;&#125;// 1. 不能确定类型class IAImpl2&lt;T&gt; implements IA&lt;T&gt;&#123; @override public void af(T t)&#123; System.out.println(t); &#125;&#125;//测试public static void main(String[] args) &#123; IAImpl2&lt;Integer&gt; ia = new IAImpl2&lt;&gt;(); ia.af(34); IAImpl2&lt;String&gt; ia1 = new IAImpl2&lt;&gt;(); ia1.af(&quot;abc&quot;);&#125; 比较器Comparable 自然排序使用默认使用自然排序 ;升序规则写在 int compareTo()方法, 使用Comparable接口：让待排序对象所在的类实现Comparable接口，并重写Comparable接口中的compareTo()方法缺点是只能按照一种规则排序 Comparator : 外部比较器 自定义比较器使用 使用Comparator接口：编写多个排序方式类实现Comparator接口，并重写新Comparator接口中的compare()方法 public static &lt;T&gt; void sort(T[] a,Comparator&lt;? super T&gt; c),根据指定比较器产生的顺序对指定对象数组进行排序。数组中的所有元素都必须是通过指定比较器可相互比较的 （也就是说，对于数组中的任何 e1 和 e2 元素而言，c.compare(e1, e2)不得抛出 ClassCastException）。 优点是可以按照多种方式排序，你要按照什么方式排序，就创建一个实现Comparator接口的排序方式类，然后将该排序类的对象传入到Arrays.sort(待排序对象，该排序方式类的对象) Comparable和Comparator区别： 位置。 Comparable代码写在要比较的类中； Comparator代码写在要比较的类外； 个数。 Comparable就定义一种： Comparator可以定义多个比较方式。 枚举有的时候一个类的对象是有限且固定的，这种情况下我们使用枚举类就比较方便.实际上 enum 就是一个 class，只不过 java 编译器帮我们做了语法的解析和编译而已。 枚举类 语法 12345678910111213enum 枚举名称&#123; 对象,第一行处; 构造; //private 方法(); 抽象方法(); 所有对象实现了抽象方法,那么此枚举类就是一个抽象枚举类 重写方法; 实现接口 接口的方法要在对象中重写,(使用的是匿名内部类) 生成了字节码文件&#125;反编译: javap (-private) 包名.枚举名 注意事项 隐式的继承了 java.lang.Enum类; 对于一个非抽象的枚举类,默认是final的 枚举类的对象必须 在枚举类的第一行代码处显示列举出来 这些枚举对象都是 public static final; 枚举类的构造器都是私有privatae的 所有对象实现了抽象方法,那么此枚举类就是一个抽象枚举类 常用方法 int compareTo(E o) 比较此枚举与指定对象的顺序。 Class&lt;E&gt; getDeclaringClass() 返回与此枚举常量的枚举类型相对应的 Class 对象。 String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明。 int ordinal() 返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）。 String toString() 返回枚举常量的名称，它包含在声明中。 static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) 返回带指定名称的指定枚举类型的枚举常量。 对象 必须在枚举类的第一行列举对象都是 public static final; 1234enum Color &#123; //枚举类的对象 RED,BLUE,GREEN;&#125; 成员变量12345678910111213141516171819202122enum Color &#123; private int no; private String name; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//使用: 访问成员变量Color.RED.setNo(11);Color.RED.setName(&quot;红色&quot;);System.out.println(Color.RED.getNo());System.out.println(Color.RED.getName()); 构造方法 构造方法是private的.有构造方法,需要修改对象 1234567891011121314151617181920212223242526272829303132enum Color implements InfoNew&#123;//对象-------------------- RED(1,&quot;红&quot;); //构造 private Color(int no, String name) &#123; this.no = no; this.name = name; &#125; //成员变量 private int no; private String name; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;//使用//------------------构造赋值，访问成员变量-------------System.out.println(Color.RED.getNo());System.out.println(Color.RED.getName()); 普通方法12345678enum Color &#123; public void show() &#123; System.out.println(&quot;普通方法&quot;); &#125;&#125;//使用:对象都是静态的Color.RED.show(); 抽象方法 如果有抽象方法,对象必须实现抽象方法实现了抽象方法(匿名内部类),那么此枚举类就是一个抽象枚举类 1234567891011121314enum Color &#123;RED(1,&quot;红色&quot;) &#123; @Override public void af() &#123; System.out.println(&quot;实现了 RED的抽象方法&quot;); &#125; &#125;; //抽象方法 public abstract void af();&#125;//-------------------抽象方法--------------------------------------Color.RED.af(); 实现接口 实现一个接口,枚举对象要重写抽象方法(匿名内部类) 1234567891011121314151617interface InfoNew&#123; void ff();&#125;enum Color implements InfoNew &#123;//对象 RED(1,&quot;红色&quot;) &#123; @Override public void af() &#123; System.out.println(&quot;实现了 RED的抽象方法&quot;); &#125; @Override public void ff() &#123; System.out.println(&quot;实现了接口的抽象方法&quot;); &#125; &#125;;&#125; 重写 重写toString() 12345678910enum Color&#123; RED; @Override public String toString() &#123; return no + &quot;,&quot; + name; &#125;&#125;//------------------重写--------System.out.println(Color.RED.toString()); 枚举类的遍历1234for(Color c : Color.values())&#123; System.out.println(c.ordinal()); System.out.println(c.name());&#125; switch使用 switch(表达式)表达式类型:byte short int char String enum使用枚举类对象=枚举类.valueOf(String str)str不是枚举类的对象会抛出异常IllegalArgumentException 123456789101112131415Scanner input = new Scanner(System.in);System.out.println(&quot;输入颜色：&quot;);String s = input.next();Color cr = Color.valueOf(s);switch(cr) &#123; case RED: System.out.println(&quot;红色&quot;); break; case GREEN: System.out.println(&quot;绿色&quot;); break; case BLUE: System.out.println(&quot;蓝色&quot;); break;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据库设计]]></title>
    <url>%2Fblog%2F2018%2F08%2F13%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[需求设计 概要设计： 抽取实体：业务模型 -&gt; 实体模型（java 类 c++类）内存 class Book{ name, bookNo,author } 数据库设计: 业务模型/实体模型 - &gt; 数据模型 (硬盘) 数据库表设计 详细设计 类详细，属性和方法 三大范式 设计原则： 建议设计的表尽量遵守三大范式。 第一范式： 要求表的每个字段必须是不可分割的独立单元1234student : name -- (大名小名在一起)违反第一范式 张小名|狗娃 sutdent ： name old_name --符合第一范式 张小名 狗娃 第二范式： 在第一范式的基础上，要求每张表只表达一个意思。表的每个字段都和表的主键有依赖。12345employee（员工）: 员工编号 员工姓名 部门名称 订单名称 --违反第二范式(订单和编号没有依赖关系)员工表：员工编号 员工姓名 部门名称 订单表： 订单编号 订单名称 -- 符合第二范式 第三范式： 在第二范式基础，要求每张表的主键之外的其他字段都只能和主键有直接决定依赖关系。1234员工表： 员工编号（主键） 员工姓名 部门编号 部门名 --符合第二范式，违反第三范式 （数据冗余高）员工表：员工编号（主键） 员工姓名 部门编号 --符合第三范式（降低数据冗余）部门表：部门编号 部门名 MySQL常用数据类型 分类 数据类型 说明 数值类型 BIT(M) bit bit(8) 位类型。M指定位数，默认值1，范围1-64 数值类型 TINYINT [UNSIGNED] [ZEROFILL] byte 带符号的范围是-128到127。无符号0到255。 数值类型 BOOL，BOOLEAN boolean 使用0或1表示真或假 数值类型 SMALLINT [UNSIGNED] [ZEROFILL] short 2的16次方 数值类型 INT [UNSIGNED] [ZEROFILL] int 2的32次方 数值类型 BIGINT [UNSIGNED] [ZEROFILL] long 2的64次方 数值类型 FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] float M指定显示长度，d指定小数位数 数值类型 DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL] double 表示比float精度更大的小数 文本、二进制类型 CHAR(size) char(20) max—255 abc 固定长度字符串 文本、二进制类型 VARCHAR(size) varchar(20) 65535 abcde String 可变长度字符串 文本、二进制类型 BLOB LONGBLOB 大的二进制数据 二进制文本数据 文本、二进制类型 TEXT(clob) LONGTEXT(longclob) 大文本数据 大文本 时间日期 DATE/DATETIME/TimeStamp 日期类型(YYYY-MM-DD) (YYYY-MM-DD HH:MM:SS)，TimeStamp表示时间戳，它可用于自动记录insert、update操作的时间 VARCHAR、BLOB和TEXT类是变长类型。每个类型的存储需求取决于列值的实际长度。 mysql中文乱码123456789101112mysql有六处使用了字符集，分别为：client 、connection、database、results、server 、system。client是客户端使用的字符集。 connection是连接数据库的字符集设置类型，如果程序没有指明连接数据库使用的字符集类型就按照服务器端默认的字符集设置。 database是数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将使用服务器安装时指定的字符集设置。 results是数据库给客户端返回时使用的字符集设定，如果没有指明，使用服务器默认的字符集。 server是服务器安装时指定的默认字符集设定。 system是数据库系统使用的字符集设定。查看和修改数据库字符集show variables like &apos;character%&apos;;set character_set_results=gbk;set character_set_client=gbk; 多表查询(关联查询)交叉连接查询123-- 需求：查询员工及其所在部门(显示员工姓名，部门名称)-- 2.1 交叉连接查询（不推荐。产生笛卡尔乘积现象：4 * 4=16，有些是重复记录）SELECT empName,deptName FROM employee,dept; 内连接查询12345-- 内连接的另一种语法select 内容 from 表inner join 表on 二表之间的联系 12345678910111213141516171819202122-- 需求：查询员工及其所在部门(显示员工姓名，部门名称)-- 多表查询规则： 1）确定查询哪些表 2）确定哪些哪些字段 3）表与表之间连接条件 (规律：连接条件数量是表数量-1)-- 2.2 内连接查询：只有满足条件的结果才会显示(使用最频繁)SELECT empName,deptName -- 2）确定哪些哪些字段 FROM employee,dept -- 1）确定查询哪些表 WHERE employee.deptId=dept.id -- 3）表与表之间连接条件 -- 内连接的另一种语法SELECT empName,deptName FROM employee INNER JOIN dept ON employee.deptId=dept.id;-- 使用表的别名SELECT e.empName,d.deptName FROM employee e INNER JOIN dept d ON e.deptId=d.id; 外连接左[外]连接查询： 使用左边表的数据去匹配右边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null (注意： 左外连接：左表的数据一定会完成显示！） – 需求： 查询每个部门的员工– 预期结果： – 软件开发部 张三 – 软件开发部 李四 – 应用维护部 王五 – 秘书部 陈六 – 总经办 null 1234567SELECT d.deptName,e.empName FROM dept d LEFT OUTER JOIN employee e ON d.id=e.deptId; 右[外]连接查询: 使用右边表的数据去匹配左边表的数据，如果符合连接条件的结果则显示，如果不符合连接条件则显示null （注意： 右外连接：右表的数据一定会完成显示！） 1234SELECT d.deptName,e.empName FROM employee e RIGHT OUTER JOIN dept d ON d.id=e.deptId; 自连接查询12345678910-- 需求：查询员工及其上司-- 预期结果： -- 张三 null -- 李四 张三 -- 王五 李四 -- 陈六 王五SELECT e.empName,b.empName FROM employee e LEFT OUTER JOIN employee b ON e.bossId=b.id; 存储过程 存储过程是带有逻辑的sql语句之前的sql语句没有条件判断,也没有循环存储过程带上流程控制语句(if,while) 特点: 执行速度非常快!存储过程是在数据库的服务器端执行的 移植性很差,不同数据库的存储过程是不能移植的 语法创建存储过程1234567delimiter $ --声明存储过程的结束符create procedure pro_test() --存储过程名称(参数列表)begin -- 开始 ///////////////////////////// //// SQL 语句 + 流程控制语句// /////////////////////////////end $ 执行存储过程 call pro_test –call 存储过程名称(参数) 存储过程的参数 in :表示输入参数,可以携带数据到存储过程中 out: 表示输出参数,可以从存储过程中返回结果 inout : 表示输入输出参数,既可以输入功能, 也可以输出功能 带有输入参数的存储过程123456789需求: 传入一个员工的id,查询员工信息delimiter $create procedure pro_findById(in eid int) -- in : 输入参数begin select * from employee where id = eid; End $// 调用 ////////call pro_findById(4); 带有输出参数的存储过程12345678910delimiter $ create procedure pro_testOut(Out str varchar(20)) --out: 输出参数begin -- 给参数赋值 set str = &quot;hello java&quot;;End $使用:call pro_testOut(@name);selec @name 接收返回参数的值mysql的变量 全局变量 123456全局变量（内置变量）：mysql数据库内置的变量 （所有连接都起作用）-- 查看所有全局变量： show variables-- 查看某个全局变量： select @@变量名-- 修改全局变量： set 变量名=新值-- character_set_client: mysql服务器的接收数据的编码-- character_set_results：mysql服务器输出数据的编码 会话变量 123会话变量： 只存在于当前客户端与数据库服务器端的一次连接当中。如果连接断开，那么会话变量全部丢失！-- 定义会话变量: set @变量=值-- 查看会话变量： select @变量 局部变量 局部变量： 在存储过程中使用的变量就叫局部变量。只要存储过程执行完毕，局部变量就丢失！！ 带有输入输出参数的存储过程1234567891011121314151617181920```mysqlDELIMITER $CREATE PROCEDURE pro_testInOut(INOUT n INT)BEGIN SELECT n; SET n=50;END $//使用SET @n=10;CALL pro_testInOut(@n); -- n 10SELECT @n; -- n 50 带有条件判断的存储过程 If – then – elseif – then –else –end if this ,end if 后面有分号; 1234567891011121314151617181920212223-- 需求：输入一个整数， 如果1，则返回“星期一”, 如果2，返回“星期二”, 如果3，返回“星期三”。 其他数字，返回“错误输入”;DELIMITER $ CREATE PROCEDURE pro_testIf(IN n INT,OUT str VARCHAR(20))BEGIN IF n=1 THEN SET str = &apos;星期一&apos;; ELSEIF n=2 THEN SET str=&apos;星期二&apos;; ELSEIF n=3 THEN SET str = &apos;星期四&apos;; ELSE SET str=&apos;输入错误&apos;; END IF;END $//使用CALL pro_testIf(1,@str)SELECT @str -- str 星期一 带有循环功能的存储过程 需要声明会话变量 while – do – end while; do 后面的都要分号 end while 要分号 1234567891011121314-- 需求： 输入一个整数，求和。例如，输入100，统计1-100的和BEGIN DECLARE i INT DEFAULT 1; DECLARE vsum INT default 0; WHILE i&lt;=num DO SET vsum = vsum+i; SET i=i+1; END WHILE; SET result = vsum;END $//使用CALL pro_testWhile(100,@result);SELECT @result; -- 5050 使用查询的结果赋值给变量 into12345678910DELIMITER $ CREATE PROCEDURE pro_finById2(IN eid INT,OUT vname VARCHAR(20))BEGIN SELECT empName INTO vname FROM employee WHERE id =eid;END $//使用CALL pro_finById2(1,@name)SELECT @name 删除存储过程DROP PROCEDURE pro_testOut; 触发器 当操作了某张表时,希望同时触发一些动作/行为 可以使用触发器当向员工表插入一条记录时，希望同时往日志表插入数据 动作: 添加 修改 删除 修改12345678910111213141516171819需求： 当向员工表插入一条记录时，希望mysql自动同时往日志表插入数据-- 创建触发器(添加)CREATE TABLE test_log( id INT(4) ZEROFILL PRIMARY KEY AUTO_INCREMENT, content VARCHAR(20))CREATE TRIGGER tri_update AFTER UPDATE ON employee FOR EACH ROW INSERT INTO test_log(content) VALUES (&apos;员工表修改了一条记录&apos;) UPDATE employee SET empName =&apos;123&apos; WHERE id =5SELECT * FROM test_log; 0001 员工表修改了一条记录//测试CREATE TRIGGER tri_empUpd AFTER UPDATE ON employee FOR EACH ROW -- 当往员工表修改一条记录时 INSERT INTO test_log(content) VALUES(&apos;员工表修改了一条记录&apos;); 添加1234CREATE TRIGGER tri_empAdd AFTER INSERT ON employee FOR EACH ROW -- 当往员工表插入一条记录时 INSERT INTO test_log(content) VALUES(&apos;员工表插入了一条记录&apos;);INSERT INTO employee(id,empName,deptId) VALUES(5,&apos;扎古斯&apos;,1); 删除12CREATE TRIGGER tri_empDel AFTER DELETE ON employee FOR EACH ROW -- 当往员工表删除一条记录时 INSERT INTO test_log(content) VALUES(&apos;员工表删除了一条记录&apos;); mysql权限问题 root :拥有所有权限(可以干任何事情); 权限账户: 只拥有部分权限(CRUD) :例如:只能操作某个数据库的某张表 修改mysql 的密码 数据库的密码采用MD5加密(单向加密)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>三大范式</tag>
        <tag>多表查询</tag>
        <tag>表约束</tag>
        <tag>表连接</tag>
        <tag>触发器</tag>
        <tag>存储过程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day12]]></title>
    <url>%2Fblog%2F2018%2F08%2F13%2Fjava%E5%9F%BA%E7%A1%80day12%2F</url>
    <content type="text"><![CDATA[概述函数式接口:接口中只有一个抽象方法 Lambda 只能实现函数式接口 具体用法参考:Lanbda表达式 方法传参 一个class的方法的形式参数是一个函数式接口, 这个时候可以传一个lambda 表达式 返回的对象必须是接口,强转为Object Object 0 =(Run) ()-&gt; System.out.println(“Hello.”); 匿名内部类和 Lambda的区别 Lambda 只能实现函数式接口 匿名内部类 可以是继承一个父类 或 实现 一个父类接口 Lambda 只能针对 函数式接口的抽象方法 匿名内部类可以调用非抽象方法, 如 默认方法等. 方法引用 前提:Lambda 只有一行代码 ,只调用了一个方法 引用类方法(静态方法) 类名::类方法 1234567891011121314151617181920212223242526272829303132interface La&#123; Integer f(String s);&#125;class Student&#123; private String name; Student(String name)&#123; this.name = name; &#125;&#125;interface La1&#123; Student f(String name);&#125;============================================= //1.引用 类方法 // La la1 = s-&gt;&#123;return Integer.parseInt(s);&#125;; La la1 = s -&gt; Integer.parseInt(s); La la2 = Integer::parseInt; //2.特定对象 引用 实例方法 La la3 = s-&gt;&quot;hello&quot;.indexOf(s); La la4 = &quot;hello&quot;::indexOf; //3.某类对象 的实例方法 La la5 = s-&gt;s.length(); La la6 = String::length; //4.引用构造器 La1 la7 = s-&gt;new Student(s); La1 la8 = Student::new; 引用实例(1.8下)一元运算 static void parallelSetAll(int[] array, IntUnaryOperator generator) 123456789101112131415//用 索引 替换掉 数组中的元素int [] arr = &#123;1,2,3,4,5&#125;;Arrays.parallelSetAll(arr, new IntUnaryOperator() &#123; @Override public int applyAsInt(int operand) &#123; // 数组的索引 return operand; &#125;&#125;);//使用引用Arrays.parallelSetAll(arr,index-&gt;index );System.out.println(Arrays.toString(arr)); //[0, 1, 2, 3, 4] 二元运算 static void parallelPrefix(int[] array, IntBinaryOperator op) 12345678910111213//用 二元运算的结果 来替换掉数组的每一个元素Arrays.parallelPrefix(arr, new IntBinaryOperator() &#123; // left -前一个元素 right:当前元素 @Override public int applyAsInt(int left, int right) &#123; // 当前元素是第一个元素 ，前一个元素 是1 return left * right; &#125;&#125;);//使用引用Arrays.parallelPrefix(arr,(n1,n2)-&gt;n1*n2 );System.out.println(Arrays.toString(arr)); //[1, 2, 6, 24, 120] 遍历数组 Stream流的方法 static IntStream stream(int[] array) 123456789101112131415161718Arrays.stream(arr).forEach(new IntConsumer() &#123; //value数组元素 @Override public void accept(int value) &#123; System.out.println(value); &#125;&#125;);//LambdaArrays.stream(arr).forEach(num-&gt;System.out.println(num));//方法引用Arrays.stream(arr).forEach(System.out::println);结果: 1 2 3 4 5 异常 显示从开始到调用的位置显示堆栈错误信息 Throwable 异常的父类 Error 不能通过代码处理 Exception - 通过代码可以解决 运行时异常 RuntimeException和它的子类 它的代码可以不用处理,但是出现异常会中断 非运行时的异常(受检异常):Exception类 和部分子类 在源代码中,必须进行异常处理,否则无法编译运行 常见的异常:12345678910111213141516171819202122232425262728291.ArithemeticException x=5/0;2. ArrayIndexOutofBoundsException int[] arr = &#123;1,2&#125;; arr[2]=5;3. NullPointerException String s = null; System.out.println(s.equals(&quot;abc&quot;));//空指针 //有些类能处理异常 System.out.println(Objects.equals(&quot;abc&quot;));//false不会报错 System.out.println(Objects.hashCode(s));//不会报错4. InputMismatchException:欲得到的数据类型与输入不匹配 Scanner下控制输入不匹配5. ClassCastException:对象强制类型转换出错 Object o = new Object(); Integer i = (Integer)o;6. NumberFormatException: 数字格式化异常 String s =&quot;123a&quot;; int n = Integer.parseInt(s);7. ClassNotFoundException: 不能加载所需的类 ClassLoader.getSystemClassLoader().loadClass(&quot;包名.类名&quot;); 8. illegalArgumentException: 方法接收到非法参数 异常的处理try-catch try 里面放可能会引发异常的代码catch 放引发异常的类型 getMessage();获取异常的消息 printStackTrace()打印堆栈的错误信息 格式:12345678public void method()&#123; try&#123; //代码段（此处可能会产生异常_ ）catch(异常类型 ex)&#123; //对异常进行处理的代码段 &#125; //代码段&#125; 结果: 没有引发异常 执行了try ,没有catch 引发了异常类型的匹配 执行try ,也执行了catch 出现了异常,但是异常类型不匹配 出现了中断 多重catch块 可以对不同类型的异常采取不同的处理方式防止出现不知道的异常,加入父类顺序:由子类到父类,由一般 到 特殊, 由常见 到 不常见 1234567891011121314151617public void method()&#123; try&#123; //代码段（此处可能会产生异常_ ）catch(异常类型 ex)&#123; //对异常进行处理的代码段 &#125;catch(异常类型 ex)&#123; //对异常进行处理的代码段 &#125; .... catch(异常类型 ex)&#123; //对异常进行处理的代码段 &#125;catch(异Exception e)&#123; //对异常进行处理的代码段 &#125;&#125; 例子: 123456789101112131415161718192021public static void main(String[] args) &#123; int [] arr = new int[5]; Scanner input = new Scanner(System.in); System.out.println(&quot;赋值;&quot;); try &#123; for(int i = 0; i &lt; arr.length; i++) &#123; arr[i] = input.nextInt(); &#125; Arrays.stream(arr).forEach(System.out::println); &#125;catch(ArrayIndexOutOfBoundsException e) &#123; System.out.println(&quot;下标越界&quot;); &#125;catch(InputMismatchException e) &#123; System.out.println(&quot;赋值出错了&quot;); &#125;catch(Exception e) &#123; System.out.println(e.getMessage()); &#125;finally &#123; System.out.println(&quot;程序运行出错&quot;); &#125; &#125; 出现异常必须执行的代码 放入到finaly 的代码;除非虚拟机退出,否则一定会执行.无论是否触发异常也会执行.通常用来释放资源6 123456789public void method()&#123; try&#123; //代码段（此处可能会产生异常_ ）catch(异常类型 ex)&#123; //对异常进行处理的代码段 &#125; finaly&#123; //一定执行的代码段 &#125;&#125; 声明抛出throws 声明异常:给调用者处理随调用谁处理 必须处理:Exception是受检异常,必须处理 调用者处理: try-catch 抛给虚拟机(不推荐) 灵活处理:throws RuntimeException 抛出受检异常 1234567891011121314public void f() throws Exception&#123; Scanner input = new Scanner(System.in); int x = input.nextInt(); int y = input.nextInt(); int z = x / y; System.out.println(z);&#125;try &#123; new TestException5().f(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 抛出运行期异常 123456789101112131415public void f() throws RuntimeException&#123; Scanner input = new Scanner(System.in); int x = input.nextInt(); int y = input.nextInt(); int z = x / y; System.out.println(z);&#125;//需要手动try-catchtry &#123; new TestException5().f(); &#125; catch (RuntimeException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 抛出异常自己手动throw 抛出一个异常对象 抛出一个受检异常 ,方法必须要throws声明一下 调用者必须处理. 抛出一个运行时异常, 不需要throws 声明 抛出受检异常 1234567891011121314151617181920public void setAge(int age)throws AgeException &#123; if(age &gt;= 0 &amp;&amp; age &lt;= 150) &#123; this.age = age; &#125;else &#123; //抛异常对象 throw new Exception(&quot;年龄必须在 0 - 150之间&quot;); &#125;&#125;测试:public static void main(String[] args) &#123; Person zhangsan = new Person(); try &#123; zhangsan.setAge(250); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 自定义异常1234567891011121314151617181920212223242526class AgeException extends Exception&#123; /*AgeException(String str)&#123; super(str);//调用父类构造传参 &#125;*/ private String message; AgeException(String message)&#123; this.message = message; &#125; @Override public String getMessage() &#123; // TODO Auto-generated method stub return &quot;message:&quot; + message; &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return &quot;string:&quot; + message; &#125; @Override public void printStackTrace() &#123; System.out.println(&quot;stack:&quot; + message); &#125; &#125; 12345678910111213141516171819202122232425262728293031class Person&#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age)throws AgeException &#123; if(age &gt;= 0 &amp;&amp; age &lt;= 150) &#123; this.age = age; &#125;else &#123; //抛异常对象 throw new AgeException(&quot;年龄必须在 0 - 150之间&quot;); &#125; &#125;&#125;/////////////////////////////////////////////public static void main(String[] args) &#123; Person zhangsan = new Person(); try &#123; zhangsan.setAge(222); &#125; catch (AgeException e) &#123; e.printStackTrace(); System.out.println(e); System.out.println(e.getMessage()); &#125;&#125;/////////////////////////////////////////////stack:年龄必须在 0 - 150之间string:年龄必须在 0 - 150之间message:年龄必须在 0 - 150之间 异常处理的原则 只用于处理非正常的情况； 12345678910111213141516String [] arr = &#123;&quot;hello&quot;,&quot;hello&quot;,&quot;hello&quot;&#125;;//--正常的写法-------------------------------for(int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;//--异常处理的写法---(不推荐)--------------------------- try &#123; for(int i = 0; ; i++) &#123; System.out.println(arr[i]); &#125;&#125; catch (Exception e) &#123; &#125;System.out.println(&quot;其他的代码&quot;);&#125; 避免过大的try 使用多重catch 不要忽略catch块儿中的异常 改正代码 文档声明 12345/** * * @param args * @throws Exception */]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql的数据约束]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2Fmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BA%A6%E6%9D%9F%2F</url>
    <content type="text"><![CDATA[SQL语句的分类： DDL： 数据定义语言 create / drop / alter DML：数据操作语句 insert / delete /update / truncate DQL： 数据查询语言： select / show 数据约束 对用户操作表的数据进行约束 默认值(default) 作用:当用户对使用默认值的字段不插入值的时候，就使用默认值。 注意: 对默认值字段插入null是可以的。 对默认值字段可以插入非null 123456789101112CREATE TABLE student( id INT, NAME VARCHAR(20), address VARCHAR(20) DEFAULT &apos;广州天河&apos; -- 默认值)当字段没有插入值的时候，mysql自动给该字段分配默认值INSERT INTO student(id,NAME) VALUES(1,&apos;张三&apos;);注意：默认值的字段允许为nullINSERT INTO student(id,NAME,address) VALUE(2,&apos;李四&apos;,NULL);INSERT INTO student(id,NAME,address) VALUE(3,&apos;王五&apos;,&apos;广州番禺&apos;); 非空(not null) 作用： 限制字段必须赋值 注意： 非空字符必须赋值 非空字符不能赋null 1234567891011CREATE TABLE student( id INT, NAME VARCHAR(20), gender VARCHAR(2) NOT NULL -- 非空)-- 非空字段必须赋值INSERT INTO student(id,NAME) VALUES(1,&apos;李四&apos;);-- 非空字符不能插入nullINSERT INTO student(id,NAME,gender) VALUES(1,&apos;李四&apos;,NULL); //出错 唯一(unique) 作用： 对字段的值不能重复 注意： 唯一字段可以插入null 唯一字段可以插入多个null 123456789CREATE TABLE student( id INT UNIQUE, -- 唯一 NAME VARCHAR(20))INSERT INTO student(id,NAME) VALUES(1,&apos;zs&apos;);INSERT INTO student(id,NAME) VALUES(1,&apos;lisi&apos;); -- ERROR 1062 (23000): Duplicate entry &apos;1&apos; for key &apos;id&apos;INSERT INTO student(id,NAME) VALUES(2,&apos;lisi&apos;); 主键(非空,唯一) 作用： 非空+唯一 注意： 通常情况下，每张表都会设置一个主键字段。用于标记表中的每条记录的唯一性。 建议不要选择表的包含业务含义的字段作为主键，建议给每张表独立设计一个非业务含义的id字段。 12345678910CREATE TABLE student( id INT PRIMARY KEY, -- 主键 NAME VARCHAR(20))INSERT INTO student(id,NAME) VALUES(1,&apos;张三&apos;);INSERT INTO student(id,NAME) VALUES(2,&apos;张三&apos;);-- INSERT INTO student(id,NAME) VALUES(1,&apos;李四&apos;); -- 违反唯一约束： Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;-- insert into student(name) value(&apos;李四&apos;); -- 违反非空约束： ERROR 1048 (23000): Column &apos;id&apos; cannot be null 自增长(auto_increment) 自动递增 id int(4): 设置长度为4位 insert into student(NAME) VALUES(&#39;张三&#39;); 结果: id 0001 12345678910111213141516CREATE TABLE student( id INT(4) ZEROFILL PRIMARY KEY AUTO_INCREMENT, -- 自增长，从0开始递增,第一条为1 ZEROFILL 零填充 NAME VARCHAR(20))-- 自增长字段可以不赋值，自动递增INSERT INTO student(NAME) VALUES(&apos;张三&apos;);INSERT INTO student(NAME) VALUES(&apos;李四&apos;);INSERT INTO student(NAME) VALUES(&apos;王五&apos;);-- 删除后自增长的区别 -- delete不能影响自增长约束,从上次删除的数开始 DELETE FROM student; -- 可以影响自增长约束,从0开始 TRUNCATE TABLE student; 外键 constraint 约束名 foreign key (外键) references (主键)约束二张表的数据 例如： 员工表 和 部门表 问题出现：在插入员工表数据的时候，员工表的部门ID字段可以随便插入！！！！！ 出现两种表的情况 解决数据冗余高问题： 独立出一张表(1万员工就1万部门,冗余度高) 使用外键约束：约束插入员工表的部门ID字段值 123456789101112131415-- 部门表（主表）CREATE TABLE dept( id INT PRIMARY KEY, deptName VARCHAR(20))-- 修改员工表（副表/从表）CREATE TABLE employee( id INT PRIMARY KEY, empName VARCHAR(20), deptId INT,-- 把部门名称改为部门ID -- 声明一个外键约束 CONSTRAINT emlyee_dept_fk FOREIGN KEY(deptId) REFERENCES dept(id) -- 外键名称 外键 参考表(参考字段)) 注意： 被约束的表称为副表，约束别人的表称为主表，外键设置在副表上的！！！ 主表的参考字段通用为主键！ 添加数据： 先添加主表，再添加副表 修改数据： 先修改副表，再修改主表 删除数据： 先删除副表，再删除主表 123456789101112131415161718192021222324INSERT INTO dept(id,deptName) VALUES(1,&apos;软件开发部&apos;);INSERT INTO dept(id,deptName) VALUES(2,&apos;应用维护部&apos;);INSERT INTO dept(id,deptName) VALUES(3,&apos;秘书部&apos;);INSERT INTO employee VALUES(1,&apos;张三&apos;,1);INSERT INTO employee VALUES(2,&apos;李四&apos;,1);INSERT INTO employee VALUES(3,&apos;王五&apos;,2);INSERT INTO employee VALUES(4,&apos;陈六&apos;,3);-- 1）当有了外键约束，添加数据的顺序： 先添加主表，再添加副表数据员工插入了一个不存在的部门数据INSERT INTO employee VALUES(5,&apos;陈六&apos;,4);-- 违反外键约束： Cannot add or update a child row: a foreign key constraint fails (`day16`.`employee`, CONSTRAINT `emlyee_dept_fk` FOREIGN KEY (`deptId`) REFERENCES `dept` (`id`))-- 2）当有了外键约束，修改数据的顺序： 先修改副表，再修改主表数据//确认副标不存在主表的关联数据 ,才能删除主表数据UPDATE dept SET id=4 WHERE id=3;//不能修改UPDATE employee SET deptId=2 WHERE id=4;-- 3）当有了外键约束，删除数据的顺序： 先删除副表，再删除主表数据//确认副标不存在主表的关联数据 ,才能删除主表数据DELETE FROM dept WHERE id=2; //不能删除DELETE FROM employee WHERE deptId=2; //删除副表 级联操作 on update cascade 当有了外键约束的时候，必须先修改或删除副表中的所有关联数据，才能修改或删除主表！但是，我们希望直接修改或删除主表数据，从而影响副表数据。可以使用级联操作实现！！！ 级联修改： ON UPDATE CASCADE 级联删除： ON DELETE CASCADE 联操作必须在外键基础上使用 12345678CREATE TABLE employee( id INT PRIMARY KEY, empName VARCHAR(20), deptId INT,-- 把部门名称改为部门ID -- 声明一个外键约束 CONSTRAINT emlyee_dept_fk FOREIGN KEY(deptId) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE CASCADE -- ON CASCADE UPDATE ：级联修改 -- 外键名称 外键 参考表(参考字段)) 1234567-- 级联修改（修改）-- 直接修改部门UPDATE dept SET id=5 WHERE id=4; //属于这个部门的员工的部门id也修改了-- 级联删除-- 直接删除部门 DELETE FROM dept WHERE id=1; //属于这个部门的员工也删除了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mysql的数据约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql的基本操作]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2FMysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[数据保存到内存： 优点: 读写速度快 缺点: 程序关闭导致数据丢失 数据保存到文件： 优点: 数据可以永久保存 缺点: 频繁地IO操作，效率不高 数据管理不方便。例如查询某个数据需要全部读取出来，再匹配。 数据保存到数据库软件： 优点: 数据永久保存下来 数据管理非常方便。（例如查询非常快速和方便） 数据库管理 查询所有的数据库 showe databases ; 创建数据库 create databases dbtest; create databases dbtest CHARACTER SET utf8 COLLATE utf8_general_ci; create database dbtest CHARACTER SET GBK COLLATE gbk_chinese_ci; 修改数据库的字符集 alter database dbtest CHARACTER SET GBK COLLATE gbk_chinese_ci; alter database dbtest CHARACTER SET utf8 COLLATE utf8_general_ci; 删除数据库 drop database dbtest; 查看所有的字符编码 SHOW CHARACTER SET; 查看创建数据库的指令并查看数据库使用的编码` show create database dbtest; 表管理 查看所有表 show tables; 创建表 123456create table tbtest( id int(10) auto_increment, user_name varchar(60) CHARACTER SET GBK COLLATE gbk_chinese_ci, email varchar(60), PRIMARY key(id))CHARACTER SET utf8 COLLATE utf8_general_ci; 查看表的结构 desc tbtest; 删除表 drop table tbtest; 修改表 添加字段 alter table student add column sgender varchar(2); 删除字段 alter table student drop column sgender varchar(2); 修改字段类型 alter table student modify column sgender varchar(2); 修改字段名称 alter table student change column sgender varchar(2); 修改表的名称 alter table student rename to teacher; 增删改数据 增加数据 插入所有字段。一定依次按顺序插入 INSERT INTO student VALUES(1,&#39;张三&#39;,&#39;男&#39;,20); 注意不能少或多字段值 INSERT INTO student VALUES(2,&#39;李四&#39;,&#39;女&#39;);//报错 插入部分字段 INSERT INTO student(id,NAME) VALUES(2,&#39;李四&#39;); 修改数据 修改所有数据（建议少用） UPDATE student SET gender=&#39;女&#39;; 带条件的修改（推荐使用） UPDATE student SET gender=&#39;男&#39; WHERE id=1; – 修改id为1的学生，修改性别为男 修改多个字段,注意: SET 字段名=值,字段名=值,…. UPDATE student SET gender=&#39;男&#39;,age=30 WHERE id=2; 删除数据 删除所有数据（建议少用） DELETE FROM student; 带条件的删除(推荐使用) DELETE FROM student WHERE id=2; 另一种方式 delete from: 可以全表删除 1)可以带条件删除 2）只能删除表的数据，不能删除表的约束 3)使用delete from删除的数据可以回滚（事务） truncate table: 可以全表删除 1）不能带条件删除 2）即可以删除表的数据，也可以删除表的约束 3）使用truncate table删除的数据不能回滚 TRUNCATE TABLE student; 查询数据查询所有列SELECT * FROM student; 查询指定列SELECT id,NAME,gender FROM student; 查询时添加常量列SELECT id,NAME,gender,age,&#39;常亮列&#39; AS &#39;年级&#39; FROM student; 查询时合并列 需求： 查询每个学生的servlet和jsp的总成绩1SELECT id,NAME,(servlet+jsp) AS &apos;总成绩&apos; FROM student; 注意：合并列只能合并数值类型的字段 SELECT id,(NAME+servlet) FROM student;//报错 查询时去除重复值 需求： 查询学生的性别 男 女 SELECT DISTINCT gender FROM student; SELECT DISTINCT(gender) FROM student; 条件查询(where)逻辑条件 and(与) or(或) 需求: 查询id 为2 ,且姓名为李四的人select * from student where sid =2 and sname = &#39;李四&#39;;– 交集 需求： 查询id为2，或姓名为张三的学生SELECT * FROM student WHERE id=2 OR NAME=&#39;张三&#39;; – 并集 比较条件: > &lt; >= &lt;= = &lt;&gt;(不等于) between and(等价于&gt;= and &lt;=) 需求： 查询servlet成绩大于70分的学生SELECT * FROM student WHERE jsp&gt;=75 AND jsp&lt;=90;SELECT * FROM student WHERE jsp BETWEEN 75 AND 90; – (包前包后) 需求: 查询性别为女的学生SELECT * FROM student WHERE gender&lt;&gt;&#39;男&#39;; 判空(判断null 和 空字符串) null 和 空字符串的区别 null：表示没有值 空字符串：有值的！ 判断null is null is not null 判断空字符串 =’’ \&lt;&gt;’’ 需求： 查询地址为空的学生（包括null和空字符串）SELECT * FROM student WHERE address IS NULL OR address=&#39;&#39;; – （包括null和空字符串) 需求： 查询有地址的学生(不包括null和空字符串)SELECT * FROM student WHERE address IS NOT NULL AND address&lt;&gt;&#39;&#39;; 模糊条件查询like % : 表示任意个字符 _ :(下划线)表示一个字符 需求： 查询姓‘张’的学生SELECT * FROM student WHERE NAME LIKE &#39;李%&#39;; 需求： 查询姓‘李’，且姓名只有两个字的学生select * from studetn where name like &#39;李__&#39; 聚合查询常用聚合函数 sum() avg() max() min() count() 需求：查询学生的servlet的总成绩 (sum() :求和函数)SELECT SUM(servlet) AS &#39;servlet的总成绩&#39; FROM student; 需求： 查询学生的servlet的平均分SELECT AVG(servlet) AS &#39;servlet的平均分&#39; FROM student; 需求: 查询当前servlet最高分SELECT MAX(servlet) AS &#39;最高分&#39; FROM student; 需求： 查询最低分SELECT MIN(servlet) AS &#39;最低分&#39; FROM student; 需求： 统计当前有多少学生(count(字段))SELECT COUNT(*) FROM student;SELECT COUNT(id) FROM student; 注意: count() 函数统计的数量不包含null 使用count统计表的记录数，要使用不包含null值的字段 分页查询（limit 起始行,查询几行） 起始行从0开始 分页：当前页 每页显示多少条 分页查询当前页的数据的sql: SELECT * FROM student LIMIT (当前页-1)*每页显示多少条,每页显示多少条; 需求： 查询第1,2条记录（第1页的数据）SELECT * FROM student LIMIT 0,2; 查询第3,4条记录（第2页的数据）SELECT * FROM student LIMIT 2,2; 查询第5,6条记录（第3页的数据）SELECT * FROM student LIMIT 4,2; 查询第7,8条记录 (没有记录不显示)SELECT * FROM student LIMIT 6,2; 查询排序(order by)语法 ：order by 字段 asc/desc asc: 顺序，正序。数值：递增，字母：自然顺序（a-z） desc: 倒序，反序。数值：递减，字母：自然反序(z-a) 默认情况下，按照插入记录顺序排序 需求： 按照id顺序排序SELECT * FROM student ORDER BY id ASC;SELECT * FROM student ORDER BY id;– 默认正序SELECT * FROM student ORDER BY id DESC;– 反序 注意：多个排序条件 需求： 按照servlet正序，按照jsp的倒序SELECT * FROM student ORDER BY servlet ASC,jsp DESC; 分组查询(group by) 需求： 查询男女的人数分组依据要显示出来123456预期结果： 男 3 女 21) 把学生按照性别分组(GROUP BY gender)2) 统计每组的人数(COUNT(*)) select ssex count(*) from group by ssex; 分组查询后筛选(having) 需求： 查询总人数大于2的性别 12341) 查询男女的人数2）筛选出人数大于2的记录(having)注意： 分组之前条件使用where关键字，分组之前条件使用having关键字SELECT gender,COUNT(*) FROM student WHERE sid&gt; 2 GROUP BY gender HAVING COUNT(*)&gt;2; SELECT gender,COUNT() FROM student GROUP BY gender where COUNT()&gt;2;这里分组之后不能使用whereSELECT gender,COUNT(*) FROM student GROUP BY gender HAVING COUNT(*)&gt;2;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql数据库的安装]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2FMysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[MySQL-mysql 8.0.12安装教程本文章参考小楼札记 下载zip安装包：MySQL8.0 For Windows zip包下载地址：点击下载，进入页面后可以不登录。后点击底部“No thanks, just start my download.”即可开始下载。 安装解压zip包到安装目录我的解压在了C:\develop\mysql-8.0.12-winx64 配置环境变量path将解压文件夹下的bin路径添加到变量值中，前后以 ; 开头结尾 配置初始化的my.ini文件我们发现解压后的目录并没有my.ini文件，没关系可以自行创建。在安装根目录下添加 my.ini（新建文本文件，将文件类型改为.ini），写入基本配置： 123456789101112131415161718192021222324[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=C:\\develop\\mysql-8.0.12-winx64 # 切记此处一定要用双斜杠\\，单斜杠我这里会出错，不过看别人的教程，有的是单斜杠。自己尝试吧# 设置mysql数据库的数据的存放目录datadir=C:\\develop\\mysql-8.0.12-winx64\\Data # 此处同上# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 安装mysql在安装时，必须以管理员身份运行cmd，否则在安装时会报错，会导致安装失败的情况 3.1 初始化数据库 在MySQL安装目录的 bin 目录下执行命令：mysqld --initialize --console 执行完成后，会打印 root 用户的初始默认密码，比如：12345678C:\Users\Administrator&gt;cd C:\Program Files\MySQL\binC:\Program Files\MySQL\bin&gt;mysqld --initialize --console2018-04-28T15:57:17.087519Z 0 [System] [MY-013169] [Server] C:\Program Files\MySQL\bin\mysqld.exe (mysqld 8.0.11) initializing of server in progress as process 49842018-04-28T15:57:24.859249Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E2018-04-28T15:57:27.106660Z 0 [System] [MY-013170] [Server] C:\Program Files\MySQL\bin\mysqld.exe (mysqld 8.0.11) initializing of server has completedC:\Program Files\MySQL\bin&gt; 注意！执行输出结果里面有一段： [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E 其中root@localhost:后面的“rI5rvf5x5G,E”就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。 没有记住请参考：https://dev.mysql.com/doc/refman/8.0/en/data-directory-initialization-mysqld.html 安装服务 在MySQL安装目录的 bin 目录下执行命令：mysqld --install [服务名] 后面的服务名可以不写，默认的名字为 mysql。当然，如果你的电脑上需要安装多个MySQL服务，就可以用不同的名字区分了，比如 mysql5 和 mysql8。 启动 安装完成之后，就可以通过命令net start mysql启动MySQL的服务了。通过命令net stop mysql停止服务。通过命令sc delete MySQL/mysqld -remove卸载 MySQL 服务 更改密码在MySQL安装目录的 bin 目录下执行命令： mysql -u root -p 这时候会提示输入密码，记住了上面第3.1步安装时的密码，填入即可登录成功，进入MySQL命令模式。 在MySQL中执行命令： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;; 修改密码，注意命令尾的；一定要有，这是mysql的语法 到此，安装部署就完成了。官方说测试速度MySQL8比5快两倍。 参考看一下默认MySQL用户： select user,host,authentication_string from mysql.user; 管理员root的host是localhost，代表仅限localhost登录访问。如果要允许开放其他ip登录，则需要添加新的host。如果要允许所有ip访问，可以直接修改成“%” 创建用户：CREATE USER &#39;用户名&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;密码&#39;; MySQL创建用户与授权]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lanbda表达式]]></title>
    <url>%2Fblog%2F2018%2F08%2F10%2FLanbda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Lambda表达式 Lambda表达式（也称为闭包）是整个Java8发行版中最受期待的在Java语言层面上的改变 Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。 Lambda表达式用于简化JAVA中接口式的匿名内部类。被称为函数式接口的概念。 函数式接囗就是一个具有一个方法的普通接口。像这样的接口，可以被隐式转换为lambda表达式。 格式 (参数1,参数2….) -&gt; {….}; 接口中抽象方法只能有一个(前提) java 接口中的默认方法和镜头方法对lambda不影响 当重写抽象方法只有一句的时候,可以省略大括号{} 当重写方法只有一句返回值的代码块时,可以省略return和{},留下值 之前的处理1234//定义只有一个抽象方法的接口interface IEat &#123; void eat();&#125; 方式一编写一个实现类123456789101112class IEatImpl implements IEat &#123; @Override public void eat(String thing) &#123; System.out.println(&quot;吃苹果&quot;); &#125;&#125;-----测试:-----------------------------------IEatImpl eat = new IEatImpl(); eat.eat(); 方式二匿名内部类1234567IEat eat2 = new IEat() &#123; @Override public void eat() &#123; System.out.println(&quot;匿名内部类重写eatd&quot;); &#125; &#125;; eat2.eat(); 使用Lambda表达式12345678910IEat eat3 = () -&gt; &#123; System.out.println(&quot;Lambda重写eat方法&quot;); &#125;;eat3.eat();---简写模式(省略&#123;&#125;)------------------IEat eat4 = () -&gt; System.out.println(&quot;Lambda重写eat方法&quot;);eat3.eat(); lambda的使用 （1）没有参数时使用Lambda表达式（2）带参数时使用Lambda表达式（3）代码块中只一句代码时使用Lambda表达式（4）代码块中有多句代码时使用Lambda表达式（5）有返回值的代码块（6）参数中使用fina关键字 没有参数时12345678910IEat eat3 = () -&gt; &#123; System.out.println(&quot;Lambda重写eat方法&quot;); &#125;;eat3.eat();---简写模式(省略&#123;&#125;)------------------IEat eat4 = () -&gt; System.out.println(&quot;Lambda重写eat方法&quot;);eat3.eat(); 带参数时 只有一个参数,类型可以省略,编译器可以推断出来(类型反推)一个参数的时候,括号也可以省略 1234567891011121314interface IEat &#123; void eat(String thing);&#125;IEat eat5 = (String thing) -&gt; &#123; System.out.println(&quot;eat....&quot; + thing); &#125;;eat5.eat(&quot;苹果&quot;);----简写模式(省略类型)-------------------------------------IEat eat5 = (thing) -&gt; &#123; System.out.println(&quot;eat....&quot; + thing); &#125;; 多个参数的时候,类型也可以省略 12345678910interface IEat1 &#123; void eat(String thing, String name);&#125;IEat eat5 = (String thing, String name) -&gt; &#123; System.out.println(name + &quot;eat....&quot; + thing); &#125;;eat5.eat(&quot;苹果&quot;,&quot;我&quot;); 代码块中只一句代码 可以省略{}1IEat eat5 = (thing) -&gt; System.out.println(&quot;eat....&quot; + thing); 代码块中有多句代码时 {}大括号不可以省略1234IEat eat5 = (thing) -&gt; &#123; System.out.println(&quot;吃东西了.&quot;); System.out.println(&quot;eat....&quot; + thing); &#125;; 有返回值 只有return 返回值一句代码 {}和return 都省略 保留{} 和 return 只要留下的结果是一个值即可,(三目运算符)123456789101112131415interface IEat1 &#123; int eat(String thing, String name);&#125; ----一句代码-------------------------------------IEat1 eat6 = (name, thing) -&gt; 10; //return 10IEat1 eat6 = (name, thing) -&gt; return 10; //编译不能通过IEat1 eat6 = (name, thing) -&gt; 5 &gt; 3 ? 100 : -1; //三目运算符----多行代码----------------------------------IEat1 eat6 = (thing, name) -&gt; &#123; System.out.println(name + &quot;吃了&quot; + thing); return 10;&#125;; 参数中使用fina关键字 表达式中可以不添加 如果要添加final关键字 带上数据类型 1234567891011121314151617181920212223interface IEat3 &#123; int eat(final String thing, final String name); public default void show() &#123; //默认方法 System.out.println(&quot;show&quot;); &#125; public static void method() &#123; //静态方法 System.out.println(&quot;method&quot;); &#125;&#125;--第一种----------------------------------IEat3 eat7 = (thing,name)-&gt;&#123; System.out.println(name + &quot;吃了&quot; + thing); return 10;&#125;;--第二种----------------------------------IEat3 eat7 = (final String thing, final String name) -&gt; &#123; System.out.println(name + &quot;吃了&quot; + thing); return 10;&#125;; 调用接口中的静态方法:接口调用1IEat3.method(); 调用接口中的默认方法:实现接口的对象调用1234567891011new IEat3() &#123; @Override public int eat(String thing, String name) &#123; return 0; &#125;&#125;.show();---lanbda--------------------------------IEat3 i = (thing, name) -&gt; 0;i.show(); 应用于排序12345678910111213141516171819202122232425262728293031323334353637public class Student &#123; private int age; private String name; public Student() &#123; super(); // TODO Auto-generated constructor stub &#125; public Student(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;; &#125;&#125; 对学生排序12345678910111213141516171819public static void main(String[] args) &#123; Student[] students = &#123; new Student(18, &quot;叶红&quot;), new Student(15, &quot;疏风&quot;), new Student(21, &quot;撒旦法&quot;) &#125;; // 第一种:匿名内部类实现 Arrays.sort(students, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; int num = o1.getAge() - o2.getAge(); int num2 = num == 0 ? o1.getName().compareTo(o2.getName()) : num; return num2; &#125; &#125;); // 遍历 for (Student s : students) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125;&#125; 使用lambda对学生排序12345678910111213141516171819202122232425public static void main(String[] args) &#123; Student[] students = &#123; new Student(18, &quot;叶红&quot;), new Student(15, &quot;疏风&quot;), new Student(21, &quot;撒旦法&quot;) &#125;; Comparator&lt;Student&gt; c = (o1, o2) -&gt; &#123; int num = o1.getAge() - o2.getAge(); int num2 = num == 0 ? o1.getName().compareTo(o2.getName()) : num; return num2; &#125;; Arrays.sort(students, c); ----简便写法------------------------------------------------------------------------- Arrays.sort(students, (o1, o2) -&gt; &#123; int num = o1.getAge() - o2.getAge(); int num2 = num == 0 ? o1.getName().compareTo(o2.getName()) : num; return num2; &#125;);----------------------------------------------------------------------------------- // 遍历 for (Student s : students) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge()); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Lanbda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day11]]></title>
    <url>%2Fblog%2F2018%2F08%2F10%2Fjava%E5%9F%BA%E7%A1%80day11%2F</url>
    <content type="text"><![CDATA[正则表达式12345一个典型的调用序列 Pattern p = Pattern.compile(&quot;a*b&quot;); Matcher m = p.matcher(&quot;aaaaab&quot;); boolean b = m.matches(); 自动拆装箱(包装类) 包装类是不可变类;对象创建就不能更改包装类使用类常量池技术,提高了性能对包装类的一部分数据进行缓存(除了float和double) 1234类型 缓存数据byte -128 ~ 127char 0 ~ 127boolean 全部 String – &gt; 数字new Ingetger(String str).intValue();Integer.parseInt(String str);num = Integer.valueof(String); 数字 –&gt; Strings = num + “”;s = String.valueof(num);s = Integer.toString(num); 进制转换123System.out.println(Integer.toBinaryString(5)); //转换为2进制System.out.println(Integer.toOctalString(10)); //转换为8进制System.out.println(Integer.toHexString(15)); //转换为16进制 十进制变其他进制() 除基取余 public static String toString(int i,int radix);将i变为 radix 进制 (范围：2-36，因为表示的数有0-9,a-z共36个)1System.out.println(Integer.toString(5, 2));//101 其他进制 变十进制 位 乘以 基的权次幂 public static int parseInt(String s,int radix); 将字符串s变为 radix 进制 public static int valueOf(String s,int radix); 将字符串s变为 radix 进制 12System.out.println(Integer.parseInt(&quot;101&quot;, 2)); //5System.out.println(Integer.valueOf(&quot;101&quot;, 8)); //65 Date 构造方法:获取当前的时间 123456java.util.Date date = new java.util.Date();System.out.println(date); //Sun Aug 12 15:11:48 CST 2018//过时的方法,(不建议使用)System.out.println(date.getYear() + 1900);System.out.println(date.getMonth() + 1);System.out.println(date.getDate()); public long getTime():获取时间，以毫秒为单位 public void setTime(long time):设置时间子类Date java.sql.Date包下 12345678910java.sql.Date dt1 = new java.sql.Date(date.getTime());System.out.println(dt1); //2018-08-12//日期 转 字符串 Date.toSring()String sdt1 = dt1.toString();System.out.println(sdt1); /2018-08-12//字符串 转 日期 Date.valueof(String str)dt1 = java.sql.Date.valueOf(sdt1);System.out.println(dt1); //2018-08-12 Time12Time time = new Time(date.getTime()); System.out.println(time); //15:20:51 Calendar类 月份从0开始123456789Calendar c = Calendar.getInstance();System.out.println(c.getTime()); //Sun Aug 12 15:23:15 CST 2018System.out.println(c.get(Calendar.YEAR)); //2018System.out.println(c.get(Calendar.MONTH)+1); //8System.out.println(c.get(Calendar.DATE)); /12//add()调节时间 c.add(Calendar.YEAR, -10); //10年前的今天; System.out.println(c.getTime()); //Tue Aug 12 15:24:55 CST 2008 格式化1234567// 数字的格式化Format//当前环境 缺省的格式NumberFormat f1 = NumberFormat.getInstance();System.out.println(f1.format(234.55665)); //234.557// 当前环境缺省的货币格式f1 = NumberFormat.getCurrencyInstance();System.out.println(f1.format(2.364588)); //￥2.36 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//----------------------日期格式化------------------------------------ //父类 //当前环境缺省格式 DateFormat df = DateFormat.getInstance(); System.out.println(df.format(date));//18-8-10 上午11:47//==Date============================================================= df = DateFormat.getDateInstance(); System.out.println(df.format(date));//2018-8-10 df = DateFormat.getDateInstance(DateFormat.SHORT); System.out.println(df.format(date));//18-8-10 df = DateFormat.getDateInstance(DateFormat.MEDIUM); System.out.println(df.format(date));//2018-8-10 df = DateFormat.getDateInstance(DateFormat.LONG); System.out.println(df.format(date));//2018年8月10日 df = DateFormat.getDateInstance(DateFormat.FULL); System.out.println(df.format(date));//2018年8月10日 星期五//==Time============================================================= df = DateFormat.getTimeInstance(); System.out.println(df.format(date));//11:50:46 d1 = DateFormat.getTimeInstance(DateFormat.SHORT); System.out.println(d1.format(date));// 上午11:58 d1 = DateFormat.getTimeInstance(DateFormat.MEDIUM); System.out.println(d1.format(date));// 11:50:46 d1 = DateFormat.getTimeInstance(DateFormat.LONG); System.out.println(d1.format(date));// 上午11时58分30秒//===DateTime============================================================= df = DateFormat.getDateTimeInstance(); System.out.println(df.format(date));//2018-8-10 11:51:20 df = DateFormat.getDateTimeInstance(DateFormat.FULL,DateFormat.FULL); System.out.println(df.format(date));//2018年8月10日 星期五 上午11时52分06秒 CST //子类 // yy MM dd hh(12) H (24) mm ss S SimpleDateFormat sf1 = new SimpleDateFormat(&quot;yyyy年MM-dd H:mm:ss.SSS&quot;); System.out.println(sf1.format(date)); //2018年08-12 15:35:11.322 //-----------------------------8.0-------------------------------------- //日期 LocalDate ldate = LocalDate.now(); ldate = LocalDate.of(2012, 1, 23); //自己设置时间 System.out.println(ldate); //2012-02-23 System.out.println(ldate.getYear()); //2012 System.out.println(ldate.getMonthValue()); //2 System.out.println(ldate.getDayOfMonth()); //23 System.out.println(ldate.getDayOfYear()); //一年中的第几天54 System.out.println(ldate.getDayOfWeek()); //THURSDAY System.out.println(ldate.plusYears(10)); //2022-02-23 10年后 System.out.println(ldate.minusYears(5)); //2007-02-23 5年前 //时间 LocalTime ltime = LocalTime.now(); ltime = LocalTime.of(3, 20, 23); System.out.println(ltime); //03:20:23 System.out.println(ltime.getHour()); //3 System.out.println(ltime.plusHours(10)); //13:20:23 System.out.println(ltime.minusHours(4)); //23:20:23 //日期时间 LocalDateTime ldt1 = LocalDateTime.now(); ldt1 = LocalDateTime.of(2012, 2, 3, 4, 5 ,56); System.out.println(ldt1); //2012-02-03T04:05:56 System.out.println(ldt1.getYear()); //2012 System.out.println(ldt1.getDayOfMonth()); //3 //运算 LocalDateTime ldt2 = LocalDateTime.now(); ldt2 = LocalDateTime.of(2012, 1, 3, 4, 5, 56); LocalDateTime ldt3 = LocalDateTime.now(); ldt3 = LocalDateTime.of(2012, 2, 5, 4, 5, 56); Duration du = Duration.between(ldt2, ldt3); System.out.println(du.toDays()); //33 内部类123456class Outer&#123;//外部类 ,外围类 class Inner &#123; //内部类 ,嵌入类 &#125;&#125; 分类 成员内部类 实例成员内部类 静态成员内部类 局部内部类 匿名内部类 成员内部类实例成员内部类 内部类可以使用四种权限访问修饰符 内部类归该类的对象 创建内部类对象 外部类名.内部类名 实例名 = new 外部对象().new 内部类对象() 内部类可以直接访问外部类成员，因为内部类对象中都隐藏了一个外部类对象 包括private修饰的 内部类字节码命名:外部类名$内部类名.class Cat$CatBody.class 除了 静态内部类 以外 ,都不允许 定义静态内容 但是 static final 除外 static final int N=22; 编译期能识别,编译后 所有N 用22 替代了 因为static归类所用 ,内部类归外部类对象所有 外部类静态方法中不能直接访问实例内部类数据 用对象调用 new Outer().new Inner().method(); 静态方法只能访问静态 如果外部类成员变量,内部类成员变量,内部类方法中的变量同名 内部类方法中的变量&gt; 内部类成员变量&gt; 外部类成员变量 内部类的方法访问同名变量 num:内部类方法中的变量 this.num:内部类成员变量 Other.this.num:内部类使用外部类成员变量 Other.this.fun():内部类调用外部类的成员方法 1234567class Outer&#123; public void f()&#123;&#125; int n; class Inner&#123; &#125;&#125; 例子:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Cat &#123; private int weight; public Cat() &#123; super(); // TODO Auto-generated constructor stub &#125; public Cat(int weight) &#123; this.weight = weight; &#125;----------------------------------------------------------------------------class CatBody &#123; ************************************************* 1.class 可以用四种权限修饰符, * 如果为private的时候,就要提供公共的方法得到内部类对象 ************************************************* private String color; public CatBody(String color) &#123; super(); this.color = color; &#125; *********************************************************** 内部类可以直接访问外部类成员，因为内部类对象中都隐藏了一个外部类对象 ********************************************************** public void show() &#123; System.out.println(&quot;颜色:&quot; + color + &quot;,重量&quot; + weight); // System.out.println(&quot;颜色:&quot;+color+&quot;,重量&quot;+Cat.this.weight); &#125;&#125;--------------------------------------------------------------------------- public void display() &#123; System.err.println(weight); CatBody body = new CatBody(&quot;土豪金&quot;); body.show(); &#125;&#125;===========================================================================public class Demo7 &#123; public static void main(String[] args) &#123; Cat cat = new Cat(200); // 创建一个内部类对象 Cat.CatBody body = cat.new CatBody(&quot;黑色&quot;); Cat.CatBody body2 = new Cat(120).new CatBody(&quot;金色&quot;); body.show(); body2.show(); &#125;&#125;===========================================================================结果: 颜色:黑色,重量200 颜色:金色,重量120 静态内部类 内部类是外部类的静态成员 创建静态内部类对象 外部类名.静态内部类名 = new 外部类名.静态内部类名(); 静态内部类的静态方法只能访问静态 外部类使用静态内部类的静态方法 通过静态内部类名.静态方法名(); 外部类使用静态内部类的成员方法’ 通过创建对象使用 12345class Outer&#123; static void sf()&#123;&#125; static class Inner&#123; &#125; &#125; 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445class School &#123;-----------静态内部类------------------------------------------------- static class WaterFountain &#123; private int x = 5000; static int y = 22; public void show() &#123; System.out.println(&quot;水量&quot; + x + &quot;ml&quot;); System.out.println(y); &#125; public static void show2() &#123; System.out.println(y); // System.out.println(x);//静态方法不能调用非静态 // System.out.println(z);//报错,静态方法不能调用非静态 System.out.println(z1); System.out.println(new WaterFountain().x);//通过对象调用非静态 System.out.println(new School().z);//通过对象调用非静态 &#125; &#125;--------成员变量---------------------------------------------------- private int z = 100; private static int z1 = 100;------成员方法-------------------------------------------------- public void manager() &#123; WaterFountain.show2(); new WaterFountain().show(); &#125;&#125;------测试-----------------------------------------------------public class Demo9 &#123; public static void main(String[] args) &#123; //创建静态内部类对象 //外部类使用静态内部类的成员方法 School.WaterFountain w = new School.WaterFountain(); w.show(); //外部类使用静态内部类的静态方法 School.WaterFountain.show2(); &#125;&#125; 接口中 可以定义静态内部类,静态内部接口 接口中 定义的 类和接口默认 public static 123456789101112131415interface Info&#123; //---静态内部类------------------------ class A&#123; int x = 11; public void f() &#123;&#125; public static void sf() &#123;&#125; &#125; //---静态内部接口------------------------ interface IA&#123; int N = 45; void af(); default void df() &#123;&#125; static void sf1() &#123;&#125; &#125;&#125; 1234567891011121314151617181920212223242526272829---接口的实现类----------------------------------class InfoImpl implements Info &#123;//-----访问class A------------------------------------ public void method() &#123; // A是实现类的内部类,属于实现类的对象 System.out.println(new A().x); new A().f(); A.sf(); //静态方法属于类 &#125;//-----访问接口内容----------------------------------------------- public void method2() &#123; System.out.println(IA.N); IA.sf1(); // 使用接口对象(匿名内部类)调用默认方法和抽象方法 IA ia = new IA() &#123; @Override public void af() &#123; // TODO Auto-generated method stub &#125; &#125;; ia.df(); ia.af(); &#125;&#125; 实现接口中的接口 12345678910111213class IAImpl implements Info.IA &#123; @Override public void af() &#123; &#125;&#125;===使用===================================public void show()&#123; df(); //默认的用对象 int n =Info.IA.N; //静态的用接口名限定 Info.IA.sf1(); //静态的用接口名限定&#125; 继承实例内部类12345678910class Outer2&#123; Outer2()&#123; System.out.println(&quot;outer2&quot;); &#125; class Inner2&#123; Inner2()&#123; System.out.println(&quot;Inner2&quot;); &#125; &#125;&#125; 继承实例内部类 继承实例内部类 子类需要访问实例内部类(父类)的无参构造方法 实例内部类是属于外部类的对象. 父类的构造方法是应该用外部对象调用(new Outer). 123456789101112class Demo extends Outer2.Inner2&#123; Demo(Outer2 o)&#123; o.super(); //new Outer().super(); System.out.println(&quot;Demo&quot;); &#125;&#125;public class TestInner &#123; public static void main(String[] args) &#123; Demo d = new Demo(new Outer2()); &#125;&#125; 局部内部类注意： 局部内部类不能声明静态成员 局部内部类处于静态方法中只能直接访问外部类的静态成员 局部内部类处于实例方法中可以直接访问外部类静态成员和实例成员 局部类对局部变量的访问 1.8 之前要用final修饰 1.8 之后可以访问变量,但是变量的值不能更改 字节码文件名： 外部类名$N内部类名.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class TestLocalInner1 &#123; static int sn = 33; int num = 44; public void f() &#123; int m = 45;//局部变量 //1.8之前防止栈内存的数据在内部类使用的时候销毁, //需要用fianl修饰 final int m =45; //局部变量被用到的地方全部用值替换了. //非静态方法局部内部类 class Parent&#123; int x = 22; public void sss() &#123; System.out.println(sn); //可以访问静态和非静态 System.out.println(num); //jdk1.8后可以访问局部变量了，但是变量的值 不能更改 //1.8之前的 System.out.println(m); &#125; &#125; &#125; public static void main(String[] args) &#123; //静态方法里的局部内部类 class Parent&#123; int x = 22; static final int n = 56; public void ss() &#123; System.out.println(sn); //静态只能范围内静态 System.out.println(new TestLocalInner1().num);//访问非静态可以使用对象 &#125; &#125;//----局部内部类继承------------------------------------------- class Child extends Parent&#123; int y = 33; &#125; Child c = new Child(); System.out.println(c.x); System.out.println(c.y); &#125;&#125;//---生成的字节码文件列表----------------------------------TestLocalInner1.classTestLocalInner1$1Parent.classTestLocalInner1$2Parent.classTestLocalInner1$1Child.class 匿名内部类 只能用一次外部类名$N.class理解: 匿名内部类就是实现接口的类 或 继承了该类 的 对象 格式123new 父类(参数列表) | 实现接口()&#123; //匿名内部类的类体部分&#125; 注意: 必须实现一个类或一个接口。 返回的是子类 或 实现类 的子类对象 不能定义静态数据 只有静态内部类才能定义静态 static final 除外 不能定义构造器 构造器和类名一样 匿名就是没有名字 不能是抽象的 返回的是继承了父类的子类对象 抽象的就不能返回对象了 传参问题 父类构造有参数,可以传参数 同名问题 123456789interface Info1&#123; void af();&#125;interface IE&#123; void f();&#125;interface IF&#123; void f();&#125; 1234567//创建Info1的匿名对象Info1 info1 = new Info1() &#123; @Override public void af() &#123; // TODO Auto-generated method stub &#125; &#125;; 抽象类使用匿名内部类 123456789101112131415161718192021222324252627282930313233343536abstract class Base1 &#123; Base1(int n) &#123; System.out.println(n); &#125; public void f() &#123; &#125;&#125;-----------------------------Base1 base1 = ////---匿名内部类------------------------- new Base1(22) &#123; &#123; System.out.println(&quot;构造块&quot;); &#125; public void f() &#123; System.out.println(&quot;sub_f&quot;); &#125; public void method() &#123; &#125;// 调用不到,Base1没有,多态 &#125;;//如果要调用,匿名内部类//匿名内部类是对象,所以能调用方法new Base1(44) &#123; public void f() &#123; System.out.println(&quot;sub_f&quot;); &#125; public void m() &#123; System.out.println(&quot;自己添加的m()&quot;); &#125; &#125;.m();]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>包装类</tag>
        <tag>日期</tag>
        <tag>成员内部类</tag>
        <tag>匿名内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day10]]></title>
    <url>%2Fblog%2F2018%2F08%2F09%2Fjava%E5%9F%BA%E7%A1%80day10%2F</url>
    <content type="text"><![CDATA[UML建模语言类图访问修饰符 - private 不写 default # protected + bublic 类和类的关系泛化 继承实线 + 空心三角子类 指向 –&gt; 父类 实现 接口接口 成员虚线 + 空心三角实现 指向 —&gt; 接口 依赖 是一种 使用 的 关系虚线 + 箭头 人 使用 车 人 指向 车 动物 依赖 食物 动物 指向 食物 语法: 成员变量 关联 拥有 学员 拥有 课程 实线 + 箭头 对象拥有的个数分类 1对1(汽车 和 车位) 1对多(学员 和 多门课程) 多对多(老师 和 学员) 聚集(聚合)(强关联) 整体 和 局部 局部 离开 整体 ,整体可以独立 存在(键盘和鼠标) 空心菱形 + 箭头 菱形执向 整体 组合(聚集的一种) 实心菱形 + 箭头实心菱形 指向 整体 整体和局部局部离开整体 整体不可以独立存在(人 和 心脏) 语法: 成员变量 APIString String 就是一个对象String 是不可变类 - 对象一旦创建就不能更改 1234567891011121314151617181920212223String s1 = &quot;abc&quot;;String s2 = new String(&quot;abc&quot;);String s3 = new String(&quot;ABC&quot;);String s4 = &quot;abc&quot;;String s5 = new String(&quot;abc&quot;);System.out.println(s1 == s4); // trueSystem.out.println(s1 == s2); // falseSystem.out.println(s2 == s5); // falseSystem.out.println(s2.equals(s5)); // true System.out.println(s2.equals(s3)); // false,equals区分大小写s1:创建了一次对象;将&quot;abc&quot;存入方法区的常量池.s2:创建了一次对象,第一次new ,在常量池中找到了&quot;abc&quot;,将地址给了堆内存,然后堆内存地址给引用.s3:创建了二次对象,第一次new 在堆,第二次在常量池中创建对象,将地址给了堆内存,然后堆内存地址给引用.s1=&quot;hello&quot;+&quot;tom&quot;;s1.concat(&quot;abcde&quot;);//连接字符串System.out.println(s1);//hellotom//如果想修改s1,就要改引用,s1=新的对象.s1=s1.concat(&quot;abcde&quot;);System.out.println(s1);//hellotomabcde 成员方法 concat(str):字符串连接字符串str. length();判断字符串的长度 equals();比较二个字符串是否相等,区分大小写 equalsIgnorceCase(): 不区分大小写 toUpperCase: 转换为大写 toLowerCase: 转换为小写 indexOf(String str): 查找 参数 字符串 在原始 字符串 中 第一次 出现的位置索引 没有找到: 返回 -1 lastIndexOf(String str):查找 参数 字符串 在原始 字符串 中 最后一次 出现的位置索引 没有找到: 返回 -1 charAt(index): 获得指定索引的字符 subString(int start):获取从索引开始截取字符串 subString(int Start ,int end):截取[start,end)范围的字符串 trim(String str): 去掉字符串的前后空格 replace(old,new): 使用new 替换 old 替换字符串中间的空格 “” 空串 常量池中 有空间,没有字符序列 null 空,空对象 没有空间 startsWith():判断是否指定的参数开头 endsWith():判断是否指定的参数结尾 comparreTo(参数对象):与参数对象比较大小 相等:0 小:负数,比较的在参考的ASCII前 (根据厂商的不同,值不同) 小:正数,比较的在参考的ASCII前 (根据厂商的不同,值不同) toCharArray(): 将字符串转换为字符串数组 split(“ “):用参数/(空格)字符串风格为一个字符串数组 contains(String):指定的参数的字符串 在原字符串中是否存在,不存在为false StringBuffer 可变的字符串格式,成倍扩充容量(影响性能)构造方法可以自定义容量.默认给16个字符大小的缓冲区123StringBuffer sb = new StringBuffer(&quot;hello&quot;)// 缓冲区:16+5自己定义:StringBuffer sb = new StringBuffre(100); 成员方法 capacity():查看缓冲区的大小 append():追加,返回一个StringBuffer对象 可以添加任意类型 append (char[] ,start , end): 从start位置 插入end个字符 insert(index , str):指定位置插入一个字符串 setCharAt(index,char):修改指定位置的字符 deleteCharAt(index):删除指定位置的字符 delete(start,end):删除索引区间为[start , end)的字符 reverse(): 反转 trimToSize() charAt() indexof() lastIndexOf() String,StringBuffer,StringBuilder的区别String:不可变类,表示一个字符串的使用,简单 - 如果字符串的值 频繁更改,用缓冲的 多线程使用 : StringBuffer,线程是安全的StringBuilder 线程不安全]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java基础day09]]></title>
    <url>%2Fblog%2F2018%2F08%2F08%2Fjava%E5%9F%BA%E7%A1%80day09%2F</url>
    <content type="text"><![CDATA[final 终态 类 ： 此类 不能被继承 方法： 此方法不能被重写 变量： 此变量的值不能更改，是常量 final 类： 为了类的安全 类中的方法有复杂的调用关系 是最终版本的类 final 方法： 不希望子类重写 使用统一的父类版本 final 变量： 自定义常量： 如PI, final 数据类型 变量名 =值 常量的变量名 大写 ，多个单词用_连接 作用 安全性，防止运算的值的修改 便于维护 增强可读性 继承设计的原则 继承的层次 最好 2~3层。 精心的用于继承的类 提供文档说明 隐藏类中的实现细节 继承的缺点 破坏封装 高耦合，便于维护，父类修改，子类也修改了 类与类组合 类和类 之间的关系： 整体和局部 局部类作为成员变量&emsp;&emsp;Heart h = new Heart();//成员变量 1234567891011121314151617181920212223package day9；//心脏 局部类class Heartl&#123; public void beat()&#123; System.out.printin(“心跳“）； &#125;&#125;//狼 整体类class Wolf1&#123; Heart h=new Heart()；//成员变量 public void run(); System.out.println(&quot;狼跑”）；&#125;public class TestAnimalf&#123; public static void main(String[]args)&#123; Wolf1 wolf=new Wolf1()； wolf.h.beat()； wolf.run（）； &#125;&#125; 抽象类 只约定类所具有的抽象行为，没有具体实行对应的行为 格式123456789101112abstract class 类名&#123; 常量； 变量； 访问修饰符 abstract 返回类型 方法名（）；//抽象方法 普通方法； 静态方法（）；&#125; 注意 抽象类 不能 创建对象 抽象方法不是必须定义 带有抽象方法类的必须是抽象类 构造方法 不能是抽象的； abstract 不能与 private ,final,static private 不能被继承，就不能重写 final 不能被重写 static ,方法没有方法体，无意义 抽象方法 没有方法的实现 没有{（空实现）}， 子类必须实现父类的所有抽象方法 重写父类的抽象方法 抽象子类除外 构造方法 构造方法不能是抽象的, 构造方法不能被继承 抽象的方法要子类重写，矛盾 虽然抽象类不能被实例化，但可以有构造函数。由于抽象类的构造函数在实例化派生类之前发生，所以，可以在这个阶段初始化抽象类字段或执行其它与子类相关的代码。 抽象类使用场合： 此类 不适合创建对象； 此类 提供一个模板的作用； 接口 是一组 公开的 规则 是功能的组合。 接口注意： 不能创建对象（抽象） 普通的实现类 要 实现接口中的 所有抽象方法 抽象的实现类除外 实现类 可以实现 多个接口 接口之间 可以 多继承 接口不能实现接口 12345678访问修饰符 interface 接口名&#123; 静态的常量；public ,static final 抽象方法；public abstract 默认方法；(1.8后支持)default,可以有方法体 静态方法；(1.8后支持)static 静态内部类型；public static 内部类，内部接口， 内部枚举enum&#125;一个类中只能，接口不能用public 修饰 接口的特点： 一组 公开 规则 降低了类之间的耦合连接 扩充了 功能实现 扩展方法默认方法 使得接口在进行扩展的时候，不会破坏与接口相关的实现类代码default方法，只能通过接口实现类的对象来调用。 之前开发中，接口实现了就不能更改，有新的需求， 写一个新的接口， 继承之前的接口， 添加新功能， 实现该类， 调用新类。 1.8之后，可以在原来的接口中， 写入新的默认方法， 调用默认方法。 接口多实现下的问题 一个类实现了两个接口（可以看做是“多继承”），这两个接口又同时都包含了一个名字相同的default方法f2()编译器会报错,在编译阶段报错要求开发者必须override同名的方法 12345678interface C extends A,B&#123; @Override default void f2() &#123; B.super.f2(); //重写B接口的f2()方法 B.super.f2(); //重写A接口的f2()方法 //可以使用内部类的分别重写A,B &#125;&#125; 静态方法 只能通过接口名调用，不可以通过实现类的类名或者实现类的对象调用。 1234567891011121314151617181920212223242526272829303132333435interface A &#123; public default void f2()&#123; System.out.println(&quot;A接口中的默认方法&quot;); &#125; public static void f() &#123; System.out.println(&quot;A_静态方法！&quot;); &#125;&#125;interface B &#123; public default void f2()&#123; System.out.println(&quot;B接口中的默认方法&quot;); &#125; public static void f() &#123; System.out.println(&quot;B_静态方法！&quot;); &#125;&#125;==============重写同名的默认方法====================interface C extends A,B&#123; @Override default void f2() &#123; B.super.f2(); //重写B接口的f2()方法 B.super.f2(); //重写A接口的f2()方法 //可以使用内部类的分别重写A,B &#125;&#125;==============测试================public class Test implements C&#123; public static void main(String[] args) &#123; A.f(); //接口静态方法 通过接口名调用 B.f(); //接口静态方法 通过接口名调用 Test d1 = new Test(); //接口默认方法 通过接口实现类的对象调用 d1.f2(); &#125;&#125; 接口和抽象类的区别相同 都是引用数据类型 都不能创建对象 都能定义抽象方法 都是 用 子类继承 或 实现类 实现（重写） 来 使用。 不同 类是单一继承的 接口的实现类可以实现多个接口的功能 接口之间可以多继承 二者的理解抽象类 为所有子类提供一个模板，半成品 子类在 父抽象类的 基础上扩展 接口： 提供一组公开的规则 同一个应用程序，接口将各个类（模块）耦合连接，（不使用继承） 对于不同的应用， 接口就是通信的规则 比如鸟有fly（）；鸵鸟extends 鸟，（高耦合，父类有的子类也要有）， 鸵鸟也能飞，（设计不合理） 写一个fly()接口， 鸵鸟 extends 鸟 implements flyInterface; 商城实现支付接口，就能与银行进行通信 多态 一种物质，多种形态 运行时多态：父类引用： 指向 -》 子类对象 编译器多态：右边：方法的重载 接口多态： 接口指向接口的实现类 多态的特点： 方法重写（前提） 父类引用： 指向 -》 子类对象 接口引用: 执向 -》 实现类对象 多态中的类型转换 子类转父类: 向上类型转换 父类转子类: 向下类型转换 需要强制转换 注意类型不匹配:java.lang.ClassCastException 运算符:instanceof 判断某个对象 是否是 类 或 接口类型， 是 true,不是 false pet instanceof Cat//判断传递的pet对象是不是Cat类类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Pet &#123; private String name; public Pet(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void eat() &#123; System.out.println(&quot;吃东西&quot;); &#125;&#125;=======================================================class Dog extends Pet &#123; public Dog(String name) &#123; super(name); &#125; @Override public void eat() &#123; System.out.println(&quot;吃骨头&quot;); &#125; public void run() &#123; System.out.println(&quot;小狗跑了&quot;); &#125;&#125;=======================================================class Cat extends Pet &#123; public Cat(String name) &#123; super(name); &#125; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void play() &#123; System.out.println(&quot;小猫去玩儿了&quot;); &#125;&#125;=======================================================class PetHospatil &#123; public void treatment(Pet pet) &#123;//类与类依赖关系 // Pet pet = wangwang; Dog - &gt; Pet 向上类型转换 System.out.println(&quot;给&quot; + pet.getName() + &quot;看病&quot;); pet.eat(); // 对类型进行判断// if (pet instanceof Dog) &#123; Dog dog = (Dog) pet; dog.run(); &#125; if (pet instanceof Cat) &#123; Cat cat = (Cat) pet; cat.play(); &#125; &#125;&#125;=======================================================public class TestHospatil &#123; public static void main(String[] args) &#123; PetHospatil hos = new PetHospatil(); Dog wangwang = new Dog(&quot;旺旺&quot;); Cat xiaohua = new Cat(&quot;小花&quot;); hos.treatment(wangwang); hos.treatment(xiaohua); &#125;&#125; 类与类的关系 组合:局部和整体 继承:泛化 依赖: 类A要完成某个功能引用了类B，则类A依赖类B。依赖在代码中主要体现为类A的某个成员方法的返回值、形参、局部变量或静态方法的调用，则表示类A引用了类B。 医院治疗功能依赖宠物,医院的方法中接收的参数是宠物类型, 多态,传递的是宠物的子类对象 依赖谁,谁就是参数认识UML类关系——依赖、关联、聚合、组合、泛化]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>final</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day08]]></title>
    <url>%2Fblog%2F2018%2F08%2F07%2Fjava%E5%9F%BA%E7%A1%80day08%2F</url>
    <content type="text"><![CDATA[静态方法(类方法)在方法前面用static 修饰访问: 通过 类名.方法名 同一个类下,可以省略类名. 注意: 静态方法中 只能 直接使用 静态成员(非静态,创建对象使用) 静态方法中不能使用 this(不需要对象就能调用) 和 super(有可能调用非静态成员) 关键字 静态方法场合: 使用简单,不用创建对象 有些类不能创建对象 通过调用静态方法 返回一个 对象来调用 实例方法 静态方法和实例方法的区别 静态方法 只能 直接 访问静态成员 实例方法 静态 与 非静态 都可以访问 静态方法不能使用 this super 实例方法 可以使用 this super 123public static 返回值 方法名 (参数列表)&#123; 方法体;&#125; 代码块构造块12345类&#123; &#123; 构造块 : 初始化 对象 new 执行, 优先于构造方法 &#125;&#125; 静态代码块12345类&#123; static&#123; 静态块: 作用 初始化类 &#125;&#125; 局部块(成员代码块) 方法中用{}扩起来 代码块中的变量作用域在{}中123456方法()&#123;int n ;//局部 &#123; 局部块：控制局部变量的声明周期 和 使用范围。 &#125;&#125; 静态下成员,方法,代码块的加载顺序 加载 主类,静态代码块, main方法 加载 使用的类 到 方法区 加载 使用的类 的 静态成员 到方法区的静态区,默认初始化 加载 使用的类 的 静态成员和静态代码块 声明处初始化静态成员,静态代码块. 静态代码块只执行一次 顺序: 静态块 &gt; 构造块 &gt; 构造器 静态导入格式:import static 包名.类名.静态方法名可以导入某个类型下的静态成员 单例模式 保证创建的对象 始终是同一个 懒汉式12345678910111213class Test2&#123; private static Test2 t2 = null; private Test2()&#123; &#125; pbulic static Test2 getInstance()&#123; if(t2==null)&#123; t2 = new Test2(); &#125; return t2; &#125;&#125; 饿汉式12345678910class Test2 &#123; private static Test2 t2 = new Test2(); private Test2()&#123; &#125; public static Test2 getInstance()&#123; return t2; &#125;&#125; 二者区别 饿汉类加载时对象就创建了； 懒汉在使用时，才会创建对象； 饿汉多线程访问，安全； 懒汉多我程访问，不妾全。 Math类 针对数学的一个类java.lang.Math(不用导包)方法都式static的 double ceil(double d): 获取大于指定参数的最小整数 Math.ceil(33.4) //34.0 double floor(double d) 获取小于指定参数的最大整数 Math.floor(33.4) //33.0 long round(double d) 四舍五入 Math.round(33.5) //34 double pow(double a,double b) a是底 b是指数 Math.pow(2,3) //8.0 double random() 产生[0.1)的随机小数 产生任意范围内[m,n]的随机数(int)(Math.rando*(n-m+1)+m) Random类 java.util.Random 1234//创建对象Random r = new Random();r.nextInt(10);//产生[0,10)之间的随机整理r.nextDouble();//产生随机小数[0.1) 继承 根据已有的类 派生出 新类的技术 优点: 代码重用； 方便维护，高耦合 继承的注意： private 修饰的不能继承 构造器不能继承,但能通过super调用 不在同一包下的子类 父类使用默认修饰符的方法 继承遵循的原则:里氏替换原则(LSP): 将父类用子类替换,程序不会出错 方法重写 @override 注解,给编译器提示信息,会检查重写规则的正误子类重写(覆盖)了父类的方法特征： 实例成员的方法,在子类中, 方法名相同, 参数相同, 父类参数 擦除后 与 子类相同即可 返回值类型相同 引用类型 子类 返回值类型 可以是 父类的子类型 访问权限 访问权限 不能比父类更严格(低) 异常类型 不能比父类更大 子类 修改 父类的功能 子类 扩展 了父类的功能 子类访问父类成员super: 父类的范围。 调用父类的成员； 1.区分 父类 和子类 同名的成员； 2.super() 调用 父类构造 。 子类访问父类的构造方法 创建 子类对象时 一定 会 先调用父类构造。 在子类的 构造器中 ，如果 没有 显示的调用 父类的 构造器super(),或者 没有显示的 调用 本类构造 this(),那么 编译器 一定 会 分配一个 super() 调用 父类的无参构造。 super() 位置 在子类 构造中 ， 而且 是第一行代码处。 使用: super(); // 无参 super(参数); //带参 父类没有无参构造,只有带参构造,解决办法: 显示调用父类的带参构造super(参数);访问父类的带参构造 在父类写上无参构造 父类派生子类的前提 增加了属性 增加了方法 继承的传递子类可以继承 直接父类的成员也可以继承间接父类的成员 Objecg类 java.lang是所有类的父类 方法 System.gc();强制垃圾回收(只是通知) finalize();//回收之前调用的方法,需要在对象的类中重写 该方法中的this表示回收的垃圾对象 equals():比较对象是否相等，地址值是否相等 clone():克隆一个新的对象 对象.toString(): 返回对象的字符串形式， getClss().getName: 获取对象的类型 @ Integer.toHexString(对象.hashCode()) 由以上三部分组成，无意义，建议重写 print()方法展示对象的时候，会隐式调用toString()]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>静态方法</tag>
        <tag>继承</tag>
        <tag>代码块</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map集合练习]]></title>
    <url>%2Fblog%2F2018%2F08%2F06%2FMap%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[获取字符串中每一个字母出现的次数 分析： A:定义一个字符串(可以改进为键盘录入) B:定义一个TreeMap集合 键:Character 值：Integer C:把字符串转换为字符数组 D:遍历字符数组，得到每一个字符 E:拿刚才得到的字符作为键到集合中去找值，看返回值 是null:说明该键不存在，就把该字符作为键，1作为值存储 不是null:说明该键存在，就把值加1，然后重写存储该键和值 F:定义字符串缓冲区变量 G:遍历集合，得到键和值，进行按照要求拼接 H:把字符串缓冲区转换为字符串输出 录入：aababcabcdabcde 结果：result:a(5)b(4)c(3)d(2)e(1) 123456789101112131415161718192021222324252627282930313233343536373839// 定义一个字符串(可以改进为键盘录入)Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入一个字符串：&quot;);String line = sc.nextLine();// 定义一个TreeMap集合TreeMap&lt;Character, Integer&gt; tm = new TreeMap&lt;Character, Integer&gt;();//把字符串转换为字符数组char[] chs = line.toCharArray();//遍历字符数组，得到每一个字符for(char ch : chs)&#123; //拿刚才得到的字符作为键到集合中去找值，看返回值 Integer i = tm.get(ch); //是null:说明该键不存在，就把该字符作为键，1作为值存储 if(i == null)&#123; tm.put(ch, 1); &#125;else &#123; //不是null:说明该键存在，就把值加1，然后重写存储该键和值 i++; tm.put(ch,i); &#125;&#125;//定义字符串缓冲区变量StringBuilder sb= new StringBuilder();//遍历集合，得到键和值，进行按照要求拼接Set&lt;Character&gt; set = tm.keySet();for(Character key : set)&#123; Integer value = tm.get(key); sb.append(key).append(&quot;(&quot;).append(value).append(&quot;)&quot;);&#125;//把字符串缓冲区转换为字符串输出String result = sb.toString();System.out.println(&quot;result:&quot;+result); 集合的嵌套遍历HashMap嵌套HashMap12345678910111213141516171819202122232425262728293031323334// 创建集合对象HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; map1 = new HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt;();HashMap&lt;String, Integer&gt; map2 = new HashMap&lt;String, Integer&gt;();// 添加元素map2.put(&quot;元素1&quot;, 20);map2.put(&quot;元素2&quot;, 22);// 把小集合添加到大集合map1.put(&quot;大集合1&quot;, map2);HashMap&lt;String, Integer&gt; map3 = new HashMap&lt;String, Integer&gt;();map3.put(&quot;元素1&quot;, 21);map3.put(&quot;元素2&quot;, 23);map1.put(&quot;大集合2&quot;, map3);//遍历//遍历集合Set&lt;String&gt; mapSet = map1.keySet();for(String mapKey : mapSet)&#123; System.out.println(mapKey); HashMap&lt;String, Integer&gt; mapValue = map1.get(mapKey); Set&lt;String&gt; mapValueSet = mapValue.keySet(); for(String mapValueKey : mapValueSet)&#123; Integer mapValueValue = mapValue.get(mapValueKey); System.out.println(&quot;\t&quot;+mapValueKey+&quot;---&quot;+mapValueValue); &#125;&#125;大集合1 元素1---20 元素2---22大集合2 元素1---21 元素2---23 HashMap嵌套ArrayList12345678910111213141516171819202122232425262728293031323334353637383940// 创建集合对象HashMap&lt;String, ArrayList&lt;String&gt;&gt; hm = new HashMap&lt;String, ArrayList&lt;String&gt;&gt;();// 创建元素集合1ArrayList&lt;String&gt; array1 = new ArrayList&lt;String&gt;();array1.add(&quot;吕布&quot;);array1.add(&quot;周瑜&quot;);hm.put(&quot;三国演义&quot;, array1);// 创建元素集合2ArrayList&lt;String&gt; array2 = new ArrayList&lt;String&gt;();array2.add(&quot;令狐冲&quot;);array2.add(&quot;林平之&quot;);hm.put(&quot;笑傲江湖&quot;, array2);// 创建元素集合3ArrayList&lt;String&gt; array3 = new ArrayList&lt;String&gt;();array3.add(&quot;郭靖&quot;);array3.add(&quot;杨过&quot;);hm.put(&quot;神雕侠侣&quot;, array3);//遍历集合Set&lt;String&gt; set = hm.keySet();for(String key : set)&#123; System.out.println(key); ArrayList&lt;String&gt; value = hm.get(key); for(String s : value)&#123; System.out.println(&quot;\t&quot;+s); &#125;&#125;神雕侠侣 郭靖 杨过三国演义 吕布 周瑜笑傲江湖 令狐冲 林平之 ArrayList嵌套HashMap12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123;// 创建集合对象ArrayList&lt;HashMap&lt;String, String&gt;&gt; array = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;();// 创建元素1HashMap&lt;String, String&gt; hm1 = new HashMap&lt;String, String&gt;();hm1.put(&quot;周瑜&quot;, &quot;小乔&quot;);hm1.put(&quot;吕布&quot;, &quot;貂蝉&quot;);// 把元素添加到array里面array.add(hm1);// 创建元素1HashMap&lt;String, String&gt; hm2 = new HashMap&lt;String, String&gt;();hm2.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);hm2.put(&quot;杨过&quot;, &quot;小龙女&quot;);// 把元素添加到array里面array.add(hm2);// 创建元素1HashMap&lt;String, String&gt; hm3 = new HashMap&lt;String, String&gt;();hm3.put(&quot;令狐冲&quot;, &quot;任盈盈&quot;);hm3.put(&quot;林平之&quot;, &quot;岳灵珊&quot;);// 把元素添加到array里面array.add(hm3);// 遍历for (HashMap&lt;String, String&gt; hm : array) &#123; Set&lt;String&gt; set = hm.keySet(); for (String key : set) &#123; String value = hm.get(key); System.out.println(key + &quot;---&quot; + value); &#125;&#125;吕布---貂蝉周瑜---小乔杨过---小龙女郭靖---黄蓉令狐冲---任盈盈林平之---岳灵珊 HashMap嵌套HashMap嵌套ArrayList(三层嵌套)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 创建大集合HashMap&lt;String, HashMap&lt;String, ArrayList&lt;Student&gt;&gt;&gt; map = new HashMap&lt;String, HashMap&lt;String, ArrayList&lt;Student&gt;&gt;&gt;();// 北京数据HashMap&lt;String, ArrayList&lt;Student&gt;&gt; bjMap = new HashMap&lt;String, ArrayList&lt;Student&gt;&gt;();ArrayList&lt;Student&gt; array1 = new ArrayList&lt;Student&gt;();Student s1 = new Student(&quot;学生1&quot;, 27);Student s2 = new Student(&quot;学生2&quot;, 30);array1.add(s1);array1.add(s2);ArrayList&lt;Student&gt; array2 = new ArrayList&lt;Student&gt;();Student s3 = new Student(&quot;学生3&quot;, 28);Student s4 = new Student(&quot;学生4&quot;, 29);array2.add(s3);array2.add(s4);bjMap.put(&quot;基础班&quot;, array1);bjMap.put(&quot;就业班&quot;, array2);map.put(&quot;北京校区&quot;, bjMap);// 西安校区数据HashMap&lt;String, ArrayList&lt;Student&gt;&gt; xaMap = new HashMap&lt;String, ArrayList&lt;Student&gt;&gt;();ArrayList&lt;Student&gt; array3 = new ArrayList&lt;Student&gt;();Student s5 = new Student(&quot;学生5&quot;, 27);Student s6 = new Student(&quot;学生6&quot;, 30);array3.add(s5);array3.add(s6);ArrayList&lt;Student&gt; array4 = new ArrayList&lt;Student&gt;();Student s7 = new Student(&quot;学生7&quot;, 28);Student s8 = new Student(&quot;学生8&quot;, 29);array4.add(s7);array4.add(s8);xaMap.put(&quot;基础班&quot;, array3);xaMap.put(&quot;就业班&quot;, array4);map.put(&quot;西安校区&quot;, xaMap);//集合遍历Set&lt;String&gt; mapSet = map.keySet();for (String mapKey : mapSet) &#123; System.out.println(mapKey); HashMap&lt;String, ArrayList&lt;Student&gt;&gt; mapValue = map .get(mapKey); Set&lt;String&gt; mapValueSet = mapValue.keySet(); for (String mapValueKey : mapValueSet) &#123; System.out.println(&quot;\t&quot; + mapValueKey); ArrayList&lt;Student&gt; czbkMapValueValue = mapValue .get(mapValueKey); for (Student s : czbkMapValueValue) &#123; System.out.println(&quot;\t\t&quot; + s.getName() + &quot;---&quot; + s.getAge()); &#125; &#125;&#125;西安校区 就业班 学生7---28 学生8---29 基础班 学生5---27 学生6---30北京校区 就业班 学生3---28 学生4---29 基础班 学生1---27 学生2---30 Hashtable和HashMap的区别?Hashtable:线程安全，效率低。不允许null键和null值HashMap:线程不安全，效率高。允许null键和null值 2:List,Set,Map等接口是否都继承子Map接口?List，Set不是继承自Map接口，它们继承自Collection接口Map接口本身就是一个顶层接口]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合的嵌套遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map子类]]></title>
    <url>%2Fblog%2F2018%2F08%2F06%2FMap%E5%AD%90%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[HashMap类概述键是哈希表结构，可以保证键的唯一性 HashMap&lt;String,String&gt;123456789101112131415161718192021222324252627// 创建集合对象HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();// 创建元素并添加元素// String key1 = &quot;001&quot;;// String value1 = &quot;欧展鹏&quot;;hm.put(&quot;001&quot;, &quot;欧展鹏&quot;);hm.put(&quot;002&quot;, &quot;嘉澜&quot;);hm.put(&quot;002&quot;, &quot;嘉澜&quot;);hm.put(&quot;003&quot;, &quot;丘黎&quot;);hm.put(&quot;004&quot;, &quot;如空月&quot;);hm.put(&quot;005&quot;, &quot;言思晴&quot;);hm.put(&quot;001&quot;, &quot;东方不败&quot;);// 遍历Set&lt;String&gt; set = hm.keySet();for (String key : set) &#123; String value = hm.get(key); System.out.println(key + &quot;---&quot; + value);&#125;结果: 001---欧展鹏 002---嘉澜 003---丘黎 004---如空月 005---东方不败 HashMap&lt;Integer,String&gt;1234567891011121314151617181920212223242526272829303132333435// 创建集合对象HashMap&lt;Integer, String&gt; hm = new HashMap&lt;Integer, String&gt;();// 创建元素并添加元素// Integer i = new Integer(27);// Integer i = 27;// String s = &quot;欧展鹏&quot;;// hm.put(i, s);hm.put(27, &quot;欧展鹏&quot;);hm.put(30, &quot;丘黎&quot;);hm.put(28, &quot;如空月&quot;);hm.put(29, &quot;嘉澜&quot;);// 下面的写法是八进制，但是不能出现8以上的单个数据// hm.put(003, &quot;hello&quot;);// hm.put(006, &quot;hello&quot;);// hm.put(007, &quot;hello&quot;);// hm.put(008, &quot;hello&quot;);// 遍历Set&lt;Integer&gt; set = hm.keySet();for (Integer key : set) &#123; String value = hm.get(key); System.out.println(key + &quot;---&quot; + value);&#125;// 下面这种方式仅仅是集合的元素的字符串表示// System.out.println(&quot;hm:&quot; + hm);&#125;结果: 27---欧展鹏 28---如空月 29---嘉澜 30---丘黎 HashMap&lt;String,Student&gt;1234567891011121314151617181920212223242526272829// 创建集合对象HashMap&lt;String, Student&gt; hm = new HashMap&lt;String, Student&gt;();// 创建学生对象Student s1 = new Student(&quot;欧展鹏&quot;, 58);Student s2 = new Student(&quot;如空月&quot;, 55);Student s3 = new Student(&quot;迦南&quot;, 54);Student s4 = new Student(&quot;球溪&quot;, 50);// 添加元素hm.put(&quot;9527&quot;, s1);hm.put(&quot;9522&quot;, s2);hm.put(&quot;9524&quot;, s3);hm.put(&quot;9529&quot;, s4);// 遍历Set&lt;String&gt; set = hm.keySet();for (String key : set) &#123; // 注意了：这次值不是字符串了 // String value = hm.get(key); Student value = hm.get(key); System.out.println(key + &quot;---&quot; + value.getName() + &quot;---&quot; + value.getAge());&#125;结果: 9524---迦南---54 9522---如空月---55 9529---球溪---50 9527---欧展鹏---58 HashMap&lt;Student,String&gt;12345678910111213141516171819202122232425262728293031323334// 创建集合对象HashMap&lt;Student, String&gt; hm = new HashMap&lt;Student, String&gt;();// 创建学生对象Student s1 = new Student(&quot;貂蝉&quot;, 27);Student s2 = new Student(&quot;王昭君&quot;, 30);Student s3 = new Student(&quot;西施&quot;, 33);Student s4 = new Student(&quot;杨玉环&quot;, 35);Student s5 = new Student(&quot;貂蝉&quot;, 27);// 添加元素hm.put(s1, &quot;8888&quot;);hm.put(s2, &quot;6666&quot;);hm.put(s3, &quot;5555&quot;);hm.put(s4, &quot;7777&quot;);hm.put(s5, &quot;9999&quot;);// 遍历Set&lt;Student&gt; set = hm.keySet();for (Student key : set) &#123; String value = hm.get(key); System.out.println(key.getName() + &quot;---&quot; + key.getAge() + &quot;---&quot; + value);&#125;//要求：如果两个对象的成员变量值都相同，则为同一个对象。//哈希表作用是用来保证键的唯一性的。//需要重写hashCode()和equals()方法结果: 王昭君---30---6666 貂蝉---27---9999 杨玉环---35---7777 西施---33---5555 LinkedHashMap类Map 接口的哈希表和链接列表实现，具有可预知的迭代顺序。 由哈希表保证键的唯一性 由链表保证键盘的有序(存储和取出的顺序一致)12345678910111213141516// 创建集合对象LinkedHashMap&lt;String, String&gt; hm = new LinkedHashMap&lt;String, String&gt;();// 创建并添加元素hm.put(&quot;2345&quot;, &quot;hello&quot;);hm.put(&quot;3456&quot;, &quot;java&quot;);hm.put(&quot;1234&quot;, &quot;world&quot;);hm.put(&quot;1234&quot;, &quot;javaee&quot;);hm.put(&quot;3456&quot;, &quot;android&quot;);// 遍历Set&lt;String&gt; set = hm.keySet();for (String key : set) &#123; String value = hm.get(key); System.out.println(key + &quot;---&quot; + value);&#125; TreeMap类概述键是红黑树结构，可以保证键的排序和唯一性 HashMap&lt;String,String&gt;12345678910111213141516171819202122// 创建集合对象TreeMap&lt;String, String&gt; tm = new TreeMap&lt;String, String&gt;();// 创建元素并添加元素tm.put(&quot;hello&quot;, &quot;你好&quot;);tm.put(&quot;world&quot;, &quot;世界&quot;);tm.put(&quot;java&quot;, &quot;爪哇&quot;);tm.put(&quot;world&quot;, &quot;世界2&quot;);tm.put(&quot;javaee&quot;, &quot;爪哇EE&quot;);// 遍历集合Set&lt;String&gt; set = tm.keySet();for (String key : set) &#123; String value = tm.get(key); System.out.println(key + &quot;---&quot; + value);&#125;结果: hello---你好 java---爪哇 javaee---爪哇EE world---世界2 TreeMap&lt;Student,String&gt;12345678910111213141516171819202122232425262728293031323334353637383940// 创建集合对象TreeMap&lt;Student, String&gt; tm = new TreeMap&lt;Student, String&gt;( new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; // 主要条件 int num = s1.getAge() - s2.getAge(); // 次要条件 int num2 = num == 0 ? s1.getName().compareTo( s2.getName()) : num; return num2; &#125; &#125;);// 创建学生对象Student s1 = new Student(&quot;潘安&quot;, 30);Student s2 = new Student(&quot;柳下惠&quot;, 35);Student s3 = new Student(&quot;唐伯虎&quot;, 33);Student s4 = new Student(&quot;燕青&quot;, 32);Student s5 = new Student(&quot;唐伯虎&quot;, 33);// 存储元素tm.put(s1, &quot;宋朝&quot;);tm.put(s2, &quot;元朝&quot;);tm.put(s3, &quot;明朝&quot;);tm.put(s4, &quot;清朝&quot;);tm.put(s5, &quot;汉朝&quot;);// 遍历Set&lt;Student&gt; set = tm.keySet();for (Student key : set) &#123; String value = tm.get(key); System.out.println(key.getName() + &quot;---&quot; + key.getAge() + &quot;---&quot; + value);&#125;结果: 潘安---30---宋朝 燕青---32---清朝 唐伯虎---33---汉朝 柳下惠---35---元朝 #]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections工具类]]></title>
    <url>%2Fblog%2F2018%2F08%2F06%2FCollections%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Collections:是针对集合进行操作的工具类，都是静态方法。Collection:是单列集合的顶层接口，有子接口List和Set。Collections:是针对集合操作的工具类，有对集合进行排序和二分查找的方法 Collections成员方法* public static &lt;T&gt; void sort(List&lt;T&gt; list)：排序 默认情况下是自然顺序。 * public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key):二分查找 * public static &lt;T&gt; T max(Collection&lt;?&gt; coll):最大值 * public static void reverse(List&lt;?&gt; list):反转 * public static void shuffle(List&lt;?&gt; list):随机置换 代码测试12345678910111213141516171819202122232425// 创建集合对象List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();// 添加元素list.add(30);list.add(20);list.add(50);list.add(10);list.add(40);System.out.println(&quot;list:&quot; + list); //list:[30, 20, 50, 10, 40]Collections.sort(list);System.out.println(&quot;list:&quot; + list); //list:[10, 20, 30, 40, 50]System.out.println(&quot;binarySearch:&quot; + Collections.binarySearch(list, 30)); //binarySearch:2(前提:有序)System.out.println(&quot;binarySearch:&quot; + Collections.binarySearch(list, 300)); //binarySearch:-6System.out.println(&quot;max:&quot;+Collections.max(list)); //max:50Collections.reverse(list);System.out.println(&quot;list:&quot; + list); //list:[40, 10, 50, 20, 30]Collections.shuffle(list);System.out.println(&quot;list:&quot; + list); //list:[20, 40, 30, 10, 50] list:[40, 10, 20, 50, 30]等等 排序比较器排序static void sort(List list, Comparator&lt;? super T&gt; c)根据指定的比较器指定的顺序对指定的列表进行排序如果同时有自然排序和比较器排序，以比较器排序为主12345678Collections.sort(list, new Comparator&lt;Student&gt;() &#123;@Overridepublic int compare(Student s1, Student s2) &#123; int num = s1.getAge() - s2.getAge(); int num2 = num == 0 ? s1.getName().compareTo(s2.getName()): num; return num2;&#125;&#125;); 自然排序 Student 类要实现 implements Comparable重写compareTo 方法123456@Overridepublic int compareTo(Student s) &#123; int num = this.age - s.age; int num2 = num == 0 ? this.name.compareTo(s.name) : num; return num2;&#125; 模拟斗地主1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static void main(String[] args) &#123;//1.创建一个牌盒ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();//2.装牌//定义一个花色数组String[] colors = &#123;&quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot;&#125;;//定义一个点数String[] numbers = &#123;&quot;A&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;&#125;;//3.装牌for (String color : colors) &#123; for (String number : numbers) &#123; array.add(color.concat(number)); &#125;&#125;//4.洗牌Collections.shuffle(array);//5.发牌ArrayList&lt;String&gt; zhangsan = new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; lisi = new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; wangwu = new ArrayList&lt;String&gt;();ArrayList&lt;String&gt; diPai = new ArrayList&lt;String&gt;();for (int i = 0; i &lt; array.size(); i++) &#123; if (i &lt; array.size() - 3) &#123; if (i % 3 == 0) &#123; zhangsan.add(array.get(i)); &#125; if (i % 3 == 1) &#123; lisi.add(array.get(i)); &#125; if (i % 3 == 2) &#123; wangwu.add(array.get(i)); &#125; &#125; else &#123; diPai.add(array.get(i)); &#125;&#125;//6.看牌//张三看牌System.out.print(&quot;张三:&quot;);for (String str : zhangsan) System.out.print(str + &quot; &quot;);System.out.print(&quot;\n李四:&quot;);for (String str : lisi) System.out.print(str + &quot; &quot;);System.out.print(&quot;\n王五:&quot;);for (String str : wangwu) System.out.print(str + &quot; &quot;);System.out.print(&quot;\n底牌:&quot;);for (String str : diPai) System.out.print(str + &quot; &quot;);&#125; 对扑克牌排序(整理)思路： A:创建一个HashMap集合 B:创建一个ArrayList集合 C:创建花色数组和点数数组 D:从0开始往HashMap里面存储编号，并存储对应的牌 同时往ArrayList里面存储编号即可。 E:洗牌(洗的是编号) F:发牌(发的也是编号，为了保证编号是排序的，就创建TreeSet集合接收) G:看牌(遍历TreeSet集合，获取编号，到HashMap集合找对应的牌) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public static void main(String[] args) &#123;// 创建一个HashMap集合HashMap&lt;Integer, String&gt; hm = new HashMap&lt;Integer, String&gt;();// 创建一个ArrayList集合ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();// 创建花色数组和点数数组// 定义一个花色数组String[] colors = &#123; &quot;♠&quot;, &quot;♥&quot;, &quot;♣&quot;, &quot;♦&quot; &#125;;// 定义一个点数数组String[] numbers = &#123; &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;, &quot;2&quot;, &#125;;// 从0开始往HashMap里面存储编号，并存储对应的牌,同时往ArrayList里面存储编号即可。int index = 0;for (String number : numbers) &#123; for (String color : colors) &#123; String poker = color.concat(number); hm.put(index, poker); array.add(index); index++; &#125;&#125;hm.put(index, &quot;小王&quot;);array.add(index);index++;hm.put(index, &quot;大王&quot;);array.add(index);// 洗牌(洗的是编号)Collections.shuffle(array);// 发牌(发的也是编号，为了保证编号是排序的，就创建TreeSet集合接收)TreeSet&lt;Integer&gt; fengQingYang = new TreeSet&lt;Integer&gt;();TreeSet&lt;Integer&gt; linQingXia = new TreeSet&lt;Integer&gt;();TreeSet&lt;Integer&gt; liuYi = new TreeSet&lt;Integer&gt;();TreeSet&lt;Integer&gt; diPai = new TreeSet&lt;Integer&gt;();for (int x = 0; x &lt; array.size(); x++) &#123; if (x &gt;= array.size() - 3) &#123; diPai.add(array.get(x)); &#125; else if (x % 3 == 0) &#123; fengQingYang.add(array.get(x)); &#125; else if (x % 3 == 1) &#123; linQingXia.add(array.get(x)); &#125; else if (x % 3 == 2) &#123; liuYi.add(array.get(x)); &#125;&#125;// 看牌(遍历TreeSet集合，获取编号，到HashMap集合找对应的牌)lookPoker(&quot;张三&quot;, fengQingYang, hm);lookPoker(&quot;李四&quot;, linQingXia, hm);lookPoker(&quot;王五&quot;, liuYi, hm);lookPoker(&quot;底牌&quot;, diPai, hm);&#125;// 写看牌的功能public static void lookPoker(String name, TreeSet&lt;Integer&gt; ts, HashMap&lt;Integer, String&gt; hm) &#123;System.out.print(name + &quot;的牌是：&quot;);for (Integer key : ts) &#123; String value = hm.get(key); System.out.print(value + &quot; &quot;);&#125;System.out.println();&#125;张三的牌是：♠A ♦A ♣3 ♠4 ♦4 ♥5 ♦6 ♠7 ♥7 ♣8 ♥9 ♣9 ♥J ♦J ♥Q ♠K 小王 李四的牌是：♥A ♣A ♥2 ♦2 ♥3 ♦3 ♥4 ♣4 ♣5 ♦5 ♣7 ♦7 ♥8 ♦9 ♥10 ♦10 ♣Q 王五的牌是：♠2 ♣2 ♠3 ♠6 ♥6 ♣6 ♠8 ♦8 ♠9 ♣10 ♠J ♠Q ♦Q ♥K ♣K ♦K 大王 底牌的牌是：♠5 ♠10 ♣J]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Collections工具类</tag>
        <tag>模拟斗地主</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Map接口]]></title>
    <url>%2Fblog%2F2018%2F08%2F06%2FMap%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Map接口概述将键映射到值的对象 一个映射不能包含重复的键 每个键最多只能映射到一个值 Map接口和Collection接口的不同 Map是双列的,Collection是单列的 Map的键唯一,Collection的子体系Set是唯一的 Map集合的数据结构值针对键有效，跟值无关 Collection集合的数据结构是针对元素有效 Map集合的一个最大的特点，就是它可以存储键值对的元素。 Map接口成员方法’1:添加功能 V put(K key,V value):添加元素。 如果键是第一次存储，就直接存储元素，返回null 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 2:删除功能 void clear():移除所有的键值对元素 V remove(Object key)：根据键删除键值对元素，并把值返回 3:判断功能 boolean containsKey(Object key)：判断集合是否包含指定的键 boolean containsValue(Object value):判断集合是否包含指定的值 boolean isEmpty()：判断集合是否为空 4:获取功能 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():返回的是键值对对象的集合 V get(Object key):根据键获取值 Set&lt;K&gt; keySet():获取集合中所有键的集合 Collection&lt;V&gt; values():获取集合中所有值的集合 5：长度功能 int size()：返回集合中的键值对的对数 12345678910111213141516171819202122// 创建集合对象Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();//添加元素System.out.println(&quot;put:&quot; + map.put(&quot;0001&quot;, &quot;麓殇&quot;)); //put:nullSystem.out.println(&quot;put:&quot; + map.put(&quot;0001&quot;, &quot;旧青画&quot;)); //put:麓殇System.out.println(&quot;put:&quot; + map.put(&quot;0002&quot;, &quot;蓝奕世&quot;)); // put:nullSystem.out.println(&quot;put:&quot; + map.put(&quot;0003&quot;, &quot;不可言&quot;)); // put:nullSystem.out.println(&quot;put:&quot; + map.put(&quot;0004&quot;, &quot;苏莫晨&quot;)); // put:null//void clear():移除所有的键值对元素map.clear();System.out.println(&quot;size:&quot;+map.size()); //size:0System.out.println(&quot;remove:&quot; + map.remove(&quot;0001&quot;)); //remove:旧青画System.out.println(&quot;remove:&quot; + map.remove(&quot;0005&quot;)); //remove:nullSystem.out.println(&quot;map:&quot; + map); //map:&#123;0004=苏莫晨, 0002=蓝奕世, 0003=不可言&#125;System.out.println(&quot;isEmpty:&quot;+map.isEmpty()); //isEmpty:falseSystem.out.println(&quot;containsKey:&quot; + map.containsKey(&quot;0004&quot;)); //containsKey:trueSystem.out.println(&quot;containsKey:&quot; + map.containsKey(&quot;0005&quot;)); //containsKey:false 1234567891011121314151617181920212223242526// 获取功能// V get(Object key):根据键获取值System.out.println(&quot;get:&quot; + map.get(&quot;0001&quot;)); //旧青画System.out.println(&quot;get:&quot; + map.get(&quot;周杰&quot;)); // 返回null// Set&lt;K&gt; keySet():获取集合中所有键的集合Set&lt;String&gt; set = map.keySet();for (String key : set) &#123; System.out.println(key);&#125;结果: 0004 0002 0003 0001// Collection&lt;V&gt; values():获取集合中所有值的集合Collection&lt;String&gt; con = map.values();for (String value : con) &#123; System.out.println(value);&#125;结果: 苏莫晨 蓝奕世 不可言 旧青画 Map集合的遍历思路： A:把所有的丈夫给集中起来。 B:遍历丈夫的集合，获取得到每一个丈夫。 C:让丈夫去找自己的妻子。 转换： A:获取所有的键 B:遍历键的集合，获取得到每一个键 C:根据键去找值 12345678910111213141516171819// 创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 创建元素并添加到集合 map.put(&quot;杨过&quot;, &quot;小龙女&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨康&quot;, &quot;穆念慈&quot;); map.put(&quot;陈玄风&quot;, &quot;梅超风&quot;); // 遍历 // 获取所有的键 Set&lt;String&gt; set = map.keySet(); // 遍历键的集合，获取得到每一个键 for (String key : set) &#123; // 根据键去找值 String value = map.get(key); System.out.println(key + &quot;---&quot; + value); &#125; &#125; 思路： A:获取所有结婚证的集合 B:遍历结婚证的集合，得到每一个结婚证 C:根据结婚证获取丈夫和妻子 转换： A:获取所有键值对对象的集合 B:遍历键值对对象的集合，得到每一个键值对对象 C:根据键值对对象获取键和值 123456789101112131415161718// 创建集合对象Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();// 创建元素并添加到集合map.put(&quot;杨过&quot;, &quot;小龙女&quot;);map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);map.put(&quot;杨康&quot;, &quot;穆念慈&quot;);map.put(&quot;陈玄风&quot;, &quot;梅超风&quot;);// 获取所有键值对对象的集合Set&lt;Map.Entry&lt;String, String&gt;&gt; set = map.entrySet();// 遍历键值对对象的集合，得到每一个键值对对象for (Map.Entry&lt;String, String&gt; me : set) &#123; // 根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + &quot;---&quot; + value);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Map集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day07]]></title>
    <url>%2Fblog%2F2018%2F08%2F06%2Fjava%E5%9F%BA%E7%A1%80day07%2F</url>
    <content type="text"><![CDATA[封装 隐藏类中的属性和实现细节,对外只提供公共的访问方式好处 访问的安全性 方法中可以使用流程控制语句 只能用我们提供的公共的访问方式访问 private 私有的被 private 修饰的方法和属性只能在 本类中使用 get,set访问器命名习惯: getXxx();setXxx(); 只读: 用 getXxx(); 可读可写 二种都用 this 本类对象区分 同名的 局部变量 和 成员变量this(参数);调用构造器 - 调用构造器 - 写在构造器中 - 作用就是来调用构造器 - 位置在构造器的第一行代码. 方法的重载 通常是一个类中, 方法名相同,参数列表不同作用: 名字方便记忆返回值不能作为区分方法重载的依据 123456789101112131415//注意要明确public void f(int a ,double b)&#123; System.out.println(&quot;int_ double&quot;);&#125;public void f(double b,int a)&#123; System.out.println(&quot;double_int&quot;);&#125;测试: 任意一个存在,都会自动转换为对应类型 对象.f(22,11); 二个都存在; 对象.f(22,11); //编译出错 可变参数的重载12345678910111213141516171819202122232425262728293031323334public void f(int[] arr)&#123; &#125;public void f(int... arr)&#123; &#125;重载失败,都是数组===============================public void f(int arr)&#123; &#125;public void f(int... arr)&#123; &#125;可以重载对象.f(22):走的是(int arr): 多个参数是JDK1.5之后出来的.=================================//参数为引用类型public void f(String str) &#123;&#125;public void f(Demo1 demo) &#123;&#125;可以重载,但是: 对象.f(null); //编译不能通过 构造方法 名字和 类名相同作用 :完成对象初始化不定义任何返回类型 格式:123访问修饰符 构造方法名(参数列表 )&#123; //初始化代码&#125; 构造器的分类默认的分类 默认构造器 - 我们类中没有显示定义构造器 - 那么,编译器会自动创建一个默认构造器 - 此方法无参,访问权限与类相同 自己定义: 显示定义了构造器 默认构造器就不存在 1. 无参 2. 带参 构造代码块 执行顺序: 构造代码块 早于 构造方法解决构造器重载代码冗余的作用 声明处初始化 和 构造代码块的区别功能一样,构造块可以添加其他代码 成员变量初始化顺序 默认初始化 声明处初始化 构造代码块初始化 构造器初始化 2,3 处看代码中定义的顺序 构造器和普通方法的区别 构造器就是用来初始化对象的 普通方法是为了完成特定的功能 构造只有 new 创建对象的时候才能调用; 普通方法 创建对象 随时调用 构造器和访问器： 构造是创建对象的时候new初始化。 对象创建完成，所有值都赋值完成； 访问器是创建对象后，完成赋值； 对象创建完成，都是默认值。 构造可以在创建对象是一次性给所有属性赋值； 访问器需要，创建对象后一个一个赋值； 创建对象后属性值的更改只能用访问器； 创建对象后属性值的访问只能用访问器 创建对象的时候完成初始化修改setXxxx()访问器12345678public Demo setNama(String name)&#123; this.name=name; return this;&#125;----------------// 解决了构造方法参数记忆问题Demo d = new Demo().setName(&quot;豆沙&quot;).setAge(18); 包管理 类 和 接口 的一种工具程序包 一定层次结构 作用:1.方便管理类；2.解决命名冲突的问题；3.更好的保护类和类中的成员。 package 父包名[.子类名.子类名….] 包名规范 - 都小写 - 包名唯一 - com/org.公司名.部门名.项目名.模块名 - package 声明必须放第一位 ,后面是导包, 类 不导包:使用完全限定命名的方式: 包名.类 对象名 = new 包名.类名;多次使用不建议 注意： 不同包，需要使用 导入包： 不同包，可以导包，也可以使用完全限定命名； 导入父包，不会导入（包括）子包下的类型： 两个包下的类同名了，用完全限定命名的方式。 导包: 通配符: 使用*; 想要导入 b.c.Test 不能使用b. b.只能导入b包下的类 如果二个包下类名相同, 使用完全限定命名的方式 访问权限修饰符 访问权限 本类 同包 子类 不同包 private 可以 默认 可以 可以 protected 可以 可以 可以 public 可以 可以 可以 可以 修饰符static 含静态的类加载过程 先加载带主方法的类(class文件)到方法区 堆内存:生成字节码文件对应的对象 在方法区的空间给静态成员变量(类变量)开辟空间,初始化 修饰成员变量 静态变量(类变量) 属于类,存在方法区中 类加载时,就分配空间,赋值了 优先于对象存在的. 被所有对象 所共享 访问： 类名.静态 对象名.静态// 静态变量 属于 类；实例变量 属于 对象； 静态变量 在类加载时 就加载了，存在 方法区中；实例变量 在 创建对象时 创建，存在 堆中。 静态变量 在 类卸载后 才释放。//应用程序结束实例变量 在对象 被垃圾回收 后就释放了。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>封装</tag>
        <tag>重载</tag>
        <tag>构造方法</tag>
        <tag>权限</tag>
        <tag>访问权限修饰符</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Set接口]]></title>
    <url>%2Fblog%2F2018%2F08%2F03%2FSet%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Collection - List :有序(存取的顺序一致),可重复 - Set :无序(存储顺序和取出顺序不一致),唯一 - HashSet :底层是哈希表结构保证唯一 - LinkedHashSet :由链表保证有序,由哈希表保证唯一 - TreeSet:底层数据结构是红黑树(自平衡二叉树),排序和唯一 HashSet集合 底层是哈希表结构。哈希表结构底层依赖:hashCode()和equals()方法。如果你认为对象的成员变量值相同即为同一个对象的话，你就应该重写这两个方法。它不保证set的迭代顺序;特别是它不保证该顺序恒久不变虽然Set集合的元素无序,但是,作为集合来说,它肯定有自己的存储顺序当=存储顺序和它的存储顺序一致时,代表不了有序,可以多存储一些数据,就能看到效果. 1234567891011121314151617181920212223242526// 创建集合对象Set&lt;String&gt; set = new HashSet&lt;String&gt;();// 添加元素set.add(&quot;hello&quot;);set.add(&quot;java&quot;);set.add(&quot;world&quot;);set.add(&quot;java&quot;);set.add(&quot;world&quot;);// 遍历// 方式一:迭代器Iterator&lt;String&gt; it = set.iterator();while (it.hasNext()) &#123; String s = it.next(); System.out.println(s);&#125;//方式二:for(String s : set)&#123; System.out.println(s);&#125;结果: java world hello// 无序 唯一 存储字符串并遍历12345678910111213// 创建集合对象HashSet&lt;String&gt; hs = new HashSet&lt;String&gt;();// 创建并添加元素hs.add(&quot;hello&quot;);hs.add(&quot;world&quot;);hs.add(&quot;java&quot;);hs.add(&quot;world&quot;);// 遍历集合for (String s : hs) &#123; System.out.println(s);&#125; 如何保证唯一 通过查看add方法的源码，我们知道这个方法底层依赖 两个方法：hashCode()和equals()。 步骤： 首先比较哈希值 如果相同，继续走，比较地址值或者走equals() 如果不同,就直接添加到集合中 先看hashCode()值是否相同 相同:继续走equals()方法 返回true： 说明元素重复，就不添加 返回false：说明元素不重复，就添加到集合 不同：就直接把元素添加到集合 如果类没有重写这两个方法，默认使用的Object()。一般来说不同相同。 而String类重写了hashCode()和equals()方法，所以，它就可以把内容相同的字符串去掉。只留下一个。 hashCode()方法理解 由于成员变量值影响了哈希值，所以我们把成员变量值相加即可this.name.hashCode() + this.age; 可能出现下面情况,对象不同,但hashCode一样,会进入equals方法// s1:name.hashCode()=40,age=30// s2:name.hashCode()=20,age=50 尽可能的区分,我们可以把它们乘以一些整数 12345678@Overridepublic int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;&#125; 123System.out.println(&quot;hello&quot;.hashCode()); //99162322System.out.println(&quot;hello&quot;.hashCode()); //99162322System.out.println(&quot;world&quot;.hashCode()); //113318802 equals方法123456789101112131415161718@Overridepublic boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true;&#125; LinkedHashSet类🌩 LinkedHashSet:底层数据结构由哈希表和链表组成。 哈希表保证元素的唯一性。 链表保证元素有素。(存储和取出是一致)1234567891011121314151617LinkedHashSet&lt;String&gt; hs = new LinkedHashSet&lt;String&gt;();// 创建并添加元素hs.add(&quot;hello&quot;);hs.add(&quot;world&quot;);hs.add(&quot;java&quot;);hs.add(&quot;world&quot;);hs.add(&quot;java&quot;);// 遍历for (String s : hs) &#123; System.out.println(s);&#125;结果: hello world java TreeSet类🌩 底层数据结构是红黑树(自平衡二叉树)唯一性: 根据返回值是否为0来判断排序: 1. 自然排序(元素具备比较性) - 让元素所属的类实现自然排序接口Comparable 2. 比较器排序 - 让集合的构造方法接收一个比较器的子类对象Comparator 排序和唯一: 能够对元素按照某种规则进行排序。 - 自然排序 - 提供的 Comparator (比较器)进行排序 - 真正的比较是依赖于元素的compareTo()方法，而这个方法是定义在 Comparable里面的。 自然排序 基本数据类型都实现了自然排序接口(Comparable) 通过观察TreeSet的add()方法，我们知道最终要看TreeMap的put()方法。 基本数据类型12345678910111213141516171819202122// 创建集合对象// 自然顺序进行排序TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;();// 创建元素并添加// 20,18,23,22,17,24,19,18,24ts.add(20);ts.add(18);ts.add(23);ts.add(22);ts.add(17);ts.add(24);ts.add(19);ts.add(18);ts.add(24);// 遍历for (Integer i : ts) &#123; System.out.print(i+&quot;\t&quot;);&#125;结果:17 18 19 20 22 23 24 引用数据类型 如果一个类的元素要想能够进行自然排序，就必须实现自然排序接口 A:你没有告诉我们怎么排序 自然排序，按照年龄从小到大排序 B:元素什么情况算唯一你也没告诉我 成员变量值都相同即为同一个元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Student implements Comparable&lt;Student&gt;&#123; @Override public int compareTo(Student s) &#123; // return 0; // return 1; // return -1; // 这里返回什么，其实应该根据我的排序规则来做 // 按照年龄排序,主要条件 int num = this.age - s.age; // 次要条件 // 年龄相同的时候，还得去看姓名是否也相同 // 如果年龄和姓名都相同，才是同一个元素 int num2 = num == 0 ? this.name.compareTo(s.name) : num; return num2; &#125;&#125;==========================================//按照姓名的长度排序@Overridepublic int compareTo(Student s) &#123; // 主要条件 姓名的长度 int num = this.name.length() - s.name.length(); // 姓名的长度相同，不代表姓名的内容相同 int num2 = num == 0 ? this.name.compareTo(s.name) : num; // 姓名的长度和内容相同，不代表年龄相同，所以还得继续判断年龄 int num3 = num2 == 0 ? this.age - s.age : num2; return num3;&#125;==================================================// 创建集合对象TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;();// 创建元素Student s1 = new Student(&quot;lin&quot;, 27);Student s2 = new Student(&quot;zhang&quot;, 29);Student s3 = new Student(&quot;wang&quot;, 23);Student s4 = new Student(&quot;lin&quot;, 27);Student s5 = new Student(&quot;liu&quot;, 22);Student s6 = new Student(&quot;wu&quot;, 40);Student s7 = new Student(&quot;feng&quot;, 22);Student s8 = new Student(&quot;lin&quot;, 29);// 添加元素ts.add(s1);ts.add(s2);ts.add(s3);ts.add(s4);ts.add(s5);ts.add(s6);ts.add(s7);ts.add(s8);// 遍历for (Student s : ts) &#123; System.out.println(s.getName() + &quot;---&quot; + s.getAge());&#125; 比较器排序集合的比较器排序 TreeSet ts = new TreeSet(); //自然排序public TreeSet(Comparator comparator(接口)) //比较器排序 1TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new MyComparator()); 通过匿名内部类如果一个方法的参数是接口，那么真正要的是接口的实现类的对象而匿名内部类就可以实现这个东西 12345678910111213TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;()&#123; @Override public int compare(Student s1, Student s2)&#123; // 姓名长度 int num = s1.getName().length() - s2.getName().length(); // 姓名内容 int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num; // 年龄 int num3 = num2 == 0 ? s1.getAge() - s2.getAge() : num2; return num3; &#125;&#125;); 自己写一个实现了Comparator接口的类12345678910public class Mycomparator implements Comparator&lt;Student&gt;&#123; @override public int compare(Student s1,Stuedent s2)&#123; int num = s1.getAge()-s2.getAge(); // 年龄大小 int num2 = num==0?s1.getName().compareTo(s2.getName()):num; // 年龄相同,比较姓名 return num2; &#125;&#125; Collection集合总结Collection |--List 有序,可重复 |--ArrayList 底层数据结构是数组，查询快，增删慢。 线程不安全，效率高 |--Vector 底层数据结构是数组，查询快，增删慢。 线程安全，效率低 |--LinkedList 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高 |--Set 无序,唯一 |--HashSet 底层数据结构是哈希表。 如何保证元素唯一性的呢? 依赖两个方法：hashCode()和equals() 开发中自动生成这两个方法即可 |--LinkedHashSet 底层数据结构是链表和哈希表 由链表保证元素有序 由哈希表保证元素唯一 |--TreeSet 底层数据结构是红黑树。 如何保证元素排序的呢? 自然排序 比较器排序 如何保证元素唯一性的呢? 根据比较的返回值是否是0来决定 针对Collection集合我们到底使用谁呢?(掌握)唯一吗? 是：Set 排序吗? 是：TreeSet 否：HashSet 如果你知道是Set，但是不知道是哪个Set，就用HashSet。 否：List 要安全吗? 是：Vector 否：ArrayList或者LinkedList 查询多：ArrayList 增删多：LinkedList 如果你知道是List，但是不知道是哪个List，就用ArrayList。 如果你知道是Collection集合，但是不知道使用谁，就用ArrayList。 如果你知道用集合，就用ArrayList。 在集合中常见的数据结构ArrayXxx:底层数据结构是数组，查询快，增删慢 LinkedXxx:底层数据结构是链表，查询慢，增删快 HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals() TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashSet</tag>
        <tag>LinkedHashSet</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK5的新特性]]></title>
    <url>%2Fblog%2F2018%2F08%2F03%2FJDK5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[新特性自动拆装箱,泛型,增强for,静态导入,可变参数,枚举 增强for增强for概述 简化数组和Collection集合的遍历格式： for(元素数据类型 变量 : 数组或者Collection集合) { 使用变量即可，该变量就是元素 } 注意事项 - 增强for的对象要判断是否为null. 1234567891011121314151617List&lt;String&gt; list = null;// NullPointerException// 这个s是我们从list里面获取出来的，在获取前，最好做一个判断// 说白了，这就是迭代器的功能if (list != null) &#123; for (String s : list) &#123; System.out.println(s); &#125;&#125;// 增强for其实是用来替代迭代器的// ConcurrentModificationException,迭代器也不能并发修改for (String s : array) &#123; if (&quot;world&quot;.equals(s)) &#123; array.add(&quot;javaee&quot;); &#125;&#125; 静态导入格式- import static 包名... .类名... .方法名; - 可以直接导入到方法的级别 12345678910111213141516171819System.out.println(java.lang.Math.abs(-100));System.out.println(java.lang.Math.pow(2, 3));System.out.println(java.lang.Math.max(20, 30));写法太复杂,出现导包.=============================import java.lang.Math;System.out.println(Math.abs(-100));System.out.println(Math.pow(2, 3));System.out.println(Math.max(20, 30));还是觉得复杂,出现静态导入.=============================import static java.lang.Math.abs;import static java.lang.Math.pow;import static java.lang.Math.max;System.out.println(abs(-100));System.out.println(pow(2, 3));System.out.println(max(20, 30)); 注意事项方法必须是静态的如果有多个同名的静态方法，容易不知道使用谁?这个时候要使用，必须加前缀。由此可见，意义不大，所以一般不用，但是要能看懂。123456789101112import static java.lang.Math.abs;import static java.lang.Math.pow;import static java.lang.Math.max;public static void abs(String s)&#123; System.out.println(s);&#125;// System.out.println(abs(-100)); //没有前缀,编译期间报错System.out.println(java.lang.Math.abs(-100)); //需要加前缀System.out.println(pow(2, 3));System.out.println(max(20, 30)); 可变参数 定义方法的时候不知道该定义多少个参数 格式：修饰符 返回值类型 方法名(数据类型… 变量名){} 这里的变量其实是一个数组如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个123456789101112131415161718192021222324252627//多个数求和public static int sum(int... a) &#123; int s = 0; for(int x : a)&#123; s +=x; &#125; return s;&#125;测试:int result = sum(10,20); //编译器:result=sum(new int[] &#123;a, b&#125;);result = sum(10,20,30);result = sum(10,20,30,40);result = sum(10,20,30,40,50);==================================public static int sum(int b ,int... a) &#123; int s = 0; for(int x : a)&#123; s +=x; &#125; return s;&#125;// 程序会把第一个数据赋值给b,剩下的给数组a,public static int sum(int... a,int b ) //编译期间报错,全部给了a,b没有赋值]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK5特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day06]]></title>
    <url>%2Fblog%2F2018%2F08%2F03%2Fjava%E5%9F%BA%E7%A1%80day06%2F</url>
    <content type="text"><![CDATA[方法123访问修饰符 返回值类型 方法名(参数1，参数2….，参数n)&#123; 方法体；&#125; 带返回值的方法 定义：返回的值的类型与声明的类型必须一致。只能返回一个值； 无参数，无返回值 void 方法名( ){ 方法体；} 无参，有返回值 int 方法名( ){ 方法体；} 有参，无返回值 void 方法名(参数1，参数2….，参数n){ 方法体；} 有参，有返回值 返回值类型 方法名(参数1，参数2….，参数n){ 方法体；}this关键字 表示本类对象 当前对象 成员变量 和局部变量区别 作用域 优先级 初始值 方法参数传递 基本数据类型作为参数 数据不影响 数据在二个栈区,互不影响 引用数据 传的引用,能修改堆内存的数据123456789101112131415161718192021222324252627282930313233class Param&#123; int value;&#125;public class Test&#123; public void f1(int n )&#123; n=22; &#125; public void f2(Param p )&#123; p.value=22; &#125; public void f3(Param p )&#123; p=new Param(); p.value=33; &#125; public static void mian()&#123; Test t1 = new Test(); int m=11; t1.f1(m); System.out.println(m); //m=11; //------------------------------------- Param p1 = new Param(); t1.f2(p1); System.out.println(p1.value); //22 //------------------------------------- t1.f3(p1); p1.value=11; System.out.println(p1.value); //11 &#125;&#125; 可变参数 格式: 权限修饰符 返回类型 方法名(数据类型... 名称(数组名)) 底层是数组:形参:new int[]{输入的数据,…} 特点: 可以不传参 传一个 或 多个参数 传一个数组 注意: 可变参数只能有一个 多个参数时,可变参数必须放最后 数组参数 和 可变参数 的区别 数组作参数,只能穿参 数组 数组参数 可以有多个 数组参数 参数可以任意位置 主方法的参数使用 public 权限最大 static 静态 通过类名找方法 void 无返回值 String[] args 字符串数组 使用: cmd下 java 包名.类名 “参数” “参数”(空格分隔) 递归 递归是允许程序 反复 调用自己的方式要有出口]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>类和对象</tag>
        <tag>方法参数传递</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型概述 是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。 为什么会有泛型呢?问题引入123456789101112131415161718// 创建集合ArrayList array = new ArrayList();// 添加元素array.add(&quot;hello&quot;);array.add(&quot;world&quot;);array.add(&quot;java&quot;);array.add(10); // JDK5以后的自动装箱// 等价于：array.add(Integer.valueOf(10));// 遍历Iterator&lt;String&gt; it = array.iterator();while (it.hasNext()) &#123; // ClassCastException // String s = (String) it.next(); String s = it.next(); System.out.println(s);&#125; 解释因为我们开始存储的时候，存储了String和Integer两种类型的数据。在遍历的时候，我们把他们都当做String类型处理，所以报错但是呢，它在编译期间却没有告诉我们。集合也模仿着数组的这种做法，在创建对象的时候明确元素的数据类型。这样就不会在有问题了。而这种技术被称为：泛型。 存在的问题有两个： 向集合中添加对象元素的时候，没有对元素的类型进行检查，也就是说，我们往集合中添加任意对象，编译器都不会报错。 当我们从集合中获取一个值的时候，我们不能都使用Object类型，需要进行强制类型转换。而这个转换过程由于在添加元素的时候没有作任何的类型的限制跟检查，所以容易出错。例如上面代码中的：String s = (String) it.next(); 泛型的好处格式： &lt;数据类型&gt; 此处的数据类型只能是引用类型。 好处： A:把运行时期的问题提前到了编译期间 B:避免了强制类型转换 C:优化了程序设计，解决了黄色警告线 泛型使用位置看API，如果类，接口，抽象类后面跟的有&lt;E&gt;就说要使用泛型。一般来说就是在集合中使用。 12345678910111213141516// 用ArrayList存储字符串元素，并遍历。用泛型改进代码ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;();//添加array.add(&quot;hello&quot;);array.add(&quot;world&quot;)&apos;//遍历Iterator&lt;String&gt; it = array.iterator();while(it.hasNext())&#123; String s = it.next(); System.out.println(s);&#125;System.out.println(&quot;-----------------&quot;);for (int x = 0; x &lt; array.size(); x++) &#123; String s = array.get(x); System.out.println(s);&#125; 泛型推断:JDK7的新特性 ArrayList array = new ArrayList&lt;&gt;();但是不建议这样使用。 ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;();(推荐) 存储自定义对象123456789101112131415161718192021222324// 创建元素对象ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;();Student s1 = new Student(&quot;曹操&quot;, 40); // 后知后觉Student s2 = new Student(&quot;蒋干&quot;, 30); // 不知不觉Student s3 = new Student(&quot;诸葛亮&quot;, 26);// 先知先觉// 添加元素array.add(s1);array.add(s2);array.add(s3);// 遍历Iterator&lt;Student&gt; it = array.iterator();while (it.hasNext()) &#123; Student s = it.next(); System.out.println(s.getName() + &quot;---&quot; + s.getAge());&#125;System.out.println(&quot;------------------&quot;);for (int x = 0; x &lt; array.size(); x++) &#123; Student s = array.get(x); System.out.println(s.getName() + &quot;---&quot; + s.getAge());&#125; 不用泛型之前 早期的时候，我们使用Object来代表任意的类型。 向上转型是没有任何问题的，但是在向下转型的时候其实隐含了类型转换的问题。 也就是说这样的程序其实并不是安全的。所以Java在JDK5后引入了泛型，提高程序的安全性。 12345678910111213141516171819202122232425262728293031定义类：public class ObjectTool &#123; private Object obj; public Object getObj() &#123; return obj; &#125; public void setObj(Object obj) &#123; // Object obj = new Integer(30);要传入基本数据 this.obj = obj; &#125;&#125;===========================================================================================使用：// 正常使用ObjectTool ot = new ObjectTool();ot.setObj(new Integer(27));Integer i = (Integer) ot.getObj();System.out.println(&quot;年龄是：&quot; + i); //年龄是：27ot.setObj(new String(&quot;上官柳丝&quot;));String s = (String) ot.getObj();System.out.println(&quot;姓名是：&quot; + s); //姓名是：上官柳丝ot.setObj(new Integer(30));// ClassCastExceptionString ss = (String) ot.getObj();System.out.println(&quot;姓名是：&quot; + ss); // ClassCastException 使用泛型泛型类 把泛型定义在类上格式:public class 类名&lt;泛型类型1,…&gt;注意:泛型类型必须是引用类型 123456789101112131415161718192021222324252627282930//定义泛型类public class ObjectTool&lt;T&gt; &#123; private T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125;====================================================// 创建泛型类对象ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;();// ot.setObj(new Integer(27)) //报错。编译期间就过不去ot.setObj(new String(&quot;上官柳丝&quot;));String s = ot.getObj();System.out.println(&quot;姓名是：&quot; + s); //姓名是：上官柳丝-------------------------------------------------------ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;();//ot2.setObj(new String(&quot;上官柳丝&quot;));//这个时候编译期间就过不去ot2.setObj(new Integer(27));Integer i = ot2.getObj();System.out.println(&quot;年龄是：&quot;+ i); //年龄是：27 泛型方法 把泛型定义在方法上 格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .)123456789101112131415161718192021222324252627282930我们如果定义为泛型类，想要输出不同格式：要创建不同的对象ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;();ot.show(&quot;hello&quot;);ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;();ot2.show(100);ObjectTool&lt;Boolean&gt; ot3 = new ObjectTool&lt;Boolean&gt;();ot3.show(true);我们可以将泛型定义在方法上面-----------------------------------------------------------public class ObjectTool()&#123; public &lt;T&gt; void show(T t)&#123; System.out.println(t); ｝&#125;=======================================使用：ObjectTool ot = new ObjectTool();ot.show(&quot;hello&quot;);ot.show(100);ot.show(true);结果： hello 100 true 泛型接口 把泛型定义在接口上 格式:public interface 接口名&lt;泛型类型1…&gt; 接口的实现 public class InterImpl implements Inter｛｝ public class InterImpl&lt;T&gt; implements Inter&lt;T&gt;{}1234567891011121314151617181920212223242526272829303132333435363738394041public interface Inter&lt;T&gt; &#123; public abstract void show(T t);&#125;// 测试Inter&lt;String&gt; i = new InterImpl();i.show(&quot;hello&quot;); //hello==================================================//实现接口//方式一：知道是什么类型public class InterImpl implements Inter&lt;String&gt;&#123; @Override public void show(String t) &#123; // TODO Auto-generated method stub System.out.println(t); &#125;&#125;=======================================================//方式二：不知道是什么类型public class InterImpl&lt;T&gt; implements Inter&lt;T&gt;&#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125;//测试Inter&lt;Stirng&gt; i = new InterImpl&lt;String&gt;();i.show(&quot;hello&quot;); //helloi.show(100); //编译期间报错Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;();ii.show(&quot;hello&quot;); //编译期间报错ii.show(100); //100 泛型高级(通配符)泛型通配符&lt;?&gt; 任意类型 如果没有明确 ，那么就是Object以及任意的Java类 ? extends E 向下限定， E 及其子类 ? super E 向上限定 E 及其父类 Collection&lt;Object&gt; c1 = new ArrayList&lt;Object&gt;(); // 泛型如果明确的写的时候，前后必须一致 Collection&lt;Object&gt; c2 = new ArrayList&lt;Animal&gt;(); Collection&lt;Object&gt; c3 = new ArrayList&lt;Dog&gt;(); Collection&lt;Object&gt; c4 = new ArrayList&lt;Cat&gt;(); // ?表示任意的类型都是可以的 Collection&lt;?&gt; c5 = new ArrayList&lt;Object&gt;(); Collection&lt;?&gt; c6 = new ArrayList&lt;Animal&gt;(); Collection&lt;?&gt; c7 = new ArrayList&lt;Dog&gt;(); Collection&lt;?&gt; c8 = new ArrayList&lt;Cat&gt;(); // ? extends E:向下限定，E及其子类 // Collection&lt;? extends Animal&gt; c9 = new ArrayList&lt;Object&gt;(); //报错,Object不是Animal的子类 Collection&lt;? extends Animal&gt; c10 = new ArrayList&lt;Animal&gt;(); Collection&lt;? extends Animal&gt; c11 = new ArrayList&lt;Dog&gt;(); Collection&lt;? extends Animal&gt; c12 = new ArrayList&lt;Cat&gt;(); // ? super E:向上限定，E极其父类 Collection&lt;? super Animal&gt; c13 = new ArrayList&lt;Object&gt;(); Collection&lt;? super Animal&gt; c14 = new ArrayList&lt;Animal&gt;(); // Collection&lt;? super Animal&gt; c15 = new ArrayList&lt;Dog&gt;(); //报错,Dog是Animal子类 // Collection&lt;? super Animal&gt; c16 = new ArrayList&lt;Cat&gt;(); //报错,Animal是Animal子类 class Animal { } class Dog extends Animal { } class Cat extends Animal { }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List集合练习]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2FList%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ArrayList题目 去除集合中字符串的重复值(字符串的内容相同) 去除集合中自定义对象的重复值(对象的成员变量值都相同) 参考答案： ArrayList去除重复 123456789101112131415161718192021222324252627282930313233343536373839404142434445分析：* A:创建集合对象* B:添加多个字符串元素(包含内容相同的)* C:创建新集合* D:遍历旧集合,获取得到每一个元素* E:拿这个元素到新集合去找，看有没有* 有：不搭理它* 没有：就添加到新集合* F:遍历新集合 // 创建集合对象 ArrayList array = new ArrayList(); // 添加多个字符串元素(包含内容相同的) array.add(&quot;hello&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); array.add(&quot;world&quot;); array.add(&quot;world&quot;); array.add(&quot;world&quot;); array.add(&quot;java&quot;); array.add(&quot;world&quot;); // 创建新集合 ArrayList newArray = new ArrayList(); // 遍历旧集合,获取得到每一个元素 Iterator it = array.iterator(); while (it.hasNext()) &#123; String s = (String) it.next(); // 拿这个元素到新集合去找，看有没有 if (!newArray.contains(s)) &#123; newArray.add(s); &#125; &#125; // 遍历新集合 for (int x = 0; x &lt; newArray.size(); x++) &#123; String s = (String) newArray.get(x); System.out.println(s); &#125; 不创建新的集合去除重复 123456789101112// 由选择排序思想引入，我们就可以通过这种思想做这个题目// 拿0索引的依次和后面的比较，有就把后的干掉// 同理，拿1索引...for(int i =0;i&lt;array.size()-1;i++)&#123; for(int j =i+1;j&lt;array.size();j++)&#123; if(array.get(i).equals(array.get(j)))&#123; array.remove(j); j--; &#125; &#125;&#125; 去除集合中自定义对象的重复值 12345678910111213141516171819202122232425262728293031323334353637Iterator it = array.iterator();while (it.hasNext()) &#123; Student s = (Student) it.next(); // 拿这个元素到新集合去找，看有没有 if (!newArray.contains(s)) &#123; newArray.add(s); &#125;&#125;结果： 对象全部复制到新的数组了；--------------------------------原因: contains()方法的底层依赖的是equals()方法。 而我们的学生类中没有equals()方法，这个时候，默认使用的是它父亲Object的equals()方法 Object()的equals()默认比较的是地址值，所以，它们进去了。因为new的东西，地址值都不同。 按照我们自己的需求，比较成员变量的值，重写equals()即可。-------------------------------------------------------------------------------------@Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (age != other.age) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; linkedListLinkedList模拟栈数据结构的集合栈的特点先进后出 参考答案：LinkedList的特有添加功能addFirst()1234567891011121314//创建集合对象LinkedList link = new LinkedList();//添加元素link.addFirst(&quot;hello&quot;);link.addFirst(&quot;world&quot;);link.addFirst(&quot;java&quot;);//遍历Iterator it = link.iterator();while(it.hasNext())&#123; String s = (String)it.next(); System.out.println(s);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ArrayList去除重复</tag>
        <tag>LinkedList模拟栈</tag>
        <tag>自定义对象的比较</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day05]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2Fjava%E5%9F%BA%E7%A1%80day05%2F</url>
    <content type="text"><![CDATA[数组的常用操作 最大值12345678int[] arr = &#123; 15, 21, 36, 100, 89, 78 &#125;;int max = arr[0];for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125;&#125;System.out.println(&quot;最大值：&quot; + max); 最小值12345678int[] arr = &#123; 15, 21, 36, 100, 89, 78 &#125;;int min = arr[0];for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; max) &#123; min = arr[i]; &#125;&#125;System.out.println(&quot;最大值：&quot; + min); 数组的遍历for循环遍历12345int[] arr = &#123; 15, 21, 36, 100, 89, 78 &#125;;for (int i = 0; i &lt; arr.length - 1; i++) &#123; System.out.println(arr[i]); &#125;&#125; 增强for遍历1234int[] arr = &#123; 15, 21, 36, 100, 89, 78 &#125;;for( int a : arr)&#123; System.out.print(a+&quot; &quot;);&#125; 增强for :更加简洁，一个一个向后访问，，不用考虑越界。 遍历所有元素 只能顺序遍历 不能改变元素的值(对象的属性可以改) 数组排序 升序：从小到大降序：从大到小 冒泡排序 效率并不高冒泡排序是将数组中的两个元素进行比较，并将最小的元素交换到前面排序次数： arr.length-1;1234567891011int[] arr = &#123; 15, 21, 36, 100, 89, 78 &#125;;for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125;&#125;System.out.println(Arrays.toString(arr)); 选择排序1234567891011121314private static void sort(int[] arr) &#123; for(int i =0;i&lt;arr.length-1;i++)&#123; for(int j =i+1;j&lt;arr.length;j++)&#123; if(arr[i]&gt;arr[j])&#123; int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; &#125; &#125; &#125; for(int a : arr) &#123; System.out.print(a+&quot; &quot;); &#125;&#125; 插入排序 检查数组列表中的每个元素，并将其放入已排序元素中的适当位置当最后一个元素放入合适位置时，该数组排序完毕 12345678910111213141516171819public static void main(String[] args) &#123; int[] arr = new int[] &#123; 12, 56, 32, 76, 8, 45, 61 &#125;; Demo1.sort(arr);&#125;private static void sort(int[] arr) &#123; for(int i = 1;i&lt;arr.length;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(arr[i]&lt;arr[j])&#123; int temp=arr[i]; for(int k=i;k&gt;j;k--)&#123; arr[k]=arr[k-1]; &#125; arr[j]=temp; &#125; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 数组查找普通遍历查找二分查找12345678910111213141516171819202122232425Scanner superman = new Scanner(System.in);int start = 0;int end = arr.length-1;//中间位置int middle = (start + end) / 2;System.out.println(&quot;--输入要找的数字：&quot;);int n = superman.nextInt();//中间位置数字不等于 查找的数就循环while(arr[middle] != n) &#123; if(n &gt; arr[middle]) &#123; start = middle +1; &#125;else if(n &lt; arr[middle]) &#123; end = middle -1; &#125; if(start &gt; end) &#123; middle = -1; System.out.println(&quot;不存在&quot;); break; &#125; middle = (start + end) / 2; &#125;System.out.println(middle); 数组的复制创建新数组接收更改数组的引用System类 System.arraycopy(src, srcPos, dest, destPos, length); src -源阵列。 srcPos -源数组中的起始位置。 dest -目标数组。 destPos在目标数据的起始位置。 length -数组元素的数目被复制。 Object类 protected Object clone() 创建并返回此对象的副本。 Arrays类常用方法： toString（array); 数组变字符串 parallelSort(array):在多核的情况下排序 升序排序sort(array); sort(array ,start,end)；对范围[start,end)的数据排序 binarySearch(arr ,searchValue);二分查找（前提：排好序的数组） ， 找不到:返回插入的（位置+1）的负数 equals();判断数组元素是否相等，个数和位置都要相同 fill()：数据填充 fill(arr,起始位置，结束位置，填充值):对指定范围内的数据填充 copyof(arr,元素个数)：产生新的数组对象； copyofRange(arr,from ,to):复制[fron，to)范围元素，返回数组对象 12345678910111213141516171819202122232425int[] arr = &#123; 15, 21, 36, 100, 89, 78 &#125;;//方式一int[] newArr = new int[6];for (int i = 0; i &lt; arr.length; i++) &#123; newArr[i] = arr[i];&#125;System.out.println(&quot;newArr:&quot; + Arrays.toString(newArr));// 方式二int[] arr2 = new int[arr.length];System.arraycopy(arr, 0, arr2, 0, arr.length);System.out.println(&quot;arr2:&quot; + Arrays.toString(arr2));// 方式三int[] arr3;arr3 = arr;System.out.println(&quot;arr3:&quot; + Arrays.toString(arr3));// 方式四int[] arr4 = arr.clone();System.out.println(&quot;arr4:&quot; + Arrays.toString(arr4));// 方式五int[] arr5 = Arrays.copyOf(arr, arr.length);System.out.println(&quot;arr5:&quot; + Arrays.toString(arr5)); 二维数组int[][] arr = new arr[行][列] 本质是一个一元数组里放一个一元数组 1234567891011121314151617Scanner sc = new Scanner(System.in);int[][] arr = new int[2][3];//赋值for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.print(&quot;请输入：&quot;); arr[i][j] = sc.nextInt(); &#125;&#125;// 遍历for (int i = 0; i &lt; 2; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.print(arr[i][j]+ &quot; &quot;); &#125; System.out.println();&#125; 不规则二维数组格式：12345678- int[][] arr2 = new int[][]&#123;&#123;1&#125;,&#123;1,2&#125;,&#123;1,2,3&#125;&#125;;- int[][] arr = new int[row][];for(int i=0;i&lt;row;i++)&#123; arr[i]=new int[i+1];&#125;//不初始化会报空指针异常 杨辉三角形12345678910111213for(int i=0;i&lt;row;i++)&#123; arr[i]=new int[i+1]; for(int j=0;j&lt;arr[i].length;j++)&#123; if(j==0||j==arr[i].length-1)&#123; arr[i][j]=1; &#125;else&#123; arr[i][j]=arr[i-1][j-1]+arr[i-1][j]; &#125; System.out.print(arr[i][j]+&quot;\t&quot;); &#125; System.out.println();&#125; 类和对象对象 实体： 一切可以被描述的事物 类 相似对象的集合，抽象的 1234567891011121314访问修饰符public class 类名&#123; //定义属性部分 属性1的类型属性1； 属性2的类型属性2； .. 属性n的类型属性n； //定义方法部分 方法1； 方法2； ... 方法m；&#125; 类名 类名：帕斯卡命名法 多个单词组成，每个单词首字母大写。 Demo MyDemo 类和对象的区别： 类抽象的；对象是具体的； 类是一个模板，根据这个模板创建出来对象： 类是用数据类型，引用数据类型； String 类 “abc” Person 类 张三 对象是引用变量。 类中的成员 成员变量： 在类中直接定义的。 系统自动初始化。 初始值： 整数：0 浮点：0.0 布尔：false 字符：’\u0000’ 字符串：nul1I 引用类型：nul1（空类型） 局部变量 在方法或代码块中声明的变量 自己初始化，系统不会自动初始化]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>数组操作</tag>
        <tag>Arrays类</tag>
        <tag>类和对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础day04]]></title>
    <url>%2Fblog%2F2018%2F08%2F01%2Fjava%E5%9F%BA%E7%A1%80day04%2F</url>
    <content type="text"><![CDATA[非固定次数循环 do -while for循环 do - while先执行，后条件判断123do&#123;&#125;while(); while 和 do - while的区别 - while: - 先判断，后执行 - 首次判断为假，一次都不执行 - do - while: - 先执行，后判断 - 首次判断为为假，也执行一遍 for格式： 12345for(表达式一；表达式二；表达式三)&#123; 循环体 &#125; 表达式二去掉 --- 死循环 分号不可以去掉 小数的格式化 java.lang &emsp;&emsp;基础类库 java.util &emsp;&emsp;工具类，集合接口 java.math &emsp;&emsp;数学类 java.text &emsp;&emsp;处理文本、日期、数字和消息的类和接口(格式化） printf语句1234//显示小数%f，整数%d，字符%c，布尔%b，double sum = 3.1415927;System.out.printf(&quot;结果是：%f\n&quot;, sum); //结果是：3.141593System.out.printf(&quot;结果是：%.2f\n&quot;, sum); //结果是：3.14 DecimalFormat 类 使用0，不足用0补；#代表位数123456DecimalFormat df=new DecimalFormat(&quot;0000.00&quot;);System.out.println(df.format(46.65657)); //0046.66DecimalFormat df1=new DecimalFormat(&quot;####.##&quot;);System.out.println(df1.format(45.654657)); //45.65DecimalFormat df1=new DecimalFormat(&quot;.00&quot;);System.out.println(df1.format(45.6)); //45.60 跳转语句break作用：结束循环 场合： 循环，switch 12345678910111213// 九九乘法表public static void main(String[] args) &#123; for(int i=1,j =1;i&lt;=9;i++)&#123;//j行 i列 System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+(i*j)+&quot;\t&quot;); if(i==j)&#123; if(j==9) break; j++; i=0; System.out.println(); &#125; &#125;&#125; continue- 作用： 结束本次循环，后面的不执行，进入下一次循环 - 用在循环 123456//输出1-10之间的偶数for(int i =0; i&lt;= 10; i++)&#123; if（i%2 != 0) continue; System.out.print(i+&quot; &quot;);&#125; break结束外层循环 可以在循环的前面加个标签: 123456789101112131415161718192021222324public static void main(String[] args) &#123; a: for (int i = 1; i &lt;= 5; i++) &#123;// 行 for (int j = 1; j &lt;= 5; j++) &#123;// 列 if (j == 3) &#123; // break; // 结束内循环 break a;// 结束外循环 //continue; //第三列消失 &#125; System.out.print(i + &quot;行&quot; + j + &quot;列\t&quot;); &#125; System.out.println(); &#125; System.out.println(&quot;外循环后的代码。&quot;);&#125;break a;结果：1行1列 1行2列 外循环后的代码。continue a;结果：1行1列 1行2列 2行1列 2行2列 3行1列 3行2列 4行1列 4行2列 5行1列 5行2列 外循环后的代码。-------------------------------------break 标签；和return不同 break可以执行后面的代码 数组 数组是长度固定的容器，存储相同数据类型的一组数据 栈内存：模拟的是后进先出的数据结构 入栈：存储数据,只能从栈顶入 弹栈：取出数据,只能从栈顶出 栈的内存相对其他区 容量小 存储 基本数据类型数据 和 引用 频繁创建 和销毁的数据 堆内存 栈的内存大 存储对象的数据 不会频繁创建和销毁 数组的初始化动态初始化我们规定长度，系统赋默认值。格式： 数据类型[] 数组名 = new 数据类型[数组长度];初始化值： 整数 &emsp;&emsp;0 小数&emsp;&emsp;0.0 char&emsp;&emsp;’\u0000’ boolean&emsp;&emsp;false String(引用类型)&emsp;&emsp;null 手动初始化元素个数就是数组的长度。格式： 数据类型[] 数组名 = new 数据类型[]{元素，元素，（元素，.....）};简写： 数据类型[] 数组名 = {元素，元素，（元素，.....）};]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>非固定次数循环</tag>
        <tag>小数格式化</tag>
        <tag>一维数组</tag>
        <tag>队、栈内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List接口]]></title>
    <url>%2Fblog%2F2018%2F07%2F31%2FList%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[List 接口概述（列表） 有序的collection，可以对列表中的每个元素的插入位置进行精确的控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。列表通常允许重复的元素。 List的存储和遍历List存储字符串并遍历1234567891011121314//创建集合对象List list = new ArrayList();//创建字符串并添加list.add(&quot;Hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);//遍历集合Iterator it = list.iterator();while(it.hasNext())&#123; String s = (STring)it.next(); System.out.println(s);&#125; List存储自定义对象并遍历12345678910111213141516171819// 创建集合对象List list = new ArrayList();//创建学生对象Student s1 = new Student(&quot;苏伯陵&quot;,27);Student s2 = new Student(&quot;东方瑾&quot;,26);Student s3 = new Student(&quot;夜子宸&quot;,28);//把学生对象添加到集合中list.add(s1);list.add(s2);list.add(s3);//遍历集合Iterator it = list.terator();while(it.hasNex())&#123; Student s = (Student)it.next(); System.out.println(s.getName + &quot;---&quot; + s.getAge());&#125; List集合的特点：有序(存储和取出的元素一致)，可重复的。1234567891011121314151617181920212223242526// 创建集合对象List list = new ArrayList();// 存储元素list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);list.add(&quot;javaee&quot;);list.add(&quot;android&quot;);list.add(&quot;javaee&quot;);list.add(&quot;android&quot;);// 遍历集合Iterator it = list.iterator();while (it.hasNext()) &#123; String s = (String) it.next(); System.out.println(s);&#125;结果： hello world java javaee android javaee android List 接口的成员方法 添加功能 void add(int index,E element):&emsp;在指定位置添加元素 获取功能 E get(int index):&emsp;获取指定位置的元素 删除功能 E remove(int index):&emsp;根据索引删除元素,返回被删除的元素 修改功能 E set(int index,E element):&emsp;根据索引修改元素，返回被修饰的元素 列表迭代器 ListIterator listIterator():&emsp;List集合特有的迭代器 List的子类ArrayList类概述及使用ArrayList类概述底层数据结构是数组，查询快，增删慢线程不安全，效率高 12345678910111213141516171819202122232425262728//创建list对象List list = new ArrayList();//添加元素list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);----指定位置添加元素---------------------------------------list.add(1,&quot;android&quot;);System.out.println(&quot;list:&quot; + list); //list:[hello, android, world, java] list.add(4, &quot;javaee&quot;); //有问题 IndexOutOfBoundsException list.add(3, &quot;javaee&quot;); //没有问题,在最后添加list:[hello, world, java, javaee]----获取指定位置的元素--------------------------------------System.out.println(&quot;get:&quot; + list.get(1)); //get:worldSystem.out.println(&quot;list:&quot; + list); //list:[hello, world, java]System.out.println(&quot;get:&quot; + list.get(3)); //IndexOutOfBoundsException----索引删除元素，返回被删除的元素--------------------------------------System.out.println(&quot;remove:&quot; + list.remove(1)); //remove:worldSystem.out.println(&quot;list:&quot; + list); //list:[hello, java]System.out.println(&quot;remove:&quot; + list.remove(3)); // IndexOutOfBoundsException----索引修改元素，返回被修饰的元素--------------------------------------System.out.println(&quot;set:&quot; + list.set(1, &quot;javaee&quot;)); //set:worldSystem.out.println(&quot;list:&quot; + list); //list:[hello, javaee, java] ArrayList 自带方法的遍历普通for遍历数组 size() 和 get() 方法1234567891011121314151617//创建lis对象List list = new ArrayList();//添加元素list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);//遍历for(int i = 0;i &lt; list.size(); i++)&#123; String s = (String) list.get(i); System.ou.println(s);&#125;结果： hello world java 遍历自定义对象 size()和get()结合123456789101112131415161718// 创建集合对象List list = new ArrayList();//创建学生对象Student s1 = new Student(&quot;苏伯陵&quot;,27);Student s2 = new Student(&quot;东方瑾&quot;,26);Student s3 = new Student(&quot;夜子宸&quot;,28);//把学生对象添加到集合中list.add(s1);list.add(s2);list.add(s3);//遍历集合for(int i =0; i&lt;list.size();i++)&#123; Student s = (Student)list.ger(i); System.out.println(s.getName + &quot;---&quot; + s.getAge());&#125; 列表迭代器 ListIterator listIterator()：List集合特有的迭代器 - 该迭代器继承了Iterator迭代器，所以，就可以直接使用hasNext()和next()方法。 特有功能： - Object previous():获取上一个元素 - boolean hasPrevious():判断是否有元素 迭代器遍历数组123456789101112131415161718192021222324252627282930// 创建List集合对象List list = new ArrayList();list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);// 集合的遍历// 创建迭代器ListIteartor lit = list.listIterator(); // 子类对象while (lit.hasNext()) &#123; String s = (String) lit.next(); System.out.println(s);&#125;System.out.println(&quot;-----------------&quot;);while (lit.hasPrevious()) &#123; String s = (String) lit.previous(); System.out.println(s);&#125;结果： hello world java ----------------- java world hello 修改集合的内容 我有一个集合，如下，请问，我想判断里面有没有”world”这个元素，如果有，我就添加一个”javaee”元素，请写代码实现。 123456789101112List list = new ArrayList();// 添加元素list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);ListIterator lit = list.listIterator();while(lit.hasNext())&#123; if(lit.next().equals(&quot;world&quot;))&#123; list.add(&quot;javaEE&quot;); &#125;&#125; ↑，ConcurrentModificationException:当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。 产生问题的原因 迭代器依赖集合而存在，在判断成功后，集合中的新添加了元素，而迭代器却不知道，这个错叫并发修改异常。 其实这个问题描述的是：迭代器遍历元素的时候，通过集合是不能修改元素的。 解决办法 迭代器迭代元素，迭代器修改元素 元素是跟在刚才迭代的元素后面的。 而Iterator迭代器却没有添加功能，所以我们使用其子接口ListIterator ListIterator: - void add(); - void remove(); - void set(E e); 1234567891011121314List list = new ArrayList();// 添加元素list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);//迭代器遍历修改ListIterator lit =list.listIterator();while(lit.hasNext())&#123; String s = （String)lit.next(); if(s.equals(&quot;world&quot;))&#123; lit.add(&quot;javaee&quot;); &#125;&#125; 集合遍历元素，集合修改元素(普通for) 元素在最后添加的。 12345678910111213List list = new ArrayList();// 添加元素list.add(&quot;hello&quot;);list.add(&quot;world&quot;);list.add(&quot;java&quot;);//集合遍历修改for(int i =0;i&lt;list.size()；i++)&#123; String s = （String)list.get(i); if（&quot;world&quot;.equals(s)）&#123; list.add(&quot;javaee&quot;); &#125;&#125; Vector类概述底层数据结构是数组，查询快，增删慢线程安全，效率低 Vector的特有功能 添加功能 public void addElement(Object obj)&emsp;&emsp;&emsp;&emsp;– add() 获取功能 public Object elementAt(int index)&emsp;&emsp;&emsp;&emsp; – get() public Enumeration elements()&emsp;&emsp;&emsp;&emsp; – Iterator iterator() boolean hasMoreElements()&emsp;&emsp;&emsp;&emsp; hasNext() Object nextElement()&emsp;&emsp;&emsp;&emsp; next() 一般不用特有的功能，用后面的方法替代，添加遍历与ArrayList相似 LinkedList类概述底层数据结构是链表，查询慢，增删快线程不安全，效率高 LinkedList类特有功能 添加功能 public void addFirst(E e)及addLast(E e) 获取功能 public E getFirst()及getLast() 删除功能 public E removeFirst()及public E removeLast() 12345678910111213141516171819202122232425262728293031323334353637383940// 创建集合对象LinkedList link = new LinkedList();// 添加元素link.add(&quot;hello&quot;);link.add(&quot;world&quot;);link.add(&quot;java&quot;);// public void addFirst(Object e)// link.addFirst(&quot;javaee&quot;);// public void addLast(Object e)// link.addLast(&quot;android&quot;);link:[javaee, hello, world, java, android]-------------------------------------------------// public Object getFirst()// System.out.println(&quot;getFirst:&quot; + link.getFirst());// public Obejct getLast()// System.out.println(&quot;getLast:&quot; + link.getLast());getFirst:hellogetLast:javalink:[hello, world, java]-------------------------------------------------------// public Object removeFirst()System.out.println(&quot;removeFirst:&quot; + link.removeFirst());// public Object removeLast()System.out.println(&quot;removeLast:&quot; + link.removeLast());removeFirst:helloremoveLast:javalink:[world]---------------------------------------------------------// 输出对象名System.out.println(&quot;link:&quot; + link); List的子类特点 子类 底层数据结构 特点 安全 效率 ArrayList 数组 查询快，增删慢 线程不安全 效率高 Vector 数组 查询快，增删慢 线程安全 效率低 LinkedList 链表 查询慢，增删快 线程不安全 效率高 List有三个儿子，我们到底使用谁呢? 看需求(情况)。 要安全吗? 要：Vector(即使要安全，也不用这个了，后面有替代的) 不要：ArrayList或者LinkedList 查询多：ArrayList 增删多：LinkedList 如果你什么都不懂，就用ArrayList。 数据结构 常见数据结构与算法整理总结（上） 数据结构之数组和链表 数据结构之栈和队列]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>List接口的成员方法</tag>
        <tag>List 集合的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2Fblog%2F2018%2F07%2F31%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合类概述为什么出现集合类？ 我们学习的是面向对象语言，而面向对象语言对事物的描述是通过对象体现的，为了方便对多个对象进行操作，我们就必须把这多个对象进行存储。而要想存储多个对象，就不能是一个基本的变量，而应该是一个容器类型的变量，在我们目前所学过的知识里面，有哪些是容器类型的呢? 数组和StringBuffer。但是呢?StringBuffer的结果是一个字符串，不一定满足我们的要求，所以我们只能选择数组，这就是对象数组。 而对象数组又不能适应变化的需求，因为数组的长度是固定的，这个时候，为了适应变化的需求，Java就提供了集合类供我们使用。 数组与集合的区别 数组和集合的区别? 长度区别 数组的长度固定 集合长度可变 B:内容不同 数组存储的是同一种类型的元素 而集合可以存储不同类型的元素 C:元素的数据类型问题 数组可以存储基本数据类型，也可以存储引用数据类型 集合只能存储引用类型 Collection接口概述 Collection:是集合的顶层接口，它的子体系有重复的，有唯一的，有有序的，有无序的。 Collection的功能 添加功能： boolean add(Object obj):添加一个元素 boolean addAll(Object obj):添加一个集合的元素 删除功能： void clear():移除所有元素 boolean remove(Object obj):移除一个元素 boolean removeAll(Collection c): 移除一个集合的元素 判断功能 boolean contains(Object obj):判断集合中是否包含指定的元素 boolean containsAll(COllection c):判断集合中是否包含指定的集合元素 boolean isEmpty():判断集合是否为空 获取功能： Iterator iterator() 长度功能： int size():元素的个数 交集功能 boolean retainAll(Collecton c):二个集合都有的元素 集合转换为数组 Object[] toArray() public T[] toArray(T[] a)1234Integer[] i = new Integer[array.size()];Integer[] ii = array.toArray(i);i 和 ii 的地址一样array.toArray(i); //表示将集合的数据转到了Intger数组 i 中 数组转集合 public static List asList (T… a) 虽然可以把数组转成集合，但是集合的长度不能改变。 123456List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;java&quot;);// list.add(&quot;javaee&quot;); // UnsupportedOperationException,不支持的操作// list.remove(1); // UnsupportedOperationExceptionlist.set(0, &quot;javaee&quot;); 创建集合对象12 Collection c = new ArrayList();// Collection c = new Collection(); //错误，因为接口不能实例化 添加元素 boolean add(Object obj):添加一个元素1234c.add(&quot;hello&quot;);c.add(&quot;world&quot;);c.add(&quot;java&quot;);System.out.println(&quot;c:&quot; + c); //c:[hello, world, java] 移除所有元素 void clear():移除所有元素 boolean remove(Object o):移除一个元素 boolean contains(Object o)：判断集合中是否包含指定的元素123456789101112131415c.clear();System.out.println(&quot;c:&quot; + c); //c:[]System.out.println(&quot;remove:&quot; + c.remove(&quot;hello&quot;)); //remove:trueSystem.out.println(&quot;c:&quot; + c); //c:[world, java]System.out.println(&quot;remove:&quot; + c.remove(&quot;javaee&quot;)); //remove:falseSystem.out.println(&quot;c:&quot; + c); //c:[world, java]System.out.println(&quot;contains:&quot;+c.contains(&quot;hello&quot;)); //contains:trueSystem.out.println(&quot;contains:&quot;+c.contains(&quot;android&quot;)); //contains:falseSystem.out.println(&quot;isEmpty:&quot;+c.isEmpty()); //isEmpty:falseSystem.out.println(&quot;size:&quot;+c.size()); //size:3 带All的方法 boolean addAll(Collection c):添加一个集合的元素 boolean removeAll(Collection c):移除一个集合的元素(是一个还是所有) boolean containsAll(Collection c)：判断集合中是否包含指定的集合元素(是一个还是所有) boolean retainAll(Collection c):两个集合都有的元素?思考元素去哪了，返回的boolean又是什么意思呢? 12345678910111213141516// 创建集合1Collection c1 = new ArrayList();c1.add(&quot;abc1&quot;);c1.add(&quot;abc2&quot;);c1.add(&quot;abc3&quot;);c1.add(&quot;abc4&quot;);// 创建集合2Collection c2 = new ArrayList(); c2.add(&quot;abc1&quot;); c2.add(&quot;abc2&quot;); c2.add(&quot;abc3&quot;); c2.add(&quot;abc4&quot;);c2.add(&quot;abc5&quot;);c2.add(&quot;abc6&quot;);c2.add(&quot;abc7&quot;); 添加boolean addAll(Collection c):添加一个集合的元素123456789System.out.println(&quot;addAll:&quot; + c1.addAll(c2));System.out.println(&quot;c1:&quot; + c1);System.out.println(&quot;c2:&quot; + c2);--------------------------------------------------结果：addAll:truec1:[abc1, abc2, abc3, abc4, abc1, abc2, abc3, abc4, abc5, abc6, abc7]c2:[abc1, abc2, abc3, abc4, abc5, abc6, abc7] 删除boolean removeAll(Collection c):移除一个集合的元素(是一个) 只要有一个数据被移除，就返回true12345678System.out.println(&quot;removeAll:&quot;+c1.removeAll(c2));System.out.println(&quot;c1:&quot; + c1);System.out.println(&quot;c2:&quot; + c2);--------------------------------------------------结果：removeAll:truec1:[]c2:[abc1, abc2, abc3, abc4, abc5, abc6, abc7] 包含boolean containsAll(Collection c)：判断集合中是否包含指定的集合元素(是所有) 只有包含所有的元素，才叫包含1234567891011121314151617System.out.println(&quot;containsAll:&quot;+c1.containsAll(c2));System.out.println(&quot;c1:&quot; + c1);System.out.println(&quot;c2:&quot; + c2);--------------------------------------------------结果：containsAll:falsec1:[abc1, abc2, abc3, abc4]c2:[abc1, abc2, abc3, abc4, abc5, abc6, abc7]System.out.println(&quot;containsAll:&quot;+c2.containsAll(c1));System.out.println(&quot;c1:&quot; + c1);System.out.println(&quot;c2:&quot; + c2);--------------------------------------------------结果：containsAll:truec1:[abc1, abc2, abc3, abc4]c2:[abc1, abc2, abc3, abc4, abc5, abc6, abc7] 交集boolean retainAll(Collection c):两个集合都有的元素?思考元素去哪了，返回的boolean又是什么意思呢? 假设有两个集合A，B。A对B做交集，最终的结果保存在A中，B不变。返回值表示的是A是否发生过改变。 1234567891011121314151617System.out.println(&quot;retainAll:&quot;+c1.retainAll(c2));System.out.println(&quot;c1:&quot; + c1);System.out.println(&quot;c2:&quot; + c2);--------------------------------------------------结果：retainAll:falsec1:[abc1, abc2, abc3, abc4]c2:[abc1, abc2, abc3, abc4, abc5, abc6, abc7]System.out.println(&quot;retainAll:&quot;+c2.retainAll(c1));System.out.println(&quot;c1:&quot; + c1);System.out.println(&quot;c2:&quot; + c2);--------------------------------------------------结果：retainAll:truec1:[abc1, abc2, abc3, abc4]c2:[abc1, abc2, abc3, abc4] 集合的遍历集合转成数组字符串的遍历Object[] toArray():把集合转成数组，可以实现集合的遍历1234567891011121314151617181920212223242526272829// 创建集合对象Collection c = new ArrayList();// 添加元素c.add(&quot;hello&quot;); // Object obj = &quot;hello&quot;; 向上转型c.add(&quot;world&quot;);c.add(&quot;java&quot;);// 遍历// Object[] toArray():把集合转成数组，可以实现集合的遍历Object[] objs = c.toArray();for (int x = 0; x &lt; objs.length; x++) &#123; // System.out.println(objs[x]); // 元素是字符串，获取到元素的的同时，还想知道元素的长度。 // System.out.println(objs[x] + &quot;---&quot; + objs[x].length()); // 上面的实现不了，原因是Object中没有length()方法 // 我们要想使用字符串的方法，就必须把元素还原成字符串 // 向下转型 String s = (String) objs[x]; System.out.println(s + &quot;---&quot; + s.length());&#125;结果： hello---5 world---5 java---4 对象集合的遍历1234567891011121314151617181920212223242526272829303132// 创建集合对象Collection c = new ArrayList();// 创建学生对象Student s1 = new Student(&quot;花绛沁&quot;, 27);Student s2 = new Student(&quot;花锦瑟&quot;, 30);Student s3 = new Student(&quot;尹幽妍&quot;, 33);Student s4 = new Student(&quot;上官柳丝&quot;, 25);Student s5 = new Student(&quot;蝶恋花&quot;, 22);// 把学生添加到集合c.add(s1);c.add(s2);c.add(s3);c.add(s4);c.add(s5);// 把集合转成数组Object[] objs = c.toArray();// 遍历数组for (int x = 0; x &lt; objs.length; x++) &#123; // System.out.println(objs[x]); //向下转型 Student s = (Student) objs[x]; System.out.println(s.getName() + &quot;---&quot; + s.getAge());&#125;结果： 花绛沁---27 花锦瑟---30 尹幽妍---33 上官柳丝---25 蝶恋花---22 迭代器Iterator iterator():迭代器，集合的专用遍历方式 Object next():获取元素,并移动到下一个位置。 NoSuchElementException：没有这样的元素，因为你已经找到最后了。 boolean hasNext():如果仍有元素可以迭代，则返回 true。 字符串的遍历12345678910111213141516171819202122232425// 创建集合对象Collection c = new ArrayList();// 创建并添加元素// String s = &quot;hello&quot;;// c.add(s);c.add(&quot;hello&quot;);c.add(&quot;world&quot;);c.add(&quot;java&quot;);// Iterator iterator():迭代器，集合的专用遍历方式Iterator it = c.iterator(); // 实际返回的肯定是子类对象，这里是多态while (it.hasNext()) &#123; // System.out.println(it.next()); String s = (String) it.next(); System.out.println(s);&#125;结果： hello world java 对象集合的遍历123456789101112131415161718192021222324252627282930313233343536373839// 创建集合对象Collection c = new ArrayList();// 创建学生对象Student s1 = new Student(&quot;花绛沁&quot;, 27);Student s2 = new Student(&quot;花锦瑟&quot;, 30);Student s3 = new Student(&quot;尹幽妍&quot;, 33);Student s4 = new Student(&quot;上官柳丝&quot;, 25);Student s5 = new Student(&quot;蝶恋花&quot;, 22);// 把学生添加到集合c.add(s1);c.add(s2);c.add(s3);c.add(s4);c.add(s5);//遍历Iterator it = c.iterator();while(it.hasNext())&#123; Student s = (Student)it.next(); System.out.println(s.getName() + &quot;---&quot; + s.getAge());&#125;结果： 花绛沁---27 花锦瑟---30 尹幽妍---33 上官柳丝---25 蝶恋花---22注意： NoSuchElementException 不要多次使用it.next()方法 System.out.println(((Student) it.next()).getName() + &quot;---&quot; + ((Student) it.next()).getAge());结果： 花绛沁---30 尹幽妍---25 Exception in thread &quot;main&quot; java.util.NoSuchElementException]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合方法</tag>
        <tag>集合遍历</tag>
        <tag>Iterator 迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象数组]]></title>
    <url>%2Fblog%2F2018%2F07%2F31%2F%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[对象数组 就是数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋给数组就行了。 Student类：1234567891011121314151617181920212223242526272829303132333435363738public class Student &#123; // 成员变量 private String name; private int age; // 构造方法 public Student() &#123; super(); &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; // 成员方法 // getXxx()/setXxx() public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; 数据存储我有5个学生，请把这个5个学生的信息存储到数组中。 1234567891011121314151617181920212223242526// 创建学生数组(对象数组)。 Student[] students = new Student[5]; // for (int x = 0; x &lt; students.length; x++) &#123; // System.out.println(students[x]); // &#125; // System.out.println(&quot;---------------------&quot;); // 创建5个学生对象，并赋值。 Student s1 = new Student(&quot;皖玫&quot;, 27); Student s2 = new Student(&quot;米修&quot;, 30); Student s3 = new Student(&quot;浅唱&quot;, 30); Student s4 = new Student(&quot;明夏沫&quot;, 60); Student s5 = new Student(&quot;冥泷&quot;, 35); // 把C步骤的元素，放到数组中。 students[0] = s1; students[1] = s2; students[2] = s3; students[3] = s4; students[4] = s5; // 看到很相似，就想循环改 // 这个是有问题的，s未定义 // for (int x = 0; x &lt; students.length; x++) &#123; // students[x] = s + &quot;&quot; + (x + 1); // &#125; 遍历对象数组普通for123456for (int x = 0; x &lt; students.length; x++) &#123; Student s = students[x]; System.out.println(s.getName()+&quot;---&quot;+s.getAge()); //System.out.println(students[x]); //调用toString();&#125; 增强for1234for(Student s : students)&#123; System.out.println(s.getName()+&quot;---&quot;+s.getAge()); System.out.println(s);&#125; 二者区别： 增强for: 简洁 不能指定范围访问，只能访问全部 不能逆序（反转）输出 不能修改元素的值]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>对象数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础第三天]]></title>
    <url>%2Fblog%2F2018%2F07%2F31%2FJava%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[运算符的优先级 口诀：单目乘除为关系，逻辑三目后赋值。 单目：单目运算符+ –(负数) ++ – 等乘除：算数单目运算符* / % + -为：位移单目运算符&lt;&lt; &gt;&gt;关系：关系单目运算符&gt; &lt; &gt;= &lt;= == !=逻辑：逻辑单目运算符&amp;&amp; || &amp; | ^三目：三目单目运算符A &gt; B ? X : Y后：无意义，仅仅为了凑字数赋值：赋值= 控制台输入 导包 创建对象 对象调用方法 123456import java.util.Scanner;Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入：&quot;);String str =sc.next();int num1 = sc.nextInt();double num2 = sc.nextDouble(); 流程控制语句条件语句 表达式的结果是一个布尔值，如果是true，直接进入if的方法体中，如果结果为false，则跳过if的方法体，继续执行。 单分支if 格式 ：&emsp;if（表达式）{方法体}注意： 方法体的默认语句只有一条的时候，可以省略{ } 双分支if - else 需要对条件成立和不成立的情况分别处理格式 ：&emsp;if（表达式）{方法体} else {方法体}注意： 方法体的默认语句只有一条的时候，可以省略{ } 多重if选择结构 格式 ：&emsp;if（表达式）{方法体} else if（表达式）{方法体}…else{方法体} 注意： else{}可以省略，表示条件都不成立的情况 当条件成立的时候，后面else if 代码不执行 判断字符串类型的值是否相等 equals(String str)：&emsp;英文时，区分大小写 123if（&quot;张三&quot;.equals(str)）&#123; System.out.print(&quot;姓名是：&quot;+&quot;张三&quot;);&#125; == 判断内存地址 分支语句switch 1234567891011121314151617181920//匹配 就是全等。语法： switch(表达式)&#123; case 值1: 表达式的值和 值1匹配上了，需要执行的代码; break; case 值2: 表达式的值和 值2匹配上了，需要执行的代码; break; case 值3: 表达式的值和 值3匹配上了，需要执行的代码; break; default: 如果表达式的值和以上的case后面的值都没有匹配上，那么就执行这里的代码。 break; &#125;* //不写break会穿透到下一个break* //default的位置可以任意，没有break，照样穿透执行。 swtich()变量类型只能是int、short、char、byte和enum类型,String(jdk1.7）。 当进行case判断时，JVM会自动从上到小扫描，寻找匹配的case， 标签不能相同 可以使用标签堆叠 只能进行等值的判断 default标签可以省略 嵌套if选择结构123456789if(条件) &#123; if(条件) &#123; 代码块一； &#125;else &#123; 代码块二； &#125;&#125;else &#123; 代码块三；&#125; 多重if 和switch 的区别 switch只能等值判断 对于等值问题的判断，switch效率高 if能够进行范围的判断 循环语句 解决重复的问题 固定次数while结题方式： 1. 初始值 2. 终止值 3. 迭代次数 1234int i=0;while(i&lt;100)&#123; System.out.println(&quot;第&quot;+ (++i) +&quot;遍好好学习&quot;+&quot;&quot;);&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>运算符优先级</tag>
        <tag>控制台输入</tag>
        <tag>流程控制语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date FateFormat类]]></title>
    <url>%2Fblog%2F2018%2F07%2F30%2F%E5%B8%B8%E7%94%A8%E7%B1%BBDate_DateFormat%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Date 类概述 Date:表示特定的瞬间，精确到毫秒。 构造方法构造方法： Date():根据当前的默认毫秒值创建日期对象 Date(long date)：根据给定的毫秒值创建日期对象123456789// 创建对象Date d = new Date();System.out.println(&quot;d:&quot; + d); //d:Mon Jul 30 16:21:01 CST 2018// 创建对象// long time = System.currentTimeMillis();long time = 1000 * 60 * 60; // 1小时Date d2 = new Date(time);System.out.println(&quot;d2:&quot; + d2); //d2:Thu Jan 01 08:00:00 CST 1970 日期类的时间从为什么是从1970年1月1日最初计算机操作系统是32位，而时间也是用32位表示。System.out.println(Integer.MAX_VALUE);2147483647Integer在JAVA内用32位表 示，因此32位能表示的最大值是2147483647。另外1年365天的总秒数是31536000，2147483647/31536000 = 68.1也就是说32位能表示的最长时间是68年，而实际上到2038年01月19日03时14分07秒，便会到达最大时间，过了这个时间点，所有32位操作系统时间便会变为10000000 00000000 00000000 00000000也就是1901年12月13日20时45分52秒，这样便会出现时间回归的现象，很多软件便会运行异常了。 成员方法 public long getTime():获取时间，以毫秒为单位 public void setTime(long time):设置时间 代码测试1234567891011// 创建对象Date d = new Date();// 获取时间long time = d.getTime(); System.out.println(time); //1532939861629// System.out.println(System.currentTimeMillis()); //1532939861630System.out.println(&quot;d:&quot; + d); //d:Mon Jul 30 16:37:41 CST 2018// 设置时间d.setTime(1000);System.out.println(&quot;d:&quot; + d); d:Thu Jan 01 08:00:01 CST 1970 DateFormat 类概述 DateFormat针对日期进行格式化和针对字符串进行解析的类，因为是抽象类，所以使用其子类SimpleDateFormat Date – String(格式化)public final String format(Date date) String – Date(解析)public Date parse(String source) SimpleDateFormat的构造方法： SimpleDateFormat():默认模式 SimpleDateFormat(String pattern):给定的模式构造 12345678这个模式字符串该如何写呢? * 通过查看API，我们就找到了对应的模式 * 年 y * 月 M * 日 d * 时 H * 分 m * 秒 s 格式化 Date – String123456789// 创建日期对象Date d = new Date();// 创建格式化对象// SimpleDateFormat sdf = new SimpleDateFormat(); //18-7-30 下午5:09(默认格式)// 给定模式SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);// public final String format(Date date)String s = sdf.format(d);System.out.println(s); //2018年07月30日 17:07:17 解释 String – Date12345String str = &quot;2008-08-08 12:12:12&quot;;//在把一个字符串解析为日期的时候，请注意格式必须和给定的字符串格式匹配SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);Date dd = sdf2.parse(str);System.out.println(dd); //Fri Aug 08 12:12:12 CST 2008 小案例：算一下你来到这个世界多少天?1234567891011121314151617181920212223public static void main(String[] args) throws ParseException &#123; // 键盘录入你的出生的年月日 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入你的出生年月日(如：1970-01-01):&quot;); String line = sc.nextLine(); // 把该字符串转换为一个日期 Date date = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).parse(line); // 通过该日期得到一个毫秒值 long d = date.getTime(); // 获取当前时间的毫秒值 long c = new Date().getTime(); // 用c-d得到一个毫秒值 long e = c - d; // 把E的毫秒值转换为年 long day = e / 1000 / 60 / 60 / 24; System.out.println(&quot;你来到这个世界：&quot; + day + &quot;天&quot;);&#125; Calendar类: 它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 成员方法 public int get(int field):返回给定日历字段的值。日历类中的每个日历字段都是静态的成员变量，并且是int类型。 12345678910111213//获取年public static void main(String[] args) &#123; // 其日历字段已由当前日期和时间初始化： Calendar rightNow = Calendar.getInstance(); // 子类对象 // 获取年 int year = rightNow.get(Calendar.YEAR); // 获取月 int month = rightNow.get(Calendar.MONTH); // 获取日 int date = rightNow.get(Calendar.DATE); System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;); &#125; public void add(int field,int amount):根据给定的日历字段和对应的时间，来对当前的日历进行操作。123456789101112131415public static void main(String[] args) &#123; // 获取当前的日历时间 Calendar c = Calendar.getInstance(); // 5年后的10天前 c.add(Calendar.YEAR, 5); c.add(Calendar.DATE, -10); // 获取年 year = c.get(Calendar.YEAR); // 获取月 month = c.get(Calendar.MONTH); // 获取日 date = c.get(Calendar.DATE); System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;); public final void set(int year,int month,int date):设置当前日历的年月日 月份从0开始 123456789Calendar c = Calendar.getInstance();c.set(1314,05,20);// 获取年year = c.get(Calendar.YEAR);// 获取月month = c.get(Calendar.MONTH);// 获取日date = c.get(Calendar.DATE);System.out.println(year + &quot;年&quot; + (month + 1) + &quot;月&quot; + date + &quot;日&quot;); //1314年6月20日 案例获取任意一年的二月有多少天123456789101112131415161718192021222324分析： * A:键盘录入任意的年份 * B:设置日历对象的年月日 * 年就是A输入的数据 * 月是2 * 日是1 * C:把时间往前推一天，就是2月的最后一天 * D:获取这一天输出即可public static void main(String[] args) &#123; // 键盘录入任意的年份 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入年份：&quot;); int year = sc.nextInt(); // 设置日历对象的年月日 Calendar c = Calendar.getInstance(); c.set(year, 2, 1); // 其实是这一年的3月1日 // 把时间往前推一天，就是2月的最后一天 c.add(Calendar.DATE, -1); // 获取这一天输出即可 System.out.println(c.get(Calendar.DATE));&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Date</tag>
        <tag>FateFormat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础第二天]]></title>
    <url>%2Fblog%2F2018%2F07%2F30%2FJava%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[存储数据–变量变量 变量就是一个存储空间， 空间的数据是可变的。 声明变量： 数据类型 变量名（，变量名，变量名）； int age; 初始化：变量名 = 值； （开辟空间，赋初值） age=22; 边声明，变赋值 int age = 22; 变量名命名规则标识符命名规则 由字母，数字，下划线_,美元符号$组成。 不能以数字开头； 不能是java的关键字； 不能是字面值 ture false null 字母可以看成所有国家书面上使用的，中文也可以看成字母。（不推荐） 关键字保留字:没有特殊含义（goto ,const） 关键字如图 java 数据数据类型基本数据类型 类型 内存（字节）大小 默认值 取值范围 byte 1 0 -128 - 127&emsp;（-2^7)~（2^7-1） short 2 0 -32768（-2^15）~32767（2^15 - 1） int 4 0 -2,147,483,648（-2^31）~2,147,483,647（2^31-1） long 8 0 -9,223,372,036,854,775,808&emsp;~&emsp;9,223,372,036,854,775,807&emsp;（-2^63）~（2^63 -1） float 4 0.0f float f1 = 234.5f double 8 0.0d double d1 = 123.4 char 2 单一的16位Unicode字符 \u0000~\uffff(0~65535) boolean 1 false true/false 测试整数 int a =20;数据可以用下划线分隔 增强可读性int n5=0b1011_1111_0000 //2进制 ：0b开头int n6=01 //8进制：0开头int 0x101f //16进制：0x开头 小数 小数字面值 当做 double 来处理double n1=11.1d;float n2 = 22.2f;double n3 = 2e2; //200.0 十六进制 ：p以2为底 (e表示14)double n1 = 0x1ap2;&emsp;//0x1a * 2^2=0x1a * 4=26 * 4=104ni = 6.0e20 + 1;&amp;emsp; //6.0E20,所以结果是不精确的 小数的精确运算1.导包：import java.math.BigDecimal; 12345BigDecimal n2 = new BigDecimal(&quot;0.1&quot;);BigDecimal n3 = new BigDecimal(&quot;0.2&quot;);BigDecimal addresult = n2.add(n3);double result = addresult.doubleValue();System.out.println(result); //0.3 字符（char) 计算机将字符是整数形式存储编码表 ASCII ISO-8859-1 Windows-1252 GBK2312（97%左右） GBK(所有的,包含繁体） GBk18030(所有的,包含繁体,少数民族） Big(台湾香港繁体字) Unicode编码(全世界统一，范围：0-65535) UTF32（4字节，浪费空间） UTF-16(双字节) UTF-8（变长的，1,2,3字节）123456String s = &quot;Hello你好&quot;;byte[] b = s.getBytes(&quot;GBK&quot;); // 以GBK编码存储String s1 = new String (b,&quot;GBK&quot;);// 以GBK编码解码String s2 = new String (b,&quot;utf-8&quot;);// 以Utf-8解码System.out.println(s1); //Hello你好System.out.println(s2); // Hello??? boolean 类型 字面值： true false 引用类型java有 5种引用类型（对象类型）： 类 接口 数组 枚举 标注 引用类型：底层结构和基本类型差别较大 JVM的内存空间：（1）. Heap 堆空间：分配对象 new Student（） （2）. Stack 栈空间：临时变量 Student stu （3）.Code 代码区 ：类的定义，静态资源 Student.class 123456eg：Student stu = new Student（）； //new 在内存的堆空间创建对象stu.study(); //把对象的地址赋给stu引用变量上例实现步骤： a.JVM加载Student.class 到Code区 b.new Student()在堆空间分配空间并创建一个Student实例 c.将此实例的地址赋值给引用stu， 栈空间 字符串 用双引号引起来。 字符串的连接:用“+”号连接12String name=&quot;张三&quot;;System.out.println(&quot;姓名是：&quot;+name); //姓名是：张三 类型转换赋值的类型 和 声明的类型不一样 自动类型转换 由 低 （范围小的） 赋值给 高 （范围大的）整形默认 int小数默认 double byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double char –&gt; int –&gt; long –&gt; float –&gt; double 12345678910byte a = 2;short b = a;System.out.println(b); //2// b=ch+1; //char - short 不能转换//char类型参与运算 char ch = &apos;a&apos;; int d = ch + 1; System.out.println(d);//a:97 结果98 强制类型转换 由 高 （范围大的）赋值给 低 （范围小的）(强转数据类型)（转换数据） 类型提升 只有参与运算的时候才有类型提升类型低的提成到类型高的进行运算运算结果采取 类型级别最高的类型作为结果类型 运算符 根据操作数个数分类： 一元 &emsp;//a++ 二元 &emsp;//a + b 三元 &emsp;//a&gt;b?a:b 算法运算符 + &emsp;&emsp;加法 当+号左右有字符串的时候，+ 为字符串的连接符 - &emsp;&emsp;减法 * &emsp;&emsp;乘法 / &emsp;&emsp;除法 除数和被除数都是整数 ，结果为整数 除数为0,时，触发java.lang.ArithmeticException: / by zero 除数/被除数 为小数 的时候，结果为double类型 123System.out.println(5/2.0); //2.5System.out.println(5.0/2); //2.5System.out.println(5.0/2.0); //2.5 浮点运算特殊值 1234567System.out.println(0/0.0); //NaNSystem.out.println(5/0.0); //InfinitySystem.out.println(-5/0.0); //-InfinitySystem.out.println(0.0/0); //NaNSystem.out.println(5.0/0); //InfinitySystem.out.println(-5.0/0); //-Infinity 取余 123456789System.out.println(5%0); //java.lang.ArithmeticException: / by zeroSystem.out.println(5%2); //1System.out.println(5%-2); //1System.out.println(-5%2); //-1System.out.println(5%0.0); //NaNSystem.out.println(5%2.0); //1.0System.out.println(-5%2.0); //-1.0System.out.println(0.0%5); //0.0System.out.println(-0.0%5); //-0.0 自增自减运算符1234567前自增和后自增、前自减和后自减的区别。自增（++）：将变量的值加1，分前缀式（如++i）和后缀式（如i++）。 前缀式是先加1再使用； 后缀式是先使用再加1。自减（--）：将变量的值减1，分前缀式（如--i）和后缀式（如i--）。 前缀式是先减1再使用； 后缀式是先使用再减1。 j = i+++ i++123456789101112131415public static void main(String [] args)&#123; int i = 0; int j = i++ + i++; //这条语句等价于j = (i++) + (i++) System.out.println(&quot;输出i的结果为&quot;+i); System.out.println(&quot;输出j的结果为&quot;+j); &#125;&#125;分析第一个（i++），假定 n=i++; temp = n; i = i+1; n = temp;所以第一个（i++）==0；第二个：因为是前缀式：(此时的i = 1) 所以最后的j = 1；i自增了两次，所以 i = 2； 关系运算符 &emsp;> &emsp;&lt; &emsp;&gt;=&emsp; &lt;=&emsp; == &emsp;!=运算结果是boolean类型 逻辑运算符 &amp;&amp; &emsp;|| &emsp; ! &amp;&amp; 一假为假 全真为真 左边为假，后边不执行 || 一真为true 全假为false 左边为真，后边不执行 ！ 真变假，假变真 非短路逻辑运算符 &amp; | ！ 不管左边为真为假，后面都要执行还可以进行位运算 赋值运算符= 先算右边，然后将值给左边 扩展赋值 += &emsp;-=&emsp;*=&emsp;/=类型级别低 ，会自动强转处理 12345short n3 =5; n3 = n3 + 5; //会报错 short = int n3 += 5; //不会报错，自动强转 n3=(short)(n3+5); 条件运算符格式：表达式一 ？表达式二 : 表达式三； true —&gt; 表达式二 false —&gt; 表达式三 表达式一的结果 必须为boolean类型 结果必须接收或输出打印。 位运算符 &amp; 与 有一个为0，结果为0 二个都为1，结果为1 | 或 有一个为1，结果为1 二个为0， 结果为0 ^ 异或 相同为0， 不同为1 一个数异或二次，结果不变 ~ 取反 1 — 0 0 — 1 ~a = -a -1 &emsp;~5&emsp;— &emsp;-6 &lt;&lt; 左移 向左移动 几位，右边底位用0补位 结果 * 2的 几位 次幂 >> 右移 向右移动 几位， 左边高位，是什么用什么补位 结果 / 2的 几位 次幂 >&gt;&gt; 无符号右移 向右移动 几位， 左边高位用0补位 123456789101112int a=3;System.out.println(a&lt;&lt;2); //3*4=12System.out.println(a&gt;&gt;1); //3/2=1System.out.println(5&gt;&gt;&gt;2); //5/4=1int a1=-4;System.out.println(a1&lt;&lt;2); //-4*4=-16System.out.println(a1&gt;&gt;1); //-4/2=-2System.out.println(a1&gt;&gt;&gt;28); //15 11111111 11111111 11111111 11111100&gt;&gt;&gt;28 00000000 00000000 00000000 00001111 ------------------------------------]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>变量</tag>
        <tag>数据类型</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Character类]]></title>
    <url>%2Fblog%2F2018%2F07%2F29%2F%E5%B8%B8%E7%94%A8%E7%B1%BBCharacter%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Character类概述 Character 类在对象中包装一个基本类型 char 的值此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然 构造方法public Character(char value) 123456public static void main(String[] args) &#123; // 创建对象 // Character ch = new Character((char) 97); Character ch = new Character(&apos;a&apos;); System.out.println(&quot;ch:&quot; + ch);&#125; 成员方法 A:判断给定的字符是否是大写 &emsp;&emsp;public static boolean isUpperCase(char ch) B:判断给定的字符是否是小写&emsp;&emsp;public static boolean isLowerCase(char ch) C:判断给定的字符是否是数字字符&emsp;&emsp; public static boolean isDigit(char ch) D:把给定的字符转成大写&emsp;&emsp;public static char toUpperCase(char ch) E:把给定的字符转成小写&emsp;&emsp;public static char toLowerCase(char ch) 代码测试12345678910111213141516171819202122232425262728293031323334353637383940414243public static void main(String[] args) &#123; // public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符 System.out.println(&quot;isUpperCase:&quot; + Character.isUpperCase(&apos;A&apos;)); System.out.println(&quot;isUpperCase:&quot; + Character.isUpperCase(&apos;a&apos;)); System.out.println(&quot;isUpperCase:&quot; + Character.isUpperCase(&apos;0&apos;)); System.out.println(&quot;-----------------------------------------&quot;); // public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符 System.out.println(&quot;isLowerCase:&quot; + Character.isLowerCase(&apos;A&apos;)); System.out.println(&quot;isLowerCase:&quot; + Character.isLowerCase(&apos;a&apos;)); System.out.println(&quot;isLowerCase:&quot; + Character.isLowerCase(&apos;0&apos;)); System.out.println(&quot;-----------------------------------------&quot;); // public static boolean isDigit(char ch):判断给定的字符是否是数字字符 System.out.println(&quot;isDigit:&quot; + Character.isDigit(&apos;A&apos;)); System.out.println(&quot;isDigit:&quot; + Character.isDigit(&apos;a&apos;)); System.out.println(&quot;isDigit:&quot; + Character.isDigit(&apos;0&apos;)); System.out.println(&quot;-----------------------------------------&quot;); // public static char toUpperCase(char ch):把给定的字符转换为大写字符 System.out.println(&quot;toUpperCase:&quot; + Character.toUpperCase(&apos;A&apos;)); System.out.println(&quot;toUpperCase:&quot; + Character.toUpperCase(&apos;a&apos;)); System.out.println(&quot;-----------------------------------------&quot;); // public static char toLowerCase(char ch):把给定的字符转换为小写字符 System.out.println(&quot;toLowerCase:&quot; + Character.toLowerCase(&apos;A&apos;)); System.out.println(&quot;toLowerCase:&quot; + Character.toLowerCase(&apos;a&apos;)); &#125;结果：isUpperCase:trueisUpperCase:falseisUpperCase:false-----------------------------------------isLowerCase:falseisLowerCase:trueisLowerCase:false-----------------------------------------isDigit:falseisDigit:falseisDigit:true-----------------------------------------toUpperCase:AtoUpperCase:A-----------------------------------------toLowerCase:atoLowerCase:a 练习:字符出现的次数 统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数。(不考虑其他字符) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* *分析： * A:定义三个统计变量。 * int bigCont=0; * int smalCount=0; * int numberCount=0; * B:键盘录入一个字符串。 * C:把字符串转换为字符数组。 * D:遍历字符数组获取到每一个字符 * E:判断该字符是 * 大写 bigCount++; * 小写 smalCount++; * 数字 numberCount++; * F:输出结果即可 */public class CharacterTest &#123; public static void main(String[] args) &#123; // 定义三个统计变量。 int bigCount = 0; int smallCount = 0; int numberCount = 0; // 键盘录入一个字符串。 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个字符串：&quot;); String line = sc.nextLine(); // 把字符串转换为字符数组。 char[] chs = line.toCharArray(); // 历字符数组获取到每一个字符 for (int x = 0; x &lt; chs.length; x++) &#123; char ch = chs[x]; // 判断该字符 if (Character.isUpperCase(ch)) &#123; bigCount++; &#125; else if (Character.isLowerCase(ch)) &#123; smallCount++; &#125; else if (Character.isDigit(ch)) &#123; numberCount++; &#125; &#125; // 输出结果即可 System.out.println(&quot;大写字母：&quot; + bigCount + &quot;个&quot;); System.out.println(&quot;小写字母：&quot; + smallCount + &quot;个&quot;); System.out.println(&quot;数字字符：&quot; + numberCount + &quot;个&quot;); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>包装类</tag>
        <tag>Character</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer类]]></title>
    <url>%2Fblog%2F2018%2F07%2F29%2F%E5%B8%B8%E7%94%A8%E7%B1%BBInteger%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[包装类 为了对基本书类型进行更多的操作，Java针对每一种数据类型提供对应的类类型—包装类类型 IntegerInteger查看数据类型的范围 最大值：public static final int MAX_VALUE; 最小值：public static final int MIN_VALUE; Integer构造函数 public Integer(int value) public Integer(String s) 注意：这个字符串必须是由数字字符组成 1234567891011// 方式1int i = 100;Integer ii = new Integer(i);System.out.println(&quot;ii:&quot; + ii); //ii:100// 方式2String s = &quot;100&quot;;// NumberFormatException// String s = &quot;abc&quot;;Integer iii = new Integer(s);System.out.println(&quot;iii:&quot; + iii); //iii:100 int类型和String类型的相互转换 int —&gt; String &quot;&quot; + int number String.valueof(int number) int ---&gt; Integer -----&gt; String 12Integer i = new Integer(int number);String str1 = i.toString(); public static String toString(); 1Integer.toString(int number) String —-&gt; int String ---&gt; Integer ---&gt;int 12Integer ii = new Integer(str);int x = ii.intValue(); public static int parseInt(String s) Integer.parseInt(String s); Integer进制转换 10进制转为2进制 public static String toBinaryString(int i); 10进制转8进制 public static String toOctalString(int i); 10进制转16进制 public static String toHexString(int i); 十进制到其他进制(范围：2-36，因为表示的数有0-9,a-z共36个) public static String toString(int i,int radix); 其他进制到十进制 public static int parseInt(String s,int radix); 12345System.out.println(Integer.parseInt(&quot;100&quot;, 10)); //100System.out.println(Integer.parseInt(&quot;100&quot;, 2)); //4System.out.println(Integer.parseInt(&quot;100&quot;, 8)); //64System.out.println(Integer.parseInt(&quot;100&quot;, 16)); //256System.out.println(Integer.parseInt(&quot;100&quot;, 23)); //529 JDK5的新特性 自动装箱： 把基本类型转换为包装类类型 自动拆箱： 把包装类类型转换为基本类型 1234567891011121314151617//定义一个int类型的包装类类型变量iiInteger ii = new Integer(100); // Integer ii=100;ii+=200;//实际上面代码：Integer ii = new Integer(100);ii=Integer.valueof(ii.intValue() + 200); //自动拆箱后，再自动装箱使用注意的问题： Integer i = null; 代码会报NullPointExpection Integer iii = null; // NullPointerException if (iii != null) &#123; iii += 1000; System.out.println(iii); &#125; 缓冲池 Integer的数据直接赋值，如果在-128到127之间，会直接从缓冲池里获取数据 练习12345678910111213141516171819202122 Integer i1 = new Integer(127);Integer i2 = new Integer(127); System.out.println(i1 == i2); //falseSystem.out.println(i1.equals(i2)); //trueSystem.out.println(&quot;-----------&quot;);Integer i3 = new Integer(128);Integer i4 = new Integer(128);System.out.println(i3 == i4); //falseSystem.out.println(i3.equals(i4)); //trueSystem.out.println(&quot;-----------&quot;);Integer i5 = 128;Integer i6 = 128;System.out.println(i5 == i6); //false &lt;-- 数据缓存池范围：-128 - 127System.out.println(i5.equals(i6)); //trueSystem.out.println(&quot;-----------&quot;);Integer i7 = 127;Integer i8 = 127;System.out.println(i7 == i8); //trueSystem.out.println(i7.equals(i8)); //true 总结Integer 类的成员方法 public int intValue() //把Integer类型转化为Int类型 public static int parseInt(String s) //把String类型转化为Int类型 public static int parseInt(String s ,int radix) //把String类型转化为radix进制 public static String toString(int i) //把Int类型转化为String类型 public static Integer toString(int i ,int radix) 10进制转为radix进制 public static Integer valueOf(String s) //把String参数给的值，转化为Integer类型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>包装类</tag>
        <tag>Integer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaEE目录]]></title>
    <url>%2Fblog%2F2018%2F07%2F28%2FjavaEE%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录 mysql mysql数据库创建,修改,删除 实体完整性，引用完整性，dml，修改和删除，查询，单行函数，聚合函数和分组函数，加密函数 高级查询，事务，存储过程，触发器 视图，索引，数据库设计优化，备份与还原，JBDBC JDBC开发 前端技术 HTML CSS JavaScript 嗯..! 目前共计 8 篇。 继续努力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[javaSE目录]]></title>
    <url>%2Fblog%2F2018%2F07%2F28%2FjavaSE%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录 java基础 java语言的特点、JDK、JRE、转义序列、进制转换、注释 变量、数据类型、运算符 运算符的优先级、控制台输入Scanner、if、switch、while do-while、for循环、小数的格式化、break、continue、数组 数组、二维数组、类和对象 方法、this、方法参数的传递、递归 封装、方法重载、构造方法、成员变量的初始化、构造器和访问器、static、访问权限修饰符 静态方法、代码块、静态导入、单例模式、Math、Random、继承、Object final、继承、抽象类、接口、多态 UML、类与类关系、String、StringBuffer 正则表达式、自动拆装箱、Date处理、内部类 lanbda表达式、方法引用、异常——–以上为基础部分——– javaSE高级 泛型、比较器、枚举 Map集合、Set集合 Collections工具类，Queue、Deque接口、Map集合、Stream流、拦截器Predicate) File类、字节流 缓冲流,字符流,多线程,同步 lock,类加载 , 反射 注解 , 网络Socket编程 嗯..! 目前共计 19 篇。 继续努力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[目录]]></title>
    <url>%2Fblog%2F2018%2F07%2F28%2F%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录 javaSE javaEE 我的自学 嗯..! 目前共计 3 篇。 继续努力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[自学目录]]></title>
    <url>%2Fblog%2F2018%2F07%2F28%2F%E8%87%AA%E5%AD%A6%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[目录 javase Integer类 Character类 Date FateFormat类 对象数组 集合 List接口 List集合练习 泛型 JDK5的新特性 Set接口 Map接口 Map子类 Map集合练习 Collections工具类 Lanbda表达式 javaee Mysql数据库的安装 Mysql的基本操作 mysql的数据约束 Mysql数据库设计 嗯..! 目前共计 19 篇。 继续努力。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础第一天]]></title>
    <url>%2Fblog%2F2018%2F07%2F27%2FJava%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[计算机程序：为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合 计算机语言 机器语言 0，1 汇编语言 pop ,end 底层的语言 高级语言 英文，数学表达式 Java的三大平台 javaSE javaEE JavaME java 的发展史1996年，sun发布了JDK1.02009年 ，甲骨文收购了Sun 高级语言分类 编译型： 源代码–(编译器)—-&gt; 机器码（针对特定的操作系统和CPU） 速度快, 解释型 源代码–(解释器)—-&gt; 解释执行 慢，跨平台 Java语言编译解释型语言： 源代码–(编译器)–&gt;字节码文件–(解释器)–&gt;机器码比解释型快，还能跨平台 Java 语言的特点 可移植性 与平台无关的特性使Java程序可以方便地移植到网络上。（JVM不是跨平台的。） 垃圾回收 内存管理：自动回收 通常是内存满了才回收 Java环境安装 JDK Java开发工具包 包含：开发工具 + JRE + 类库 JRE Java运行环境 JVM(java虚拟机) + 类库 环境配置 目的： 在任何路径下都能识别java, javac命令 path 环境变量 %JAVA_HOME%\bin; JAVA_HOME 环境变量 目的：JDK的安装路径频繁更改 D:\Java\jdk1.8.0_144 classpath 环境变量 目的：在任何路径下都能找到.class文件 解释运行 字节码文件的路径 临时配置 set 永久配置： 我的电脑 –&gt; 环境配置 Dos命令（Disk Operating System：磁盘操作系统）打开dos窗口：Win+R ,输入CMD。 列表项 help &nbsp;&nbsp;帮助 d: &nbsp;&nbsp;切换盘符 dir/dir 路径 &nbsp;&nbsp;显示文件目录清单 /s &nbsp;&nbsp;查看目录的文件和子目录 /p &nbsp;&nbsp;分屏显示 dir /s/p &nbsp;&nbsp;分屏显示所有 cd &nbsp;&nbsp;改变目录 cd .. &nbsp;&nbsp;返回上一级 cd \ &nbsp;&nbsp;返回根目录 md 目录名 &nbsp;&nbsp;创建目录/创建文件夹 copy con 文件名.扩展名 创建文件 输入内容 &nbsp;&nbsp;CTRL + Z 结束 type 文件名.扩展名 &nbsp;&nbsp; 显示文件名 copy 文件名.扩展名 目标路径 &nbsp;&nbsp;复制文件 ren 原文件名 新文件名 &nbsp;&nbsp;重命名 move 原文件名 目标路径&nbsp;&nbsp;*移动（剪切）* rd 目录名 &nbsp;&nbsp;删除空的目录 /S 除目录本身外，还将删除指定目录下的所有子目录和文件。用于删除目录树。 /Q 安静模式，带 /S 删除目录树时不要求确认 del 文件.扩展名&nbsp;&nbsp;删除文件 cls &nbsp;&nbsp;清屏 exit &nbsp;&nbsp;退出 编写第一个程序123456789101112131415161718192021public class Hello&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World！&quot;); &#125;&#125;运行：在Dos窗口下，cd 到JDk的安装路径下\bin目录 1.javac Hello.java --&gt;生成Hello.class 2.java Hello（类加载只能识别类名，不能带扩展名） --&gt;控制台输出Hello World! 出现的问题： 找不到或无法加载主类Hello: java -classpath d:\data Hello （Hello.class的路径） 注意： 1.java区分大小写 2.符号 英文半角 3.（）[] &#123;&#125; 成对出现 4. 语句结束用分号； 5.每行写一句代码，代码有缩进。 java 运行步骤1234567st=&gt;start: Startop=&gt;operation: javac 编译器op2=&gt;operation: 字节码文件 .classop1=&gt;operation: java 解释器e=&gt;end: 运行st-&gt;op-&gt;op2-&gt;op1-&gt;e JVM工作原理 第一个程序解释控制台上的打印输出System.out.println(&quot;字符串&quot;)；输出后换行System.out.print(&quot;字符串&quot;)；输出后不换行 打印出现问题 System.out.println(&quot;c:\a.txt&quot;);的结果？ 编译报错；———- javac ———-Hello.java:3: 错误: 非法转义符 System.out.println(&quot;c:\a.txt&quot;); 转义序列a:用97表示， 八进制转义:\000 - \7777 System.out.println(&quot;\141&quot;) //a 十六进制转义:\u0000 - \uffff System.out.println(&quot;\u0061&quot;) //a 转义字符 \\&nbsp;&nbsp;\ \\*&amp;nbsp;&amp;nbsp; * \&apos;&amp;nbsp;&amp;nbsp; &apos; \t 一个水平制表符 \n 换行 进制 二进制：以0b开头。（b大小写都行） 八进制：0开头 0~7 十六进制：0x开头 0~9 a~f 其他进制到十进制(位权展开求和) 系数：每一位的数据 基数：x进制，基数就是几 权：从右往左，从0开始编号，对应位置的编号即为该位的权 结果：系数*基数的权次幂之和 十进制到其他进制 除基取余，直到商为0，余数反转 有符号数据表示： 原码：二进制定点表示法,最高位为符号位，0为正，1为负，其余位数表示数值的大小 反码：正数的反码与原码相同，负数的反码：符号位不变，其余按位取反 补码：正数的补码与原码相同；负数:反码加1; 123456789101112131415165的二进制表示： 00000000 00000000 00000000 00000101-5的二进制表示：5的二进制取反+1 00000000 00000000 00000000 00000101取反： 11111111 11111111 11111111 11111010 +1 ： 00000000 00000000 00000000 00000001 --------------------------------------------- 11111111 11111111 11111111 11111011 -5的变5的二进制：-5的二进制-1后取反（结果和-5求补码一样） 11111111 11111111 11111111 11111011 -1 ： 00000000 00000000 00000000 00000001 --------------------------------------------- 11111111 11111111 11111111 11111010取反： 00000000 00000000 00000000 00000101 二进制到八进制从右到左，3为一取，得到对应的8进制数。 123001111001 111 ---&gt; 1 70b00111 ---&gt; 017 二进制到16进制从右到左，4为一取，得到对应的16进制数。 1230011110000 1111 ---&gt; 0 f0b001111 ---&gt; 0x0f 注释 单行注释：// 多行注释:/* 内容 */ 多行注释不能相互嵌套 文档注释： javadoc , 识别注释后会生成一个帮助文档 使用时间：声明类 类中的成员，接口等 生成帮助文档命令： 不识别作者，版本：javadoc -d 输出的文件夹 类.class javadoc -d doc Hello.java 识别作者，版本号：javadoc -d 存储的文件夹 -author -version 类.class javadoc -d doc -author -version Hello.java 了解的选项： -public 访问权限是public -protected 访问权限是public和protected -package 访问权限是public、protected和默认 -private 访问权限是public、protected、默认 private 常见的javadoc标记 @author 指定作者 @version 版本号和时间 @param 描述方法的参数 @return 描述方法的返回值 @throws 描述方法抛出的异常 @see 生成参考其他javaDoc文档的链接 @see 类名#方法（）； 使用注释的地方？ 1. 修改的代码 2. 表达不明确的地方 3. 算法 4. 分支语句，循环语句 5. 声明类，接口 总结]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>进制</tag>
        <tag>Java环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo中遇到的坑]]></title>
    <url>%2Fblog%2F2018%2F06%2F01%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo搭建过程中遇到的问题 在使用hexo g生成文章的时候，报错如下: Template render error: (unknown path) [Line 31, Column 21]expected variable end 问题原因: 当文章中有}}时,且这两个括号未被代码块包含，解析会出问题 flow图的语法: tag=&gt;type: content:&gt;url 类型 start end operation subroutine condition inputoutput 连接连接元素阶段的语法就简单多了，直接用-&gt;来连接两个元素，需要注意的是condition类型，因为他有yes和no两个分支，所以要写成 c2(yes)-&gt;io-&gt;e c2(no)-&gt;op2-&gt;e 123456789101112131415st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yes or No?|approved:&gt;http://www.baidu.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e 123456789101112131415st=&gt;start: Start|past:&gt;http://www.google.com[blank]e=&gt;end: End:&gt;http://www.google.comop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yes or No?|approved:&gt;http://www.baidu.comc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个python程序]]></title>
    <url>%2Fblog%2F2018%2F01%2F21%2F%E7%AC%AC%E4%B8%80%E4%B8%AApython%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[第一个python程序 Python的哲学就是简单优雅，尽量写容易看明白的代码，尽量写少的代码. Python是跨平台的 Python有两个版本，一个是2.x版，一个是3.x版，这两个版本是不兼容的。 Python的缺点: pyt’hon是解释型的语言，和C语言相比非常慢 代码不能加密。如果要发布你的Python程序，实际上就是发布源代码。 Python解释器​ 编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。 CPython当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。 小结Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。 第一个Python程序命令行模式在Windows开始菜单选择“命令提示符”，就进入到命令行模式，它的提示符类似C:\&gt;： 123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - □ x │├────────────────────────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:\&gt; _ ││ ││ ││ ││ ││ ││ ││ │└────────────────────────────────────────────────────────┘ Python交互模式在命令行模式下敲命令python，就看到类似如下的一堆文本输出，然后就进入到Python交互模式，它的提示符是&gt;&gt;&gt;。 123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - python - □ x │├────────────────────────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:\&gt; python ││Python 3.7 ... on win32 ││Type &quot;help&quot;, ... for more information. ││&gt;&gt;&gt; _ ││ ││ ││ ││ │└────────────────────────────────────────────────────────┘ 在Python交互模式下输入exit()并回车，就退出了Python交互模式，并回到命令行模式： 123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - □ x │├────────────────────────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:\&gt; python ││Python 3.7 ... on win32 ││Type &quot;help&quot;, ... for more information. ││&gt;&gt;&gt; exit() ││ ││C:\&gt; _ ││ ││ │└────────────────────────────────────────────────────────┘ 也可以直接通过开始菜单选择Python (command line)菜单项，直接进入Python交互模式，但是输入exit()后窗口会直接关闭，不会回到命令行模式。 在交互模式的提示符&gt;&gt;&gt;下，直接输入代码，按回车，就可以立刻得到代码执行结果。现在，试试输入100+200，看看计算结果是不是300： 12&gt;&gt;&gt; 100+200300 很简单吧，任何有效的数学计算都可以算出来。 如果要让Python打印出指定的文字，可以用print()函数，然后把希望打印的文字用单引号或者双引号括起来，但不能混用单引号和双引号： 12&gt;&gt;&gt; print(&apos;hello, world&apos;)hello, world 这种用单引号或者双引号括起来的文本在程序中叫字符串，今后我们还会经常遇到。 在命令行模式下，可以执行python进入Python交互式环境，也可以执行python hello.py运行一个.py文件。 执行一个.py文件只能在命令行模式执行。 在命令行模式运行.py文件和在Python交互式环境下直接运行Python代码有所不同。 Python交互式环境会把每一行Python代码的结果自动打印出来 直接运行Python代码却不会。 例如，在Python交互式环境下，输入： 12&gt;&gt;&gt; 100 + 200 + 300600 直接可以看到结果600。 但是，写一个calc.py的文件，内容如下： 1100 + 200 + 300 然后在命令行模式下执行： 1C:\work&gt;python calc.py 发现什么输出都没有。 这是正常的。想要输出结果，必须自己用print()打印出来。把calc.py改造一下： 1print(100 + 200 + 300) 再执行，就可以看到结果： 12C:\work&gt;python calc.py600 使用文本编辑器必须要以.py结尾，其他的都不行。此外，文件名只能是英文字母、数字和下划线的组合。 直接运行py文件有同学问，能不能像.exe文件那样直接运行.py文件呢？在Windows上是不行的，但是，在Mac和Linux上是可以的，方法是在.py文件的第一行加上一个特殊的注释： 123#!/usr/bin/env python3print(&apos;hello, world&apos;) 然后，通过命令给hello.py以执行权限： 1$ chmod a+x hello.py 就可以直接运行hello.py了 输出用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出&#39;hello, world&#39;，用代码实现如下： 1&gt;&gt;&gt; print(&apos;hello, world&apos;) print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出： 12&gt;&gt;&gt; print(&apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;)The quick brown fox jumps over the lazy dog print()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的： print()也可以打印整数，或者计算结果： 1234&gt;&gt;&gt; print(300)300&gt;&gt;&gt; print(100 + 200)300 因此，我们可以把计算100 + 200的结果打印得更漂亮一点： 12&gt;&gt;&gt; print(&apos;100 + 200 =&apos;, 100 + 200)100 + 200 = 300 注意，对于100 + 200，Python解释器自动计算出结果300，但是，&#39;100 + 200 =&#39;是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。 输入现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字： 12&gt;&gt;&gt; name = input()Michael 当你输入name = input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。 输入完成后，不会有任何提示，Python交互式命令行又回到&gt;&gt;&gt;状态了。那我们刚才输入的内容到哪去了？答案是存放到name变量里了。可以直接输入name查看变量内容： 12&gt;&gt;&gt; name&apos;Michael&apos; 什么是变量？ 在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，name作为一个变量就是一个字符串。 要打印出name变量的内容，除了直接写name然后按回车外，还可以用print()函数： 12&gt;&gt;&gt; print(name)Michael 有了输入和输出，我们就可以把上次打印&#39;hello, world&#39;的程序改成有点意义的程序了： 12name = input()print(&apos;hello,&apos;, name) 运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入name变量中；第二行代码会根据用户的名字向用户说hello，比如输入Michael： 123C:\Workspace&gt; python hello.pyMichaelhello, Michael 但是程序运行的时候，没有任何提示信息告诉用户：“嘿，赶紧输入你的名字”，这样显得很不友好。幸好，input()可以让你显示一个字符串来提示用户，于是我们把代码改成： 12name = input(&apos;please enter your name: &apos;)print(&apos;hello,&apos;, name) 再次运行这个程序，你会发现，程序一运行，会首先打印出please enter your name:，这样，用户就可以根据提示，输入名字后，得到hello, xxx的输出： 123C:\Workspace&gt; python hello.pyplease enter your name: Michaelhello, Michael 每次运行该程序，根据用户输入的不同，输出结果也会不同。 小结在Python交互式模式下，可以直接输入代码，然后执行，并立刻得到结果。 在命令行模式下，可以直接运行.py文件。 参考资料：廖雪峰python]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
</search>
