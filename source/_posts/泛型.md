---
title: 泛型
tags:
  - 泛型
date: 2018-08-02 11:27:56
categories: Java
top:
---

# 泛型概述
> 是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。

<!-- more -->

## 为什么会有泛型呢?

### 问题引入
```
// 创建集合
ArrayList array = new ArrayList();

// 添加元素
array.add("hello");
array.add("world");
array.add("java");
array.add(10); // JDK5以后的自动装箱
// 等价于：array.add(Integer.valueOf(10));

// 遍历
Iterator<String> it = array.iterator();
while (it.hasNext()) {
	// ClassCastException
	// String s = (String) it.next();
	String s = it.next();
	System.out.println(s);
}
```

### 解释
因为我们开始存储的时候，存储了String和Integer两种类型的数据。	
在遍历的时候，我们把他们都当做String类型处理，所以报错	
但是呢，它在编译期间却没有告诉我们。	
集合也模仿着数组的这种做法，在创建对象的时候明确元素的数据类型。这样就不会在有问题了。		
而这种技术被称为：泛型。	

存在的问题有两个：
- 向集合中添加对象元素的时候，没有对元素的类型进行检查，也就是说，我们往集合中添加任意对象，编译器都不会报错。	
- 当我们从集合中获取一个值的时候，我们不能都使用Object类型，需要进行强制类型转换。而这个转换过程由于在添加元素的时候没有作任何的类型的限制跟检查，所以容易出错。例如上面代码中的：`String s = (String) it.next();`

### 泛型的好处
格式：
- <数据类型>
	- 此处的数据类型只能是引用类型。
	
好处：
- A:把运行时期的问题提前到了编译期间
- B:避免了强制类型转换
- C:优化了程序设计，解决了黄色警告线

## 泛型使用位置
		看API，如果类，接口，抽象类后面跟的有<E>就说要使用泛型。一般来说就是在集合中使用。
```
// 用ArrayList存储字符串元素，并遍历。用泛型改进代码
ArrayList<String> array = new ArrayList<String>();
//添加
array.add("hello");
array.add("world")'
//遍历
Iterator<String> it = array.iterator();
while(it.hasNext()){
	String s = it.next();
	System.out.println(s);
}
System.out.println("-----------------");
for (int x = 0; x < array.size(); x++) {
	String s = array.get(x);
	System.out.println(s);
}
```

## 泛型推断:JDK7的新特性
> ArrayList<Student> array = new ArrayList<>();
> 但是不建议这样使用。
	`ArrayList<Student> array = new ArrayList<Student>();`(推荐)

存储自定义对象
```
// 创建元素对象
ArrayList<Student> array = new ArrayList<Student>();

Student s1 = new Student("曹操", 40); // 后知后觉
Student s2 = new Student("蒋干", 30); // 不知不觉
Student s3 = new Student("诸葛亮", 26);// 先知先觉

// 添加元素
array.add(s1);
array.add(s2);
array.add(s3);

// 遍历
Iterator<Student> it = array.iterator();
while (it.hasNext()) {
	Student s = it.next();
	System.out.println(s.getName() + "---" + s.getAge());
}
System.out.println("------------------");

for (int x = 0; x < array.size(); x++) {
	Student s = array.get(x);
	System.out.println(s.getName() + "---" + s.getAge());
}
```

# 不用泛型之前
> 早期的时候，我们使用Object来代表任意的类型。
 向上转型是没有任何问题的，但是在向下转型的时候其实隐含了类型转换的问题。
 也就是说这样的程序其实并不是安全的。所以Java在JDK5后引入了泛型，提高程序的安全性。

```
定义类：
public class ObjectTool {
	private Object obj;

	public Object getObj() {
		return obj;
	}

	public void setObj(Object obj) { // Object obj = new Integer(30);要传入基本数据
		this.obj = obj;
	}
}

===========================================================================================

使用：
// 正常使用
ObjectTool ot = new ObjectTool();

ot.setObj(new Integer(27));
Integer i = (Integer) ot.getObj();
System.out.println("年龄是：" + i);		//年龄是：27

ot.setObj(new String("上官柳丝"));
String s = (String) ot.getObj();
System.out.println("姓名是：" + s);		//姓名是：上官柳丝

ot.setObj(new Integer(30));
// ClassCastException
String ss = (String) ot.getObj();
System.out.println("姓名是：" + ss);		// ClassCastException
```

# 使用泛型

## 泛型类
> 把泛型定义在类上
格式:public class 类名<泛型类型1,…>
注意:泛型类型必须是引用类型

```
//定义泛型类
public class ObjectTool<T> {
	private T obj;

	public T getObj() {
		return obj;
	}

	public void setObj(T obj) {
		this.obj = obj;
	}
}

====================================================
// 创建泛型类对象
ObjectTool<String> ot = new ObjectTool<String>();

// ot.setObj(new Integer(27))	//报错。编译期间就过不去

ot.setObj(new String("上官柳丝"));
String s = ot.getObj();
System.out.println("姓名是：" + s);	//姓名是：上官柳丝

-------------------------------------------------------

ObjectTool<Integer> ot2 = new ObjectTool<Integer>();
//ot2.setObj(new String("上官柳丝"));//这个时候编译期间就过不去
ot2.setObj(new Integer(27));
Integer i = ot2.getObj();
System.out.println("年龄是："+ i);	//年龄是：27
```


## 泛型方法
>　把泛型定义在方法上
　格式:public <泛型类型> 返回类型 方法名(泛型类型 .)
```
我们如果定义为泛型类，想要输出不同格式：要创建不同的对象
ObjectTool<String> ot = new ObjectTool<String>();
ot.show("hello");

ObjectTool<Integer> ot2 = new ObjectTool<Integer>();
ot2.show(100);

ObjectTool<Boolean> ot3 = new ObjectTool<Boolean>();
ot3.show(true);

我们可以将泛型定义在方法上面
-----------------------------------------------------------
public class ObjectTool(){
	public <T> void show(T t){
		System.out.println(t);
	｝
}

=======================================

使用：
ObjectTool ot = new ObjectTool();
ot.show("hello");
ot.show(100);
ot.show(true);

结果：
	hello
	100
	true
```

## 泛型接口
> 把泛型定义在接口上
 格式:public  interface 接口名<泛型类型1…>

接口的实现
- public class InterImpl implements Inter<String>｛｝
- public class `InterImpl<T>` implements `Inter<T>`{}
```
public interface Inter<T> {
	public abstract void show(T t);

}

// 测试
Inter<String> i = new InterImpl();
i.show("hello");			//hello

==================================================

//实现接口

//方式一：知道是什么类型
public class InterImpl implements Inter<String>{

	@Override
	public void show(String t) {
		// TODO Auto-generated method stub
		System.out.println(t);
	}
}

=======================================================
//方式二：不知道是什么类型
public class InterImpl<T> implements Inter<T>{

	@Override
	public void show(T t) {
		System.out.println(t);
	}
}

//测试
Inter<Stirng> i = new InterImpl<String>();
i.show("hello");	//hello
i.show(100);		//编译期间报错

Inter<Integer> ii = new InterImpl<Integer>();
ii.show("hello");	//编译期间报错
ii.show(100);		//100
```

# 泛型高级(通配符)
## 泛型通配符<?>
> 任意类型 如果没有明确 ，那么就是Object以及任意的Java类

## ? extends E
> 向下限定， E 及其子类

## ? super E
> 向上限定 E 及其父类

```
Collection<Object> c1 = new ArrayList<Object>();

// 泛型如果明确的写的时候，前后必须一致
Collection<Object> c2 = new ArrayList<Animal>();
Collection<Object> c3 = new ArrayList<Dog>();
Collection<Object> c4 = new ArrayList<Cat>();

// ?表示任意的类型都是可以的
Collection<?> c5 = new ArrayList<Object>();		
Collection<?> c6 = new ArrayList<Animal>();
Collection<?> c7 = new ArrayList<Dog>();
Collection<?> c8 = new ArrayList<Cat>();

// ? extends E:向下限定，E及其子类
// Collection<? extends Animal> c9 = new ArrayList<Object>();	//报错,Object不是Animal的子类
Collection<? extends Animal> c10 = new ArrayList<Animal>();
Collection<? extends Animal> c11 = new ArrayList<Dog>();
Collection<? extends Animal> c12 = new ArrayList<Cat>();

// ? super E:向上限定，E极其父类
Collection<? super Animal> c13 = new ArrayList<Object>();
Collection<? super Animal> c14 = new ArrayList<Animal>();
// Collection<? super Animal> c15 = new ArrayList<Dog>();		//报错,Dog是Animal子类
// Collection<? super Animal> c16 = new ArrayList<Cat>();		//报错,Animal是Animal子类


class Animal {
}

class Dog extends Animal {
}

class Cat extends Animal {
}
```	

