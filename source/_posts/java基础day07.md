---
title: java基础day07
tags:
  - 封装
  - 重载
  - 构造方法
  - 权限
  - 访问权限修饰符
  - static
date: 2018-08-06 09:03:21
categories: JavaSE
top: 
---

# 封装
> 隐藏类中的属性和实现细节,对外只提供公共的访问方式
好处
- 访问的安全性
- 方法中可以使用流程控制语句
- 只能用我们提供的公共的访问方式访问

<!-- more -->

## private 
> 私有的
> 被 private 修饰的方法和属性只能在 本类中使用

## get,set访问器
命名习惯: getXxx();setXxx();
- 只读:
	- 用 getXxx();
- 可读可写
	- 二种都用

## this 
> 本类对象
> 区分 同名的 局部变量 和 成员变量
> this(参数);调用构造器
	- 调用构造器
	- 写在构造器中
	- 作用就是来调用构造器
	- 位置在构造器的第一行代码.

# 方法的重载
> 通常是一个类中, 方法名相同,参数列表不同
> 作用: 名字方便记忆
> 返回值不能作为区分方法重载的依据

```
//注意要明确

public void f(int a ,double b){
	System.out.println("int_ double");
}

public void f(double b,int a){
	System.out.println("double_int");
}

测试:
	任意一个存在,都会自动转换为对应类型
		对象.f(22,11);	
	二个都存在;
		对象.f(22,11);	//编译出错

```

## 可变参数的重载
```
public void f(int[] arr){
	
}

public void f(int... arr){
	
}

重载失败,都是数组
===============================

public void f(int arr){
	
}

public void f(int... arr){
	
}
可以重载

对象.f(22):走的是(int arr):
	多个参数是JDK1.5之后出来的.
=================================
//参数为引用类型
public void f(String str) {

}

public void f(Demo1 demo) {

}

可以重载,但是:
	对象.f(null);	//编译不能通过
```

# 构造方法
> 名字和 类名相同
> 作用 :完成对象初始化
> 不定义任何返回类型

格式:
```
访问修饰符 构造方法名(参数列表 ){
	//初始化代码
}
```

## 构造器的分类
### 默认的分类
> 默认构造器
	- 我们类中没有显示定义构造器
	- 那么,编译器会自动创建一个默认构造器
	- 此方法无参,访问权限与类相同

> 自己定义: 显示定义了构造器 默认构造器就不存在
	1. 无参
	2. 带参 

## 构造代码块
> 执行顺序: 构造代码块 早于 构造方法
> 解决构造器重载代码冗余的作用

声明处初始化 和 构造代码块的区别
功能一样,构造块可以添加其他代码

# 成员变量初始化顺序
1. 默认初始化
2. 声明处初始化
3. 构造代码块初始化
4. 构造器初始化
> 2,3 处看代码中定义的顺序

# 构造器和普通方法的区别
1. 构造器就是用来初始化对象的
2. 普通方法是为了完成特定的功能
3. 构造只有 new 创建对象的时候才能调用;
4. 普通方法 创建对象 随时调用

# 构造器和访问器：

1. 构造是创建对象的时候new初始化。
1. 对象创建完成，所有值都赋值完成；
2. 访问器是创建对象后，完成赋值；
2. 对象创建完成，都是默认值。
3. 构造可以在创建对象是一次性给所有属性赋值；
3. 访问器需要，创建对象后一个一个赋值；
4. 创建对象后属性值的更改只能用访问器；
4. 创建对象后属性值的访问只能用访问器

# 创建对象的时候完成初始化
修改setXxxx()访问器
```
public Demo setNama(String name){
	this.name=name;
	return this;
}

----------------
// 解决了构造方法参数记忆问题
Demo d = new Demo().setName("豆沙").setAge(18);

```

# 包
管理 类 和 接口 的一种工具
程序包 一定层次结构
> 作用:
> 1.方便管理类；
> 2.解决命名冲突的问题；
> 3.更好的保护类和类中的成员。
  

package 父包名[.子类名.子类名....]

> 包名规范
	- 都小写
	- 包名唯一
	- com/org.公司名.部门名.项目名.模块名
	- package 声明必须放第一位 ,后面是导包, 类

不导包:
使用完全限定命名的方式:	包名.类 对象名 = new 包名.类名;
多次使用不建议

> 注意：
> 1. 不同包，需要使用 导入包：
> 2. 不同包，可以导包，也可以使用完全限定命名；
> 3. 导入父包，不会导入（包括）子包下的类型：
> 4. 两个包下的类同名了，用完全限定命名的方式。


> 导包:
> 	通配符: 使用\*;
> 	想要导入 b.c.Test 不能使用b.*
> 	b.*只能导入b包下的类
> 	如果二个包下类名相同, 使用完全限定命名的方式

# 访问权限修饰符
|访问权限|本类|同包|子类|不同包|
| ----- | ----- | ----- | ----- | ----- |
| private | 可以||||
| 默认|可以| 可以|||
| protected | 可以| 可以| 可以| |
| public| 可以| 可以| 可以| 可以| 

# 修饰符
## static
> 含静态的类加载过程
> 1. 先加载带主方法的类(class文件)到方法区
> 2. 堆内存:生成字节码文件对应的对象
> 3. 在方法区的空间给静态成员变量(类变量)开辟空间,初始化

- 修饰成员变量
	- 静态变量(类变量)
	- 属于类,存在方法区中
	- 类加载时,就分配空间,赋值了
	- 优先于对象存在的.
	- 被所有对象 所共享

访问：
  类名.静态
  对象名.静态// 

1. 静态变量 属于 类；
   实例变量 属于 对象；
2. 静态变量 在类加载时 就加载了，存在 方法区中；
   实例变量 在 创建对象时  创建，存在 堆中。
3. 静态变量 在 类卸载后 才释放。//应用程序结束
   实例变量 在对象 被垃圾回收 后就释放了。