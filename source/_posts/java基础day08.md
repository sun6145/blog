---
title: java基础day08
tags:
  - 静态方法
  - 继承
  - 代码块
  - 单例模式
date: 2018-08-07 09:16:32
categories: JavaSE
top: 
---
# 静态方法(类方法)
在方法前面用static 修饰	
访问:   
- 通过 类名.方法名	
- 同一个类下,可以省略类名.


<!-- more -->

注意:
- 静态方法中 只能 直接使用 静态成员(非静态,创建对象使用)
- 静态方法中不能使用 this(不需要对象就能调用) 和 super(有可能调用非静态成员) 关键字

静态方法场合:
1. 使用简单,不用创建对象
2. 有些类不能创建对象 通过调用静态方法 返回一个 对象来调用 实例方法

静态方法和实例方法的区别
1. 静态方法 只能 直接 访问静态成员
2. 实例方法 静态 与 非静态 都可以访问
3. 静态方法不能使用 this super 
4. 实例方法 可以使用 this super

```
public static 返回值 方法名 (参数列表){
	方法体;
}
```

# 代码块
## 构造块
```
类{
	{
		构造块 : 初始化 对象 new 执行, 优先于构造方法
	}
}
```

## 静态代码块
```
类{
	static{
		静态块: 作用 初始化类
	}
}
```

## 局部块(成员代码块)
- 方法中用{}扩起来
- 代码块中的变量作用域在{}中
```
方法(){
int  n ;//局部
	{
	  局部块：控制局部变量的声明周期 和 使用范围。
	}
}
```

# 静态下成员,方法,代码块的加载顺序
1. 加载 主类,静态代码块, main方法
2. 加载 使用的类 到 方法区
3. 加载 使用的类 的 静态成员 到方法区的静态区,默认初始化
4. 加载 使用的类 的 静态成员和静态代码块 声明处初始化静态成员,静态代码块.
5. 静态代码块只执行一次

顺序: 静态块 > 构造块 > 构造器

# 静态导入
格式:`import static 包名.类名.静态方法名`
可以导入某个类型下的静态成员

# 单例模式
> 保证创建的对象 始终是同一个
## 懒汉式
```
class Test2{
	private static Test2  t2 = null;
	private Test2(){

	}

	pbulic static Test2 getInstance(){
		if(t2==null){
			t2 = new Test2();
		}
		return t2;
	}
}
```

## 饿汉式
```
class Test2 {
	private static Test2 t2  = new Test2();
	private Test2(){

	}
	
	public static Test2 getInstance(){
		return t2;
	}
}
```
## 二者区别
1. 饿汉类加载时对象就创建了；
1. 懒汉在使用时，才会创建对象；
2. 饿汉多线程访问，安全；
1. 懒汉多我程访问，不妾全。

# Math类
> 针对数学的一个类
> java.lang.Math(不用导包)
> 方法都式static的

1. double ceil(double d):
	- 获取大于指定参数的最小整数
	- Math.ceil(33.4)	//34.0
2. double floor(double d)
	- 获取小于指定参数的最大整数
	- Math.floor(33.4)	//33.0
3. long round(double d)
	- 四舍五入
	- Math.round(33.5)	//34
4. double pow(double a,double b)
	- a是底
	- b是指数
	- Math.pow(2,3)	//8.0
5. double random()
	- 产生[0.1)的随机小数
	- 产生任意范围内[m,n]的随机数`(int)(Math.rando*(n-m+1)+m)`

# Random类
> java.util.Random

```
//创建对象
Random r = new Random();
r.nextInt(10);//产生[0,10)之间的随机整理
r.nextDouble();//产生随机小数[0.1)

```

# 继承
> 根据已有的类 派生出 新类的技术

优点:
1. 代码重用；
2. 方便维护，高耦合

继承的注意：
1. private 修饰的不能继承
2. 构造器不能继承,但能通过super调用
3. 不在同一包下的子类 父类使用默认修饰符的方法

继承遵循的原则:里氏替换原则(LSP):
> 将父类用子类替换,程序不会出错

## 方法重写
> @override 注解,给编译器提示信息,会检查重写规则的正误
子类重写(覆盖)了父类的方法特征：
- 实例成员的方法,在子类中,
- 方法名相同,
- 参数相同,
	- 父类参数 擦除后 与 子类相同即可
- 返回值类型相同
	- 引用类型 子类 返回值类型 可以是 父类的子类型
- 访问权限
	- 访问权限 不能比父类更严格(低)
	- 异常类型 不能比父类更大


1. 子类 修改 父类的功能
2. 子类 扩展 了父类的功能

## 子类访问父类成员
super: 父类的范围。

  调用父类的成员；
  1.区分 父类 和子类 同名的成员；
  2.super()
    调用 父类构造 。
   


## 子类访问父类的构造方法
> - 创建 子类对象时  一定 会 先调用父类构造。
> - 在子类的 构造器中 ，如果 没有 显示的调用 父类的 构造器super(),或者 没有显示的 调用 本类构造 this(),那么 编译器 一定 会 分配一个 super() 调用 父类的无参构造。
> - super() 位置 在子类 构造中 ， 而且 是第一行代码处。
> 
使用:
- super();	//	无参
- super(参数);	//带参

父类没有无参构造,只有带参构造,解决办法:
- 显示调用父类的带参构造super(参数);访问父类的带参构造
- 在父类写上无参构造

父类派生子类的前提
- 增加了属性
- 增加了方法

## 继承的传递
子类可以继承 直接父类的成员
也可以继承间接父类的成员

# Objecg类
> java.lang
> 是所有类的父类

##  方法
1. System.gc();强制垃圾回收(只是通知)
2. finalize();//回收之前调用的方法,需要在对象的类中重写
	- 该方法中的this表示回收的垃圾对象
3. equals():比较对象是否相等，地址值是否相等
4. clone():克隆一个新的对象
5. 对象.toString(): 返回对象的字符串形式，
	- getClss().getName: 获取对象的类型
	- @
	- Integer.toHexString(对象.hashCode())
	- 由以上三部分组成，无意义，建议重写
	- print()方法展示对象的时候，会隐式调用toString()

